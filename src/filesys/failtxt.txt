
build/tests/filesys/extended/dir-empty-name:     file format elf32-i386


Disassembly of section .text:

08048094 <test_main>:
#include "tests/lib.h"
#include "tests/main.h"

void
test_main (void) 
{
 8048094:	83 ec 18             	sub    $0x18,%esp
  CHECK (!mkdir (""), "mkdir \"\" (must return false)");
 8048097:	68 f9 ab 04 08       	push   $0x804abf9
 804809c:	e8 d2 00 00 00       	call   8048173 <msg>
 80480a1:	c7 04 24 25 ac 04 08 	movl   $0x804ac25,(%esp)
 80480a8:	e8 78 21 00 00       	call   804a225 <mkdir>
 80480ad:	83 c4 10             	add    $0x10,%esp
 80480b0:	84 c0                	test   %al,%al
 80480b2:	74 0d                	je     80480c1 <test_main+0x2d>
 80480b4:	83 ec 0c             	sub    $0xc,%esp
 80480b7:	68 f9 ab 04 08       	push   $0x804abf9
 80480bc:	e8 d5 00 00 00       	call   8048196 <fail>
}
 80480c1:	83 c4 0c             	add    $0xc,%esp
 80480c4:	c3                   	ret    

080480c5 <vmsg>:
const char *test_name;
bool quiet = false;

static void
vmsg (const char *format, va_list args, const char *suffix) 
{
 80480c5:	55                   	push   %ebp
 80480c6:	57                   	push   %edi
 80480c7:	56                   	push   %esi
 80480c8:	53                   	push   %ebx
 80480c9:	83 ec 1c             	sub    $0x1c,%esp
 80480cc:	89 44 24 08          	mov    %eax,0x8(%esp)
 80480d0:	89 d5                	mov    %edx,%ebp
 80480d2:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
     that'll (typically) ensure that it gets sent to the console
     atomically.  Otherwise kernel messages like "foo: exit(0)"
     can end up being interleaved if we're unlucky. */
  static char buf[1024];

  snprintf (buf, sizeof buf, "(%s) ", test_name);
 80480d6:	ff 35 84 c6 04 08    	pushl  0x804c684
 80480dc:	68 16 ac 04 08       	push   $0x804ac16
 80480e1:	68 00 04 00 00       	push   $0x400
 80480e6:	68 60 c1 04 08       	push   $0x804c160
 80480eb:	e8 35 13 00 00       	call   8049425 <snprintf>
  vsnprintf (buf + strlen (buf), sizeof buf - strlen (buf), format, args);
 80480f0:	be ff ff ff ff       	mov    $0xffffffff,%esi
 80480f5:	bf 60 c1 04 08       	mov    $0x804c160,%edi
 80480fa:	bb 00 00 00 00       	mov    $0x0,%ebx
 80480ff:	89 f1                	mov    %esi,%ecx
 8048101:	89 d8                	mov    %ebx,%eax
 8048103:	f2 ae                	repnz scas %es:(%edi),%al
 8048105:	f7 d1                	not    %ecx
 8048107:	83 e9 01             	sub    $0x1,%ecx
 804810a:	55                   	push   %ebp
 804810b:	ff 74 24 1c          	pushl  0x1c(%esp)
 804810f:	bd 00 04 00 00       	mov    $0x400,%ebp
 8048114:	89 e8                	mov    %ebp,%eax
 8048116:	29 c8                	sub    %ecx,%eax
 8048118:	50                   	push   %eax
 8048119:	81 c1 60 c1 04 08    	add    $0x804c160,%ecx
 804811f:	51                   	push   %ecx
 8048120:	e8 93 12 00 00       	call   80493b8 <vsnprintf>
  strlcpy (buf + strlen (buf), suffix, sizeof buf - strlen (buf));
 8048125:	bf 60 c1 04 08       	mov    $0x804c160,%edi
 804812a:	89 f1                	mov    %esi,%ecx
 804812c:	89 d8                	mov    %ebx,%eax
 804812e:	f2 ae                	repnz scas %es:(%edi),%al
 8048130:	f7 d1                	not    %ecx
 8048132:	83 e9 01             	sub    $0x1,%ecx
 8048135:	83 c4 1c             	add    $0x1c,%esp
 8048138:	29 cd                	sub    %ecx,%ebp
 804813a:	55                   	push   %ebp
 804813b:	ff 74 24 14          	pushl  0x14(%esp)
 804813f:	81 c1 60 c1 04 08    	add    $0x804c160,%ecx
 8048145:	51                   	push   %ecx
 8048146:	e8 b4 1b 00 00       	call   8049cff <strlcpy>
  write (STDOUT_FILENO, buf, strlen (buf));
 804814b:	bf 60 c1 04 08       	mov    $0x804c160,%edi
 8048150:	89 f1                	mov    %esi,%ecx
 8048152:	89 d8                	mov    %ebx,%eax
 8048154:	f2 ae                	repnz scas %es:(%edi),%al
 8048156:	f7 d1                	not    %ecx
 8048158:	83 e9 01             	sub    $0x1,%ecx
 804815b:	83 c4 0c             	add    $0xc,%esp
 804815e:	51                   	push   %ecx
 804815f:	68 60 c1 04 08       	push   $0x804c160
 8048164:	6a 01                	push   $0x1
 8048166:	e8 46 20 00 00       	call   804a1b1 <write>
}
 804816b:	83 c4 2c             	add    $0x2c,%esp
 804816e:	5b                   	pop    %ebx
 804816f:	5e                   	pop    %esi
 8048170:	5f                   	pop    %edi
 8048171:	5d                   	pop    %ebp
 8048172:	c3                   	ret    

08048173 <msg>:
void
msg (const char *format, ...) 
{
  va_list args;

  if (quiet)
 8048173:	80 3d 40 c1 04 08 00 	cmpb   $0x0,0x804c140
 804817a:	75 18                	jne    8048194 <msg+0x21>
  write (STDOUT_FILENO, buf, strlen (buf));
}

void
msg (const char *format, ...) 
{
 804817c:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  if (quiet)
    return;
  va_start (args, format);
  vmsg (format, args, "\n");
 804817f:	b9 24 ac 04 08       	mov    $0x804ac24,%ecx
 8048184:	8d 54 24 14          	lea    0x14(%esp),%edx
 8048188:	8b 44 24 10          	mov    0x10(%esp),%eax
 804818c:	e8 34 ff ff ff       	call   80480c5 <vmsg>
  va_end (args);
}
 8048191:	83 c4 0c             	add    $0xc,%esp
 8048194:	f3 c3                	repz ret 

08048196 <fail>:

void
fail (const char *format, ...) 
{
 8048196:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  va_start (args, format);
  vmsg (format, args, ": FAILED\n");
 8048199:	b9 1c ac 04 08       	mov    $0x804ac1c,%ecx
 804819e:	8d 54 24 14          	lea    0x14(%esp),%edx
 80481a2:	8b 44 24 10          	mov    0x10(%esp),%eax
 80481a6:	e8 1a ff ff ff       	call   80480c5 <vmsg>
  va_end (args);

  exit (1);
 80481ab:	83 ec 0c             	sub    $0xc,%esp
 80481ae:	6a 01                	push   $0x1
 80481b0:	e8 63 1f 00 00       	call   804a118 <exit>

080481b5 <shuffle>:
    }
}

void
shuffle (void *buf_, size_t cnt, size_t size) 
{
 80481b5:	55                   	push   %ebp
 80481b6:	57                   	push   %edi
 80481b7:	56                   	push   %esi
 80481b8:	53                   	push   %ebx
 80481b9:	83 ec 1c             	sub    $0x1c,%esp
 80481bc:	8b 44 24 34          	mov    0x34(%esp),%eax
  char *buf = buf_;
  size_t i;

  for (i = 0; i < cnt; i++)
 80481c0:	85 c0                	test   %eax,%eax
 80481c2:	74 71                	je     8048235 <shuffle+0x80>
 80481c4:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80481c8:	be 00 00 00 00       	mov    $0x0,%esi
 80481cd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 80481d4:	00 
    {
      size_t j = i + random_ulong () % (cnt - i);
 80481d5:	e8 52 07 00 00       	call   804892c <random_ulong>
      swap (buf + i * size, buf + j * size, size);
 80481da:	ba 00 00 00 00       	mov    $0x0,%edx
 80481df:	f7 74 24 0c          	divl   0xc(%esp)
 80481e3:	03 54 24 08          	add    0x8(%esp),%edx
 80481e7:	0f af 54 24 38       	imul   0x38(%esp),%edx
 80481ec:	89 f5                	mov    %esi,%ebp
{
  uint8_t *a = a_;
  uint8_t *b = b_;
  size_t i;

  for (i = 0; i < size; i++) 
 80481ee:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
 80481f3:	74 30                	je     8048225 <shuffle+0x70>
 80481f5:	89 f1                	mov    %esi,%ecx
 80481f7:	03 4c 24 30          	add    0x30(%esp),%ecx
 80481fb:	89 f7                	mov    %esi,%edi
 80481fd:	03 7c 24 38          	add    0x38(%esp),%edi
 8048201:	03 7c 24 30          	add    0x30(%esp),%edi
    {
      uint8_t t = a[i];
 8048205:	0f b6 19             	movzbl (%ecx),%ebx
 8048208:	88 5c 24 07          	mov    %bl,0x7(%esp)
 804820c:	89 c8                	mov    %ecx,%eax
 804820e:	29 e8                	sub    %ebp,%eax
      a[i] = b[i];
 8048210:	0f b6 1c 10          	movzbl (%eax,%edx,1),%ebx
 8048214:	88 19                	mov    %bl,(%ecx)
      b[i] = t;
 8048216:	0f b6 5c 24 07       	movzbl 0x7(%esp),%ebx
 804821b:	88 1c 10             	mov    %bl,(%eax,%edx,1)
 804821e:	83 c1 01             	add    $0x1,%ecx
{
  uint8_t *a = a_;
  uint8_t *b = b_;
  size_t i;

  for (i = 0; i < size; i++) 
 8048221:	39 f9                	cmp    %edi,%ecx
 8048223:	75 e0                	jne    8048205 <shuffle+0x50>
shuffle (void *buf_, size_t cnt, size_t size) 
{
  char *buf = buf_;
  size_t i;

  for (i = 0; i < cnt; i++)
 8048225:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
 804822a:	03 74 24 38          	add    0x38(%esp),%esi
 804822e:	83 6c 24 0c 01       	subl   $0x1,0xc(%esp)
 8048233:	75 a0                	jne    80481d5 <shuffle+0x20>
    {
      size_t j = i + random_ulong () % (cnt - i);
      swap (buf + i * size, buf + j * size, size);
    }
}
 8048235:	83 c4 1c             	add    $0x1c,%esp
 8048238:	5b                   	pop    %ebx
 8048239:	5e                   	pop    %esi
 804823a:	5f                   	pop    %edi
 804823b:	5d                   	pop    %ebp
 804823c:	c3                   	ret    

0804823d <exec_children>:

void
exec_children (const char *child_name, pid_t pids[], size_t child_cnt) 
{
 804823d:	55                   	push   %ebp
 804823e:	57                   	push   %edi
 804823f:	56                   	push   %esi
 8048240:	53                   	push   %ebx
 8048241:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
 8048247:	8b ac 24 a4 00 00 00 	mov    0xa4(%esp),%ebp
 804824e:	8b bc 24 a8 00 00 00 	mov    0xa8(%esp),%edi
  size_t i;

  for (i = 0; i < child_cnt; i++) 
 8048255:	85 ff                	test   %edi,%edi
 8048257:	74 5a                	je     80482b3 <exec_children+0x76>
 8048259:	bb 00 00 00 00       	mov    $0x0,%ebx
    {
      char cmd_line[128];
      snprintf (cmd_line, sizeof cmd_line, "%s %zu", child_name, i);
 804825e:	89 e6                	mov    %esp,%esi
 8048260:	83 ec 0c             	sub    $0xc,%esp
 8048263:	53                   	push   %ebx
 8048264:	ff b4 24 b0 00 00 00 	pushl  0xb0(%esp)
 804826b:	68 26 ac 04 08       	push   $0x804ac26
 8048270:	68 80 00 00 00       	push   $0x80
 8048275:	56                   	push   %esi
 8048276:	e8 aa 11 00 00       	call   8049425 <snprintf>
      CHECK ((pids[i] = exec (cmd_line)) != PID_ERROR,
 804827b:	83 c3 01             	add    $0x1,%ebx
 804827e:	83 c4 20             	add    $0x20,%esp
 8048281:	56                   	push   %esi
 8048282:	57                   	push   %edi
 8048283:	53                   	push   %ebx
 8048284:	68 2d ac 04 08       	push   $0x804ac2d
 8048289:	e8 e5 fe ff ff       	call   8048173 <msg>
 804828e:	89 34 24             	mov    %esi,(%esp)
 8048291:	e8 a7 1e 00 00       	call   804a13d <exec>
 8048296:	89 44 9d fc          	mov    %eax,-0x4(%ebp,%ebx,4)
 804829a:	83 c4 10             	add    $0x10,%esp
 804829d:	83 f8 ff             	cmp    $0xffffffff,%eax
 80482a0:	75 0d                	jne    80482af <exec_children+0x72>
 80482a2:	54                   	push   %esp
 80482a3:	57                   	push   %edi
 80482a4:	53                   	push   %ebx
 80482a5:	68 2d ac 04 08       	push   $0x804ac2d
 80482aa:	e8 e7 fe ff ff       	call   8048196 <fail>
void
exec_children (const char *child_name, pid_t pids[], size_t child_cnt) 
{
  size_t i;

  for (i = 0; i < child_cnt; i++) 
 80482af:	39 df                	cmp    %ebx,%edi
 80482b1:	75 ad                	jne    8048260 <exec_children+0x23>
      char cmd_line[128];
      snprintf (cmd_line, sizeof cmd_line, "%s %zu", child_name, i);
      CHECK ((pids[i] = exec (cmd_line)) != PID_ERROR,
             "exec child %zu of %zu: \"%s\"", i + 1, child_cnt, cmd_line);
    }
}
 80482b3:	81 c4 8c 00 00 00    	add    $0x8c,%esp
 80482b9:	5b                   	pop    %ebx
 80482ba:	5e                   	pop    %esi
 80482bb:	5f                   	pop    %edi
 80482bc:	5d                   	pop    %ebp
 80482bd:	c3                   	ret    

080482be <wait_children>:

void
wait_children (pid_t pids[], size_t child_cnt) 
{
 80482be:	55                   	push   %ebp
 80482bf:	57                   	push   %edi
 80482c0:	56                   	push   %esi
 80482c1:	53                   	push   %ebx
 80482c2:	83 ec 0c             	sub    $0xc,%esp
 80482c5:	8b 6c 24 24          	mov    0x24(%esp),%ebp
  size_t i;
  
  for (i = 0; i < child_cnt; i++) 
 80482c9:	85 ed                	test   %ebp,%ebp
 80482cb:	74 47                	je     8048314 <wait_children+0x56>
 80482cd:	bb 00 00 00 00       	mov    $0x0,%ebx
    {
      int status = wait (pids[i]);
 80482d2:	83 ec 0c             	sub    $0xc,%esp
 80482d5:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 80482d9:	ff 34 98             	pushl  (%eax,%ebx,4)
 80482dc:	e8 69 1e 00 00       	call   804a14a <wait>
 80482e1:	89 c7                	mov    %eax,%edi
      CHECK (status == (int) i,
 80482e3:	8d 73 01             	lea    0x1(%ebx),%esi
 80482e6:	89 1c 24             	mov    %ebx,(%esp)
 80482e9:	50                   	push   %eax
 80482ea:	55                   	push   %ebp
 80482eb:	56                   	push   %esi
 80482ec:	68 b8 ae 04 08       	push   $0x804aeb8
 80482f1:	e8 7d fe ff ff       	call   8048173 <msg>
 80482f6:	83 c4 20             	add    $0x20,%esp
 80482f9:	39 df                	cmp    %ebx,%edi
 80482fb:	74 11                	je     804830e <wait_children+0x50>
 80482fd:	83 ec 0c             	sub    $0xc,%esp
 8048300:	53                   	push   %ebx
 8048301:	57                   	push   %edi
 8048302:	55                   	push   %ebp
 8048303:	56                   	push   %esi
 8048304:	68 b8 ae 04 08       	push   $0x804aeb8
 8048309:	e8 88 fe ff ff       	call   8048196 <fail>
 804830e:	89 f3                	mov    %esi,%ebx
void
wait_children (pid_t pids[], size_t child_cnt) 
{
  size_t i;
  
  for (i = 0; i < child_cnt; i++) 
 8048310:	39 f5                	cmp    %esi,%ebp
 8048312:	75 be                	jne    80482d2 <wait_children+0x14>
      int status = wait (pids[i]);
      CHECK (status == (int) i,
             "wait for child %zu of %zu returned %d (expected %zu)",
             i + 1, child_cnt, status, i);
    }
}
 8048314:	83 c4 0c             	add    $0xc,%esp
 8048317:	5b                   	pop    %ebx
 8048318:	5e                   	pop    %esi
 8048319:	5f                   	pop    %edi
 804831a:	5d                   	pop    %ebp
 804831b:	c3                   	ret    

0804831c <compare_bytes>:
}

void
compare_bytes (const void *read_data_, const void *expected_data_, size_t size,
               size_t ofs, const char *file_name) 
{
 804831c:	55                   	push   %ebp
 804831d:	57                   	push   %edi
 804831e:	56                   	push   %esi
 804831f:	53                   	push   %ebx
 8048320:	83 ec 20             	sub    $0x20,%esp
 8048323:	8b 5c 24 34          	mov    0x34(%esp),%ebx
 8048327:	8b 74 24 38          	mov    0x38(%esp),%esi
 804832b:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
  const uint8_t *read_data = read_data_;
  const uint8_t *expected_data = expected_data_;
  size_t i, j;
  size_t show_cnt;

  if (!memcmp (read_data, expected_data, size))
 804832f:	57                   	push   %edi
 8048330:	56                   	push   %esi
 8048331:	53                   	push   %ebx
 8048332:	e8 a3 14 00 00       	call   80497da <memcmp>
 8048337:	83 c4 10             	add    $0x10,%esp
 804833a:	85 c0                	test   %eax,%eax
 804833c:	0f 84 bf 01 00 00    	je     8048501 <compare_bytes+0x1e5>
    return;
  
  for (i = 0; i < size; i++)
 8048342:	85 ff                	test   %edi,%edi
 8048344:	0f 84 7e 01 00 00    	je     80484c8 <compare_bytes+0x1ac>
    if (read_data[i] != expected_data[i])
 804834a:	0f b6 06             	movzbl (%esi),%eax
 804834d:	38 03                	cmp    %al,(%ebx)
 804834f:	0f 85 18 01 00 00    	jne    804846d <compare_bytes+0x151>
 8048355:	ba 00 00 00 00       	mov    $0x0,%edx
 804835a:	eb 0d                	jmp    8048369 <compare_bytes+0x4d>
 804835c:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
 8048361:	38 44 13 01          	cmp    %al,0x1(%ebx,%edx,1)
 8048365:	75 0b                	jne    8048372 <compare_bytes+0x56>
  size_t show_cnt;

  if (!memcmp (read_data, expected_data, size))
    return;
  
  for (i = 0; i < size; i++)
 8048367:	89 ea                	mov    %ebp,%edx
 8048369:	8d 6a 01             	lea    0x1(%edx),%ebp
 804836c:	39 ef                	cmp    %ebp,%edi
 804836e:	75 ec                	jne    804835c <compare_bytes+0x40>
 8048370:	89 fd                	mov    %edi,%ebp
    if (read_data[i] != expected_data[i])
      break;
  for (j = i + 1; j < size; j++)
 8048372:	8d 42 02             	lea    0x2(%edx),%eax
 8048375:	39 c7                	cmp    %eax,%edi
 8048377:	76 1d                	jbe    8048396 <compare_bytes+0x7a>
    if (read_data[j] == expected_data[j])
 8048379:	0f b6 4c 16 02       	movzbl 0x2(%esi,%edx,1),%ecx
 804837e:	38 4c 13 02          	cmp    %cl,0x2(%ebx,%edx,1)
 8048382:	75 0b                	jne    804838f <compare_bytes+0x73>
 8048384:	eb 10                	jmp    8048396 <compare_bytes+0x7a>
 8048386:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
 804838a:	38 0c 03             	cmp    %cl,(%ebx,%eax,1)
 804838d:	74 07                	je     8048396 <compare_bytes+0x7a>
    return;
  
  for (i = 0; i < size; i++)
    if (read_data[i] != expected_data[i])
      break;
  for (j = i + 1; j < size; j++)
 804838f:	83 c0 01             	add    $0x1,%eax
 8048392:	39 c7                	cmp    %eax,%edi
 8048394:	77 f0                	ja     8048386 <compare_bytes+0x6a>
    if (read_data[j] == expected_data[j])
      break;

  quiet = false;
 8048396:	c6 05 40 c1 04 08 00 	movb   $0x0,0x804c140
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
 804839d:	89 ef                	mov    %ebp,%edi
 804839f:	03 7c 24 3c          	add    0x3c(%esp),%edi
 80483a3:	29 e8                	sub    %ebp,%eax
 80483a5:	ff 74 24 40          	pushl  0x40(%esp)
 80483a9:	57                   	push   %edi
 80483aa:	89 44 24 14          	mov    %eax,0x14(%esp)
 80483ae:	50                   	push   %eax
 80483af:	68 f0 ae 04 08       	push   $0x804aef0
 80483b4:	e8 ba fd ff ff       	call   8048173 <msg>
       "from expected.", j - i, ofs + i, file_name);
  show_cnt = j - i;
  if (j - i > 64) 
 80483b9:	83 c4 10             	add    $0x10,%esp
  for (j = i + 1; j < size; j++)
    if (read_data[j] == expected_data[j])
      break;

  quiet = false;
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
 80483bc:	8b 44 24 0c          	mov    0xc(%esp),%eax
 80483c0:	89 44 24 08          	mov    %eax,0x8(%esp)
       "from expected.", j - i, ofs + i, file_name);
  show_cnt = j - i;
  if (j - i > 64) 
 80483c4:	83 f8 40             	cmp    $0x40,%eax
 80483c7:	76 1a                	jbe    80483e3 <compare_bytes+0xc7>
    {
      show_cnt = 64;
      msg ("Showing first differing %zu bytes.", show_cnt);
 80483c9:	83 ec 08             	sub    $0x8,%esp
 80483cc:	6a 40                	push   $0x40
 80483ce:	68 34 af 04 08       	push   $0x804af34
 80483d3:	e8 9b fd ff ff       	call   8048173 <msg>
 80483d8:	83 c4 10             	add    $0x10,%esp
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
       "from expected.", j - i, ofs + i, file_name);
  show_cnt = j - i;
  if (j - i > 64) 
    {
      show_cnt = 64;
 80483db:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
 80483e2:	00 
      msg ("Showing first differing %zu bytes.", show_cnt);
    }
  msg ("Data actually read:");
 80483e3:	83 ec 0c             	sub    $0xc,%esp
 80483e6:	68 49 ac 04 08       	push   $0x804ac49
 80483eb:	e8 83 fd ff ff       	call   8048173 <msg>
  hex_dump (ofs + i, read_data + i, show_cnt, true);
 80483f0:	6a 01                	push   $0x1
 80483f2:	ff 74 24 1c          	pushl  0x1c(%esp)
 80483f6:	01 eb                	add    %ebp,%ebx
 80483f8:	53                   	push   %ebx
 80483f9:	57                   	push   %edi
 80483fa:	e8 43 10 00 00       	call   8049442 <hex_dump>
  msg ("Expected data:");
 80483ff:	83 c4 14             	add    $0x14,%esp
 8048402:	68 5d ac 04 08       	push   $0x804ac5d
 8048407:	e8 67 fd ff ff       	call   8048173 <msg>
  hex_dump (ofs + i, expected_data + i, show_cnt, true);
 804840c:	6a 01                	push   $0x1
 804840e:	ff 74 24 1c          	pushl  0x1c(%esp)
 8048412:	01 ee                	add    %ebp,%esi
 8048414:	56                   	push   %esi
 8048415:	57                   	push   %edi
 8048416:	e8 27 10 00 00       	call   8049442 <hex_dump>
  fail ("%zu bytes read starting at offset %zu in \"%s\" differ "
 804841b:	83 c4 20             	add    $0x20,%esp
 804841e:	ff 74 24 40          	pushl  0x40(%esp)
 8048422:	57                   	push   %edi
 8048423:	ff 74 24 14          	pushl  0x14(%esp)
 8048427:	68 58 af 04 08       	push   $0x804af58
 804842c:	e8 65 fd ff ff       	call   8048196 <fail>
      break;
  for (j = i + 1; j < size; j++)
    if (read_data[j] == expected_data[j])
      break;

  quiet = false;
 8048431:	c6 05 40 c1 04 08 00 	movb   $0x0,0x804c140
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
 8048438:	ff 74 24 40          	pushl  0x40(%esp)
 804843c:	ff 74 24 40          	pushl  0x40(%esp)
 8048440:	6a 01                	push   $0x1
 8048442:	68 f0 ae 04 08       	push   $0x804aef0
 8048447:	e8 27 fd ff ff       	call   8048173 <msg>
 804844c:	83 c4 10             	add    $0x10,%esp
 804844f:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
 8048453:	bd 00 00 00 00       	mov    $0x0,%ebp
 8048458:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 804845f:	00 
 8048460:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 8048467:	00 
 8048468:	e9 76 ff ff ff       	jmp    80483e3 <compare_bytes+0xc7>
    return;
  
  for (i = 0; i < size; i++)
    if (read_data[i] != expected_data[i])
      break;
  for (j = i + 1; j < size; j++)
 804846d:	83 ff 01             	cmp    $0x1,%edi
 8048470:	77 3e                	ja     80484b0 <compare_bytes+0x194>
 8048472:	eb bd                	jmp    8048431 <compare_bytes+0x115>
    if (read_data[j] == expected_data[j])
      break;

  quiet = false;
 8048474:	c6 05 40 c1 04 08 00 	movb   $0x0,0x804c140
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
 804847b:	ff 74 24 40          	pushl  0x40(%esp)
 804847f:	ff 74 24 40          	pushl  0x40(%esp)
 8048483:	6a 01                	push   $0x1
 8048485:	68 f0 ae 04 08       	push   $0x804aef0
 804848a:	e8 e4 fc ff ff       	call   8048173 <msg>
 804848f:	83 c4 10             	add    $0x10,%esp
 8048492:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
 8048496:	bd 00 00 00 00       	mov    $0x0,%ebp
 804849b:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 80484a2:	00 
 80484a3:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 80484aa:	00 
 80484ab:	e9 33 ff ff ff       	jmp    80483e3 <compare_bytes+0xc7>
  
  for (i = 0; i < size; i++)
    if (read_data[i] != expected_data[i])
      break;
  for (j = i + 1; j < size; j++)
    if (read_data[j] == expected_data[j])
 80484b0:	0f b6 46 01          	movzbl 0x1(%esi),%eax
 80484b4:	38 43 01             	cmp    %al,0x1(%ebx)
 80484b7:	74 bb                	je     8048474 <compare_bytes+0x158>
 80484b9:	bd 00 00 00 00       	mov    $0x0,%ebp
    return;
  
  for (i = 0; i < size; i++)
    if (read_data[i] != expected_data[i])
      break;
  for (j = i + 1; j < size; j++)
 80484be:	b8 01 00 00 00       	mov    $0x1,%eax
 80484c3:	e9 c7 fe ff ff       	jmp    804838f <compare_bytes+0x73>
    if (read_data[j] == expected_data[j])
      break;

  quiet = false;
 80484c8:	c6 05 40 c1 04 08 00 	movb   $0x0,0x804c140
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
 80484cf:	ff 74 24 40          	pushl  0x40(%esp)
 80484d3:	ff 74 24 40          	pushl  0x40(%esp)
 80484d7:	6a 01                	push   $0x1
 80484d9:	68 f0 ae 04 08       	push   $0x804aef0
 80484de:	e8 90 fc ff ff       	call   8048173 <msg>
 80484e3:	83 c4 10             	add    $0x10,%esp
 80484e6:	89 fd                	mov    %edi,%ebp
 80484e8:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
 80484ec:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 80484f3:	00 
 80484f4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 80484fb:	00 
 80484fc:	e9 e2 fe ff ff       	jmp    80483e3 <compare_bytes+0xc7>
  hex_dump (ofs + i, read_data + i, show_cnt, true);
  msg ("Expected data:");
  hex_dump (ofs + i, expected_data + i, show_cnt, true);
  fail ("%zu bytes read starting at offset %zu in \"%s\" differ "
        "from expected", j - i, ofs + i, file_name);
}
 8048501:	83 c4 1c             	add    $0x1c,%esp
 8048504:	5b                   	pop    %ebx
 8048505:	5e                   	pop    %esi
 8048506:	5f                   	pop    %edi
 8048507:	5d                   	pop    %ebp
 8048508:	c3                   	ret    

08048509 <check_file_handle>:
}

void
check_file_handle (int fd,
                   const char *file_name, const void *buf_, size_t size) 
{
 8048509:	55                   	push   %ebp
 804850a:	57                   	push   %edi
 804850b:	56                   	push   %esi
 804850c:	53                   	push   %ebx
 804850d:	81 ec 28 02 00 00    	sub    $0x228,%esp
 8048513:	8b bc 24 48 02 00 00 	mov    0x248(%esp),%edi
  size_t file_size;

  /* Warn about file of wrong size.  Don't fail yet because we
     may still be able to get more information by reading the
     file. */
  file_size = filesize (fd);
 804851a:	ff b4 24 3c 02 00 00 	pushl  0x23c(%esp)
 8048521:	e8 67 1c 00 00       	call   804a18d <filesize>
 8048526:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  if (file_size != size)
 804852a:	83 c4 10             	add    $0x10,%esp
 804852d:	39 f8                	cmp    %edi,%eax
 804852f:	0f 84 be 00 00 00    	je     80485f3 <check_file_handle+0xea>
    msg ("size of %s (%zu) differs from expected (%zu)",
 8048535:	57                   	push   %edi
 8048536:	50                   	push   %eax
 8048537:	ff b4 24 3c 02 00 00 	pushl  0x23c(%esp)
 804853e:	68 9c af 04 08       	push   $0x804af9c
 8048543:	e8 2b fc ff ff       	call   8048173 <msg>
          file_name, file_size, size);

  /* Read the file block-by-block, comparing data as we go. */
  while (ofs < size)
 8048548:	83 c4 10             	add    $0x10,%esp
 804854b:	85 ff                	test   %edi,%edi
 804854d:	74 75                	je     80485c4 <check_file_handle+0xbb>
}

void
check_file_handle (int fd,
                   const char *file_name, const void *buf_, size_t size) 
{
 804854f:	be 00 00 00 00       	mov    $0x0,%esi

      block_size = size - ofs;
      if (block_size > sizeof block)
        block_size = sizeof block;

      ret_val = read (fd, block, block_size);
 8048554:	8d 6c 24 10          	lea    0x10(%esp),%ebp
  while (ofs < size)
    {
      char block[512];
      size_t block_size, ret_val;

      block_size = size - ofs;
 8048558:	89 fb                	mov    %edi,%ebx
 804855a:	29 f3                	sub    %esi,%ebx
 804855c:	81 fb 00 02 00 00    	cmp    $0x200,%ebx
 8048562:	b8 00 02 00 00       	mov    $0x200,%eax
 8048567:	0f 47 d8             	cmova  %eax,%ebx
      if (block_size > sizeof block)
        block_size = sizeof block;

      ret_val = read (fd, block, block_size);
 804856a:	83 ec 04             	sub    $0x4,%esp
 804856d:	53                   	push   %ebx
 804856e:	55                   	push   %ebp
 804856f:	ff b4 24 3c 02 00 00 	pushl  0x23c(%esp)
 8048576:	e8 1f 1c 00 00       	call   804a19a <read>
      if (ret_val != block_size)
 804857b:	83 c4 10             	add    $0x10,%esp
 804857e:	39 c3                	cmp    %eax,%ebx
 8048580:	74 17                	je     8048599 <check_file_handle+0x90>
        fail ("read of %zu bytes at offset %zu in \"%s\" returned %zu",
 8048582:	83 ec 0c             	sub    $0xc,%esp
 8048585:	50                   	push   %eax
 8048586:	ff b4 24 44 02 00 00 	pushl  0x244(%esp)
 804858d:	56                   	push   %esi
 804858e:	53                   	push   %ebx
 804858f:	68 cc af 04 08       	push   $0x804afcc
 8048594:	e8 fd fb ff ff       	call   8048196 <fail>
              block_size, ofs, file_name, ret_val);

      compare_bytes (block, buf + ofs, block_size, ofs, file_name);
 8048599:	83 ec 0c             	sub    $0xc,%esp
 804859c:	ff b4 24 40 02 00 00 	pushl  0x240(%esp)
 80485a3:	56                   	push   %esi
 80485a4:	53                   	push   %ebx
 80485a5:	89 f0                	mov    %esi,%eax
 80485a7:	03 84 24 50 02 00 00 	add    0x250(%esp),%eax
 80485ae:	50                   	push   %eax
 80485af:	55                   	push   %ebp
 80485b0:	e8 67 fd ff ff       	call   804831c <compare_bytes>
      ofs += block_size;
 80485b5:	01 de                	add    %ebx,%esi
  if (file_size != size)
    msg ("size of %s (%zu) differs from expected (%zu)",
          file_name, file_size, size);

  /* Read the file block-by-block, comparing data as we go. */
  while (ofs < size)
 80485b7:	83 c4 20             	add    $0x20,%esp
 80485ba:	39 f7                	cmp    %esi,%edi
 80485bc:	77 9a                	ja     8048558 <check_file_handle+0x4f>
      compare_bytes (block, buf + ofs, block_size, ofs, file_name);
      ofs += block_size;
    }

  /* Now fail due to wrong file size. */
  if (file_size != size)
 80485be:	39 7c 24 0c          	cmp    %edi,0xc(%esp)
 80485c2:	74 16                	je     80485da <check_file_handle+0xd1>
    fail ("size of %s (%zu) differs from expected (%zu)",
 80485c4:	57                   	push   %edi
 80485c5:	ff 74 24 10          	pushl  0x10(%esp)
 80485c9:	ff b4 24 3c 02 00 00 	pushl  0x23c(%esp)
 80485d0:	68 9c af 04 08       	push   $0x804af9c
 80485d5:	e8 bc fb ff ff       	call   8048196 <fail>
          file_name, file_size, size);

  msg ("verified contents of \"%s\"", file_name);
 80485da:	83 ec 08             	sub    $0x8,%esp
 80485dd:	ff b4 24 3c 02 00 00 	pushl  0x23c(%esp)
 80485e4:	68 6c ac 04 08       	push   $0x804ac6c
 80485e9:	e8 85 fb ff ff       	call   8048173 <msg>
}
 80485ee:	83 c4 10             	add    $0x10,%esp
 80485f1:	eb 0d                	jmp    8048600 <check_file_handle+0xf7>
  if (file_size != size)
    msg ("size of %s (%zu) differs from expected (%zu)",
          file_name, file_size, size);

  /* Read the file block-by-block, comparing data as we go. */
  while (ofs < size)
 80485f3:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
 80485f8:	0f 85 51 ff ff ff    	jne    804854f <check_file_handle+0x46>
 80485fe:	eb da                	jmp    80485da <check_file_handle+0xd1>
  if (file_size != size)
    fail ("size of %s (%zu) differs from expected (%zu)",
          file_name, file_size, size);

  msg ("verified contents of \"%s\"", file_name);
}
 8048600:	81 c4 1c 02 00 00    	add    $0x21c,%esp
 8048606:	5b                   	pop    %ebx
 8048607:	5e                   	pop    %esi
 8048608:	5f                   	pop    %edi
 8048609:	5d                   	pop    %ebp
 804860a:	c3                   	ret    

0804860b <check_file>:

void
check_file (const char *file_name, const void *buf, size_t size) 
{
 804860b:	56                   	push   %esi
 804860c:	53                   	push   %ebx
 804860d:	83 ec 0c             	sub    $0xc,%esp
 8048610:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  int fd;

  CHECK ((fd = open (file_name)) > 1, "open \"%s\" for verification",
 8048614:	53                   	push   %ebx
 8048615:	68 86 ac 04 08       	push   $0x804ac86
 804861a:	e8 54 fb ff ff       	call   8048173 <msg>
 804861f:	89 1c 24             	mov    %ebx,(%esp)
 8048622:	e8 59 1b 00 00       	call   804a180 <open>
 8048627:	83 c4 10             	add    $0x10,%esp
 804862a:	83 f8 01             	cmp    $0x1,%eax
 804862d:	7f 0e                	jg     804863d <check_file+0x32>
 804862f:	83 ec 08             	sub    $0x8,%esp
 8048632:	53                   	push   %ebx
 8048633:	68 86 ac 04 08       	push   $0x804ac86
 8048638:	e8 59 fb ff ff       	call   8048196 <fail>
 804863d:	89 c6                	mov    %eax,%esi
         file_name);
  check_file_handle (fd, file_name, buf, size);
 804863f:	ff 74 24 18          	pushl  0x18(%esp)
 8048643:	ff 74 24 18          	pushl  0x18(%esp)
 8048647:	53                   	push   %ebx
 8048648:	50                   	push   %eax
 8048649:	e8 bb fe ff ff       	call   8048509 <check_file_handle>
  msg ("close \"%s\"", file_name);
 804864e:	83 c4 08             	add    $0x8,%esp
 8048651:	53                   	push   %ebx
 8048652:	68 a1 ac 04 08       	push   $0x804aca1
 8048657:	e8 17 fb ff ff       	call   8048173 <msg>
  close (fd);
 804865c:	89 34 24             	mov    %esi,(%esp)
 804865f:	e8 83 1b 00 00       	call   804a1e7 <close>
}
 8048664:	83 c4 14             	add    $0x14,%esp
 8048667:	5b                   	pop    %ebx
 8048668:	5e                   	pop    %esi
 8048669:	c3                   	ret    

0804866a <seq_test>:

void 
seq_test (const char *file_name, void *buf, size_t size, size_t initial_size,
          size_t (*block_size_func) (void),
          void (*check_func) (int fd, long ofs)) 
{
 804866a:	55                   	push   %ebp
 804866b:	57                   	push   %edi
 804866c:	56                   	push   %esi
 804866d:	53                   	push   %ebx
 804866e:	83 ec 14             	sub    $0x14,%esp
 8048671:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
  size_t ofs;
  int fd;
  
  random_bytes (buf, size);
 8048675:	ff 74 24 30          	pushl  0x30(%esp)
 8048679:	ff 74 24 30          	pushl  0x30(%esp)
 804867d:	e8 f0 01 00 00       	call   8048872 <random_bytes>
  CHECK (create (file_name, initial_size), "create \"%s\"", file_name);
 8048682:	83 c4 08             	add    $0x8,%esp
 8048685:	ff 74 24 28          	pushl  0x28(%esp)
 8048689:	68 ac ac 04 08       	push   $0x804acac
 804868e:	e8 e0 fa ff ff       	call   8048173 <msg>
 8048693:	83 c4 08             	add    $0x8,%esp
 8048696:	ff 74 24 34          	pushl  0x34(%esp)
 804869a:	ff 74 24 2c          	pushl  0x2c(%esp)
 804869e:	e8 b4 1a 00 00       	call   804a157 <create>
 80486a3:	83 c4 10             	add    $0x10,%esp
 80486a6:	84 c0                	test   %al,%al
 80486a8:	75 11                	jne    80486bb <seq_test+0x51>
 80486aa:	83 ec 08             	sub    $0x8,%esp
 80486ad:	ff 74 24 28          	pushl  0x28(%esp)
 80486b1:	68 ac ac 04 08       	push   $0x804acac
 80486b6:	e8 db fa ff ff       	call   8048196 <fail>
  CHECK ((fd = open (file_name)) > 1, "open \"%s\"", file_name);
 80486bb:	83 ec 08             	sub    $0x8,%esp
 80486be:	ff 74 24 28          	pushl  0x28(%esp)
 80486c2:	68 b8 ac 04 08       	push   $0x804acb8
 80486c7:	e8 a7 fa ff ff       	call   8048173 <msg>
 80486cc:	83 c4 04             	add    $0x4,%esp
 80486cf:	ff 74 24 2c          	pushl  0x2c(%esp)
 80486d3:	e8 a8 1a 00 00       	call   804a180 <open>
 80486d8:	89 c7                	mov    %eax,%edi
 80486da:	83 c4 10             	add    $0x10,%esp
 80486dd:	83 f8 01             	cmp    $0x1,%eax
 80486e0:	7f 11                	jg     80486f3 <seq_test+0x89>
 80486e2:	83 ec 08             	sub    $0x8,%esp
 80486e5:	ff 74 24 28          	pushl  0x28(%esp)
 80486e9:	68 b8 ac 04 08       	push   $0x804acb8
 80486ee:	e8 a3 fa ff ff       	call   8048196 <fail>

  ofs = 0;
  msg ("writing \"%s\"", file_name);
 80486f3:	83 ec 08             	sub    $0x8,%esp
 80486f6:	ff 74 24 28          	pushl  0x28(%esp)
 80486fa:	68 c2 ac 04 08       	push   $0x804acc2
 80486ff:	e8 6f fa ff ff       	call   8048173 <msg>
  while (ofs < size) 
 8048704:	83 c4 10             	add    $0x10,%esp
 8048707:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
 804870c:	74 54                	je     8048762 <seq_test+0xf8>
 804870e:	be 00 00 00 00       	mov    $0x0,%esi
    {
      size_t block_size = block_size_func ();
 8048713:	ff 54 24 30          	call   *0x30(%esp)
      if (block_size > size - ofs)
 8048717:	8b 54 24 28          	mov    0x28(%esp),%edx
 804871b:	29 f2                	sub    %esi,%edx
 804871d:	39 d0                	cmp    %edx,%eax
 804871f:	89 d3                	mov    %edx,%ebx
 8048721:	0f 46 d8             	cmovbe %eax,%ebx
        block_size = size - ofs;

      if (write (fd, buf + ofs, block_size) != (int) block_size)
 8048724:	83 ec 04             	sub    $0x4,%esp
 8048727:	53                   	push   %ebx
 8048728:	89 f0                	mov    %esi,%eax
 804872a:	03 44 24 2c          	add    0x2c(%esp),%eax
 804872e:	50                   	push   %eax
 804872f:	57                   	push   %edi
 8048730:	e8 7c 1a 00 00       	call   804a1b1 <write>
 8048735:	83 c4 10             	add    $0x10,%esp
 8048738:	39 d8                	cmp    %ebx,%eax
 804873a:	74 10                	je     804874c <seq_test+0xe2>
        fail ("write %zu bytes at offset %zu in \"%s\" failed",
 804873c:	ff 74 24 20          	pushl  0x20(%esp)
 8048740:	56                   	push   %esi
 8048741:	53                   	push   %ebx
 8048742:	68 04 b0 04 08       	push   $0x804b004
 8048747:	e8 4a fa ff ff       	call   8048196 <fail>
              block_size, ofs, file_name);

      ofs += block_size;
 804874c:	01 de                	add    %ebx,%esi
      if (check_func != NULL)
 804874e:	85 ed                	test   %ebp,%ebp
 8048750:	74 0a                	je     804875c <seq_test+0xf2>
        check_func (fd, ofs);
 8048752:	83 ec 08             	sub    $0x8,%esp
 8048755:	56                   	push   %esi
 8048756:	57                   	push   %edi
 8048757:	ff d5                	call   *%ebp
 8048759:	83 c4 10             	add    $0x10,%esp
  CHECK (create (file_name, initial_size), "create \"%s\"", file_name);
  CHECK ((fd = open (file_name)) > 1, "open \"%s\"", file_name);

  ofs = 0;
  msg ("writing \"%s\"", file_name);
  while (ofs < size) 
 804875c:	39 74 24 28          	cmp    %esi,0x28(%esp)
 8048760:	77 b1                	ja     8048713 <seq_test+0xa9>

      ofs += block_size;
      if (check_func != NULL)
        check_func (fd, ofs);
    }
  msg ("close \"%s\"", file_name);
 8048762:	83 ec 08             	sub    $0x8,%esp
 8048765:	ff 74 24 28          	pushl  0x28(%esp)
 8048769:	68 a1 ac 04 08       	push   $0x804aca1
 804876e:	e8 00 fa ff ff       	call   8048173 <msg>
  close (fd);
 8048773:	89 3c 24             	mov    %edi,(%esp)
 8048776:	e8 6c 1a 00 00       	call   804a1e7 <close>
  check_file (file_name, buf, size);
 804877b:	83 c4 0c             	add    $0xc,%esp
 804877e:	ff 74 24 2c          	pushl  0x2c(%esp)
 8048782:	ff 74 24 2c          	pushl  0x2c(%esp)
 8048786:	ff 74 24 2c          	pushl  0x2c(%esp)
 804878a:	e8 7c fe ff ff       	call   804860b <check_file>
}
 804878f:	83 c4 1c             	add    $0x1c,%esp
 8048792:	5b                   	pop    %ebx
 8048793:	5e                   	pop    %esi
 8048794:	5f                   	pop    %edi
 8048795:	5d                   	pop    %ebp
 8048796:	c3                   	ret    

08048797 <main>:
#include "tests/lib.h"
#include "tests/main.h"

int
main (int argc UNUSED, char *argv[]) 
{
 8048797:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 804879b:	83 e4 f0             	and    $0xfffffff0,%esp
 804879e:	ff 71 fc             	pushl  -0x4(%ecx)
 80487a1:	55                   	push   %ebp
 80487a2:	89 e5                	mov    %esp,%ebp
 80487a4:	51                   	push   %ecx
 80487a5:	83 ec 10             	sub    $0x10,%esp
 80487a8:	8b 41 04             	mov    0x4(%ecx),%eax
  test_name = argv[0];
 80487ab:	8b 00                	mov    (%eax),%eax
 80487ad:	a3 84 c6 04 08       	mov    %eax,0x804c684

  msg ("begin");
 80487b2:	68 cf ac 04 08       	push   $0x804accf
 80487b7:	e8 b7 f9 ff ff       	call   8048173 <msg>
  random_init (0);
 80487bc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80487c3:	e8 39 00 00 00       	call   8048801 <random_init>
  test_main ();
 80487c8:	e8 c7 f8 ff ff       	call   8048094 <test_main>
  msg ("end");
 80487cd:	c7 04 24 d5 ac 04 08 	movl   $0x804acd5,(%esp)
 80487d4:	e8 9a f9 ff ff       	call   8048173 <msg>
 80487d9:	83 c4 10             	add    $0x10,%esp
  return 0;
}
 80487dc:	b8 00 00 00 00       	mov    $0x0,%eax
 80487e1:	8b 4d fc             	mov    -0x4(%ebp),%ecx
 80487e4:	c9                   	leave  
 80487e5:	8d 61 fc             	lea    -0x4(%ecx),%esp
 80487e8:	c3                   	ret    

080487e9 <_start>:
int main (int, char *[]);
void _start (int argc, char *argv[]);

void
_start (int argc, char *argv[]) 
{
 80487e9:	83 ec 14             	sub    $0x14,%esp
  exit (main (argc, argv));
 80487ec:	ff 74 24 1c          	pushl  0x1c(%esp)
 80487f0:	ff 74 24 1c          	pushl  0x1c(%esp)
 80487f4:	e8 9e ff ff ff       	call   8048797 <main>
 80487f9:	89 04 24             	mov    %eax,(%esp)
 80487fc:	e8 17 19 00 00       	call   804a118 <exit>

08048801 <random_init>:
{
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
 8048801:	b8 00 00 00 00       	mov    $0x0,%eax
    s[i] = i;
 8048806:	88 80 80 c5 04 08    	mov    %al,0x804c580(%eax)
{
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
 804880c:	83 c0 01             	add    $0x1,%eax
 804880f:	3d 00 01 00 00       	cmp    $0x100,%eax
 8048814:	75 f0                	jne    8048806 <random_init+0x5>
}

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
 8048816:	56                   	push   %esi
 8048817:	53                   	push   %ebx
 8048818:	be 00 00 00 00       	mov    $0x0,%esi
 804881d:	b8 00 00 00 00       	mov    $0x0,%eax

  for (i = 0; i < 256; i++) 
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
    {
      j += s[i] + seedp[i % sizeof seed];
 8048822:	89 c1                	mov    %eax,%ecx
 8048824:	83 e1 03             	and    $0x3,%ecx
 8048827:	0f b6 98 80 c5 04 08 	movzbl 0x804c580(%eax),%ebx
 804882e:	89 da                	mov    %ebx,%edx
 8048830:	02 54 0c 0c          	add    0xc(%esp,%ecx,1),%dl
 8048834:	89 d1                	mov    %edx,%ecx
 8048836:	01 ce                	add    %ecx,%esi
      swap_byte (s + i, s + j);
 8048838:	89 f2                	mov    %esi,%edx
 804883a:	0f b6 ca             	movzbl %dl,%ecx
/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
  uint8_t t = *a;
  *a = *b;
 804883d:	0f b6 91 80 c5 04 08 	movzbl 0x804c580(%ecx),%edx
 8048844:	88 90 80 c5 04 08    	mov    %dl,0x804c580(%eax)
  *b = t;
 804884a:	88 99 80 c5 04 08    	mov    %bl,0x804c580(%ecx)
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
 8048850:	83 c0 01             	add    $0x1,%eax
 8048853:	3d 00 01 00 00       	cmp    $0x100,%eax
 8048858:	75 c8                	jne    8048822 <random_init+0x21>
    {
      j += s[i] + seedp[i % sizeof seed];
      swap_byte (s + i, s + j);
    }

  s_i = s_j = 0;
 804885a:	c6 05 61 c5 04 08 00 	movb   $0x0,0x804c561
 8048861:	c6 05 62 c5 04 08 00 	movb   $0x0,0x804c562
  inited = true;
 8048868:	c6 05 60 c5 04 08 01 	movb   $0x1,0x804c560
}
 804886f:	5b                   	pop    %ebx
 8048870:	5e                   	pop    %esi
 8048871:	c3                   	ret    

08048872 <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
 8048872:	55                   	push   %ebp
 8048873:	57                   	push   %edi
 8048874:	56                   	push   %esi
 8048875:	53                   	push   %ebx
 8048876:	83 ec 08             	sub    $0x8,%esp
 8048879:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
 804887d:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  uint8_t *buf;

  if (!inited)
 8048881:	80 3d 60 c5 04 08 00 	cmpb   $0x0,0x804c560
 8048888:	75 0a                	jne    8048894 <random_bytes+0x22>
    random_init (0);
 804888a:	6a 00                	push   $0x0
 804888c:	e8 70 ff ff ff       	call   8048801 <random_init>
 8048891:	83 c4 04             	add    $0x4,%esp

  for (buf = buf_; size-- > 0; buf++)
 8048894:	8d 45 ff             	lea    -0x1(%ebp),%eax
 8048897:	89 04 24             	mov    %eax,(%esp)
 804889a:	85 ed                	test   %ebp,%ebp
 804889c:	0f 84 82 00 00 00    	je     8048924 <random_bytes+0xb2>
 80488a2:	0f b6 05 62 c5 04 08 	movzbl 0x804c562,%eax
 80488a9:	88 44 24 07          	mov    %al,0x7(%esp)
 80488ad:	0f b6 35 61 c5 04 08 	movzbl 0x804c561,%esi
 80488b4:	01 dd                	add    %ebx,%ebp
 80488b6:	88 44 24 06          	mov    %al,0x6(%esp)
    {
      uint8_t s_k;
      
      s_i++;
 80488ba:	80 44 24 06 01       	addb   $0x1,0x6(%esp)
 80488bf:	0f b6 44 24 06       	movzbl 0x6(%esp),%eax
      s_j += s[s_i];
 80488c4:	0f b6 d0             	movzbl %al,%edx
 80488c7:	89 f0                	mov    %esi,%eax
 80488c9:	02 82 80 c5 04 08    	add    0x804c580(%edx),%al
 80488cf:	89 c6                	mov    %eax,%esi
      swap_byte (s + s_i, s + s_j);
 80488d1:	0f b6 c0             	movzbl %al,%eax

/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
  uint8_t t = *a;
 80488d4:	0f b6 ba 80 c5 04 08 	movzbl 0x804c580(%edx),%edi
  *a = *b;
 80488db:	0f b6 88 80 c5 04 08 	movzbl 0x804c580(%eax),%ecx
 80488e2:	88 8a 80 c5 04 08    	mov    %cl,0x804c580(%edx)
  *b = t;
 80488e8:	89 f9                	mov    %edi,%ecx
 80488ea:	88 88 80 c5 04 08    	mov    %cl,0x804c580(%eax)
      s_i++;
      s_j += s[s_i];
      swap_byte (s + s_i, s + s_j);

      s_k = s[s_i] + s[s_j];
      *buf = s[s_k];
 80488f0:	89 f8                	mov    %edi,%eax
 80488f2:	02 82 80 c5 04 08    	add    0x804c580(%edx),%al
 80488f8:	0f b6 c0             	movzbl %al,%eax
 80488fb:	0f b6 80 80 c5 04 08 	movzbl 0x804c580(%eax),%eax
 8048902:	88 03                	mov    %al,(%ebx)
  uint8_t *buf;

  if (!inited)
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
 8048904:	83 c3 01             	add    $0x1,%ebx
 8048907:	39 dd                	cmp    %ebx,%ebp
 8048909:	75 af                	jne    80488ba <random_bytes+0x48>
 804890b:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
 8048910:	0f b6 3c 24          	movzbl (%esp),%edi
 8048914:	8d 44 38 01          	lea    0x1(%eax,%edi,1),%eax
 8048918:	a2 62 c5 04 08       	mov    %al,0x804c562
 804891d:	89 f0                	mov    %esi,%eax
 804891f:	a2 61 c5 04 08       	mov    %al,0x804c561
      swap_byte (s + s_i, s + s_j);

      s_k = s[s_i] + s[s_j];
      *buf = s[s_k];
    }
}
 8048924:	83 c4 08             	add    $0x8,%esp
 8048927:	5b                   	pop    %ebx
 8048928:	5e                   	pop    %esi
 8048929:	5f                   	pop    %edi
 804892a:	5d                   	pop    %ebp
 804892b:	c3                   	ret    

0804892c <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
 804892c:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
 804892f:	6a 04                	push   $0x4
 8048931:	8d 44 24 10          	lea    0x10(%esp),%eax
 8048935:	50                   	push   %eax
 8048936:	e8 37 ff ff ff       	call   8048872 <random_bytes>
  return ul;
}
 804893b:	8b 44 24 14          	mov    0x14(%esp),%eax
 804893f:	83 c4 18             	add    $0x18,%esp
 8048942:	c3                   	ret    

08048943 <vsnprintf_helper>:
}

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
 8048943:	53                   	push   %ebx
 8048944:	8b 5c 24 08          	mov    0x8(%esp),%ebx
 8048948:	8b 44 24 0c          	mov    0xc(%esp),%eax
  struct vsnprintf_aux *aux = aux_;

  if (aux->length++ < aux->max_length)
 804894c:	8b 50 04             	mov    0x4(%eax),%edx
 804894f:	8d 4a 01             	lea    0x1(%edx),%ecx
 8048952:	89 48 04             	mov    %ecx,0x4(%eax)
 8048955:	3b 50 08             	cmp    0x8(%eax),%edx
 8048958:	7d 09                	jge    8048963 <vsnprintf_helper+0x20>
    *aux->p++ = ch;
 804895a:	8b 10                	mov    (%eax),%edx
 804895c:	8d 4a 01             	lea    0x1(%edx),%ecx
 804895f:	89 08                	mov    %ecx,(%eax)
 8048961:	88 1a                	mov    %bl,(%edx)
}
 8048963:	5b                   	pop    %ebx
 8048964:	c3                   	ret    

08048965 <output_dup>:
}

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
 8048965:	55                   	push   %ebp
 8048966:	57                   	push   %edi
 8048967:	56                   	push   %esi
 8048968:	53                   	push   %ebx
 8048969:	83 ec 0c             	sub    $0xc,%esp
 804896c:	8b 7c 24 20          	mov    0x20(%esp),%edi
  while (cnt-- > 0)
 8048970:	85 d2                	test   %edx,%edx
 8048972:	74 16                	je     804898a <output_dup+0x25>
 8048974:	89 cd                	mov    %ecx,%ebp
 8048976:	89 d3                	mov    %edx,%ebx
    output (ch, aux);
 8048978:	0f be f0             	movsbl %al,%esi
 804897b:	83 ec 08             	sub    $0x8,%esp
 804897e:	57                   	push   %edi
 804897f:	56                   	push   %esi
 8048980:	ff d5                	call   *%ebp

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
  while (cnt-- > 0)
 8048982:	83 c4 10             	add    $0x10,%esp
 8048985:	83 eb 01             	sub    $0x1,%ebx
 8048988:	75 f1                	jne    804897b <output_dup+0x16>
    output (ch, aux);
}
 804898a:	83 c4 0c             	add    $0xc,%esp
 804898d:	5b                   	pop    %ebx
 804898e:	5e                   	pop    %esi
 804898f:	5f                   	pop    %edi
 8048990:	5d                   	pop    %ebp
 8048991:	c3                   	ret    

08048992 <format_integer>:
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
                const struct integer_base *b,
                const struct printf_conversion *c,
                void (*output) (char, void *), void *aux)
{
 8048992:	55                   	push   %ebp
 8048993:	57                   	push   %edi
 8048994:	56                   	push   %esi
 8048995:	53                   	push   %ebx
 8048996:	83 ec 7c             	sub    $0x7c,%esp
 8048999:	89 c6                	mov    %eax,%esi
 804899b:	89 d7                	mov    %edx,%edi
 804899d:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
 80489a4:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
 80489ab:	00 
  if (is_signed) 
 80489ac:	84 c9                	test   %cl,%cl
 80489ae:	74 40                	je     80489f0 <format_integer+0x5e>
    {
      if (c->flags & PLUS)
 80489b0:	8b 94 24 98 00 00 00 	mov    0x98(%esp),%edx
 80489b7:	8b 12                	mov    (%edx),%edx
 80489b9:	f6 c2 02             	test   $0x2,%dl
 80489bc:	74 10                	je     80489ce <format_integer+0x3c>
        sign = negative ? '-' : '+';
 80489be:	3c 01                	cmp    $0x1,%al
 80489c0:	19 c0                	sbb    %eax,%eax
 80489c2:	83 e0 fe             	and    $0xfffffffe,%eax
 80489c5:	83 c0 2d             	add    $0x2d,%eax
 80489c8:	89 44 24 20          	mov    %eax,0x20(%esp)
 80489cc:	eb 22                	jmp    80489f0 <format_integer+0x5e>
      else if (c->flags & SPACE)
 80489ce:	f6 c2 04             	test   $0x4,%dl
 80489d1:	74 10                	je     80489e3 <format_integer+0x51>
        sign = negative ? '-' : ' ';
 80489d3:	3c 01                	cmp    $0x1,%al
 80489d5:	19 c0                	sbb    %eax,%eax
 80489d7:	83 e0 f3             	and    $0xfffffff3,%eax
 80489da:	83 c0 2d             	add    $0x2d,%eax
 80489dd:	89 44 24 20          	mov    %eax,0x20(%esp)
 80489e1:	eb 0d                	jmp    80489f0 <format_integer+0x5e>
      else if (negative)
        sign = '-';
 80489e3:	3c 01                	cmp    $0x1,%al
 80489e5:	19 c0                	sbb    %eax,%eax
 80489e7:	f7 d0                	not    %eax
 80489e9:	83 e0 2d             	and    $0x2d,%eax
 80489ec:	89 44 24 20          	mov    %eax,0x20(%esp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
 80489f0:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
 80489f7:	8b 00                	mov    (%eax),%eax
 80489f9:	89 44 24 28          	mov    %eax,0x28(%esp)
 80489fd:	83 e0 08             	and    $0x8,%eax
 8048a00:	89 44 24 2c          	mov    %eax,0x2c(%esp)
 8048a04:	89 f2                	mov    %esi,%edx
 8048a06:	09 fa                	or     %edi,%edx
 8048a08:	74 14                	je     8048a1e <format_integer+0x8c>
 8048a0a:	85 c0                	test   %eax,%eax
 8048a0c:	74 10                	je     8048a1e <format_integer+0x8c>
 8048a0e:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
 8048a15:	8b 40 08             	mov    0x8(%eax),%eax
 8048a18:	89 44 24 24          	mov    %eax,0x24(%esp)
 8048a1c:	eb 08                	jmp    8048a26 <format_integer+0x94>
 8048a1e:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
 8048a25:	00 
  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
 8048a26:	89 f8                	mov    %edi,%eax
 8048a28:	09 f0                	or     %esi,%eax
 8048a2a:	0f 84 ad 00 00 00    	je     8048add <format_integer+0x14b>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
        *cp++ = ',';
      *cp++ = b->digits[value % b->base];
 8048a30:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
 8048a37:	8b 40 04             	mov    0x4(%eax),%eax
 8048a3a:	89 44 24 18          	mov    %eax,0x18(%esp)
 8048a3e:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
 8048a45:	8b 00                	mov    (%eax),%eax
 8048a47:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048a4b:	99                   	cltd   
 8048a4c:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8048a50:	bb 00 00 00 00       	mov    $0x0,%ebx
 8048a55:	8d 6c 24 30          	lea    0x30(%esp),%ebp
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
 8048a59:	8b 44 24 28          	mov    0x28(%esp),%eax
 8048a5d:	c1 e8 05             	shr    $0x5,%eax
 8048a60:	83 e0 01             	and    $0x1,%eax
 8048a63:	88 44 24 1f          	mov    %al,0x1f(%esp)
 8048a67:	eb 2b                	jmp    8048a94 <format_integer+0x102>
 8048a69:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
 8048a6e:	74 20                	je     8048a90 <format_integer+0xfe>
 8048a70:	85 db                	test   %ebx,%ebx
 8048a72:	7e 1c                	jle    8048a90 <format_integer+0xfe>
 8048a74:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
 8048a7b:	89 d8                	mov    %ebx,%eax
 8048a7d:	99                   	cltd   
 8048a7e:	f7 79 0c             	idivl  0xc(%ecx)
 8048a81:	85 d2                	test   %edx,%edx
 8048a83:	75 0b                	jne    8048a90 <format_integer+0xfe>
        *cp++ = ',';
 8048a85:	8d 45 02             	lea    0x2(%ebp),%eax
 8048a88:	89 44 24 14          	mov    %eax,0x14(%esp)
 8048a8c:	c6 45 01 2c          	movb   $0x2c,0x1(%ebp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
 8048a90:	8b 6c 24 14          	mov    0x14(%esp),%ebp
  digit_cnt = 0;
  while (value > 0) 
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
        *cp++ = ',';
      *cp++ = b->digits[value % b->base];
 8048a94:	8d 45 01             	lea    0x1(%ebp),%eax
 8048a97:	89 44 24 14          	mov    %eax,0x14(%esp)
 8048a9b:	ff 74 24 0c          	pushl  0xc(%esp)
 8048a9f:	ff 74 24 0c          	pushl  0xc(%esp)
 8048aa3:	57                   	push   %edi
 8048aa4:	56                   	push   %esi
 8048aa5:	e8 d8 15 00 00       	call   804a082 <__umoddi3>
 8048aaa:	83 c4 10             	add    $0x10,%esp
 8048aad:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 8048ab1:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
 8048ab5:	88 45 00             	mov    %al,0x0(%ebp)
      value /= b->base;
 8048ab8:	ff 74 24 0c          	pushl  0xc(%esp)
 8048abc:	ff 74 24 0c          	pushl  0xc(%esp)
 8048ac0:	57                   	push   %edi
 8048ac1:	56                   	push   %esi
 8048ac2:	e8 9f 15 00 00       	call   804a066 <__udivdi3>
 8048ac7:	83 c4 10             	add    $0x10,%esp
 8048aca:	89 c6                	mov    %eax,%esi
 8048acc:	89 d7                	mov    %edx,%edi
      digit_cnt++;
 8048ace:	83 c3 01             	add    $0x1,%ebx
  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
 8048ad1:	89 d0                	mov    %edx,%eax
 8048ad3:	09 f0                	or     %esi,%eax
 8048ad5:	75 92                	jne    8048a69 <format_integer+0xd7>
 8048ad7:	8b 5c 24 14          	mov    0x14(%esp),%ebx
 8048adb:	eb 04                	jmp    8048ae1 <format_integer+0x14f>
  x = (c->flags & POUND) && value ? b->x : 0;

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
 8048add:	8d 5c 24 30          	lea    0x30(%esp),%ebx
  /* Append enough zeros to match precision.
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
 8048ae1:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
 8048ae8:	8b 50 08             	mov    0x8(%eax),%edx
 8048aeb:	85 d2                	test   %edx,%edx
 8048aed:	b8 01 00 00 00       	mov    $0x1,%eax
 8048af2:	0f 48 d0             	cmovs  %eax,%edx
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
 8048af5:	8d 7c 24 30          	lea    0x30(%esp),%edi
 8048af9:	89 d8                	mov    %ebx,%eax
 8048afb:	29 f8                	sub    %edi,%eax
 8048afd:	39 c2                	cmp    %eax,%edx
 8048aff:	7e 1f                	jle    8048b20 <format_integer+0x18e>
 8048b01:	8d 44 24 6f          	lea    0x6f(%esp),%eax
 8048b05:	39 c3                	cmp    %eax,%ebx
 8048b07:	73 17                	jae    8048b20 <format_integer+0x18e>
 8048b09:	89 f9                	mov    %edi,%ecx
 8048b0b:	89 c6                	mov    %eax,%esi
    *cp++ = '0';
 8048b0d:	83 c3 01             	add    $0x1,%ebx
 8048b10:	c6 43 ff 30          	movb   $0x30,-0x1(%ebx)
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
 8048b14:	89 d8                	mov    %ebx,%eax
 8048b16:	29 c8                	sub    %ecx,%eax
 8048b18:	39 c2                	cmp    %eax,%edx
 8048b1a:	7e 04                	jle    8048b20 <format_integer+0x18e>
 8048b1c:	39 f3                	cmp    %esi,%ebx
 8048b1e:	72 ed                	jb     8048b0d <format_integer+0x17b>
    *cp++ = '0';
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
 8048b20:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
 8048b25:	74 20                	je     8048b47 <format_integer+0x1b5>
 8048b27:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
 8048b2e:	83 38 08             	cmpl   $0x8,(%eax)
 8048b31:	75 14                	jne    8048b47 <format_integer+0x1b5>
 8048b33:	8d 44 24 30          	lea    0x30(%esp),%eax
 8048b37:	39 c3                	cmp    %eax,%ebx
 8048b39:	74 06                	je     8048b41 <format_integer+0x1af>
 8048b3b:	80 7b ff 30          	cmpb   $0x30,-0x1(%ebx)
 8048b3f:	74 06                	je     8048b47 <format_integer+0x1b5>
    *cp++ = '0';
 8048b41:	c6 03 30             	movb   $0x30,(%ebx)
 8048b44:	8d 5b 01             	lea    0x1(%ebx),%ebx

  /* Calculate number of pad characters to fill field width. */
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
 8048b47:	29 df                	sub    %ebx,%edi
 8048b49:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
 8048b50:	03 78 04             	add    0x4(%eax),%edi
 8048b53:	89 fe                	mov    %edi,%esi
 8048b55:	83 7c 24 24 01       	cmpl   $0x1,0x24(%esp)
 8048b5a:	19 c0                	sbb    %eax,%eax
 8048b5c:	f7 d0                	not    %eax
 8048b5e:	83 e0 02             	and    $0x2,%eax
 8048b61:	29 c6                	sub    %eax,%esi
 8048b63:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
 8048b68:	0f 95 c0             	setne  %al
 8048b6b:	0f b6 c0             	movzbl %al,%eax
 8048b6e:	29 c6                	sub    %eax,%esi
 8048b70:	b8 00 00 00 00       	mov    $0x0,%eax
 8048b75:	0f 48 f0             	cmovs  %eax,%esi
  if (pad_cnt < 0)
    pad_cnt = 0;

  /* Do output. */
  if ((c->flags & (MINUS | ZERO)) == 0)
 8048b78:	f6 44 24 28 11       	testb  $0x11,0x28(%esp)
 8048b7d:	75 20                	jne    8048b9f <format_integer+0x20d>
    output_dup (' ', pad_cnt, output, aux);
 8048b7f:	83 ec 0c             	sub    $0xc,%esp
 8048b82:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
 8048b89:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
 8048b90:	89 f2                	mov    %esi,%edx
 8048b92:	b8 20 00 00 00       	mov    $0x20,%eax
 8048b97:	e8 c9 fd ff ff       	call   8048965 <output_dup>
 8048b9c:	83 c4 10             	add    $0x10,%esp
  if (sign)
 8048b9f:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
 8048ba4:	74 18                	je     8048bbe <format_integer+0x22c>
    output (sign, aux);
 8048ba6:	83 ec 08             	sub    $0x8,%esp
 8048ba9:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
 8048bb0:	ff 74 24 2c          	pushl  0x2c(%esp)
 8048bb4:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
 8048bbb:	83 c4 10             	add    $0x10,%esp
  if (x) 
 8048bbe:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
 8048bc3:	74 2d                	je     8048bf2 <format_integer+0x260>
    {
      output ('0', aux);
 8048bc5:	83 ec 08             	sub    $0x8,%esp
 8048bc8:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
 8048bcf:	6a 30                	push   $0x30
 8048bd1:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
      output (x, aux); 
 8048bd8:	83 c4 08             	add    $0x8,%esp
 8048bdb:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
 8048be2:	0f be 44 24 30       	movsbl 0x30(%esp),%eax
 8048be7:	50                   	push   %eax
 8048be8:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
 8048bef:	83 c4 10             	add    $0x10,%esp
    }
  if (c->flags & ZERO)
 8048bf2:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
 8048bf9:	f6 00 10             	testb  $0x10,(%eax)
 8048bfc:	74 20                	je     8048c1e <format_integer+0x28c>
    output_dup ('0', pad_cnt, output, aux);
 8048bfe:	83 ec 0c             	sub    $0xc,%esp
 8048c01:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
 8048c08:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
 8048c0f:	89 f2                	mov    %esi,%edx
 8048c11:	b8 30 00 00 00       	mov    $0x30,%eax
 8048c16:	e8 4a fd ff ff       	call   8048965 <output_dup>
 8048c1b:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
 8048c1e:	8d 44 24 30          	lea    0x30(%esp),%eax
 8048c22:	39 c3                	cmp    %eax,%ebx
 8048c24:	76 2c                	jbe    8048c52 <format_integer+0x2c0>
 8048c26:	89 c7                	mov    %eax,%edi
 8048c28:	89 74 24 08          	mov    %esi,0x8(%esp)
 8048c2c:	8b b4 24 9c 00 00 00 	mov    0x9c(%esp),%esi
 8048c33:	8b ac 24 a0 00 00 00 	mov    0xa0(%esp),%ebp
    output (*--cp, aux);
 8048c3a:	83 eb 01             	sub    $0x1,%ebx
 8048c3d:	83 ec 08             	sub    $0x8,%esp
 8048c40:	55                   	push   %ebp
 8048c41:	0f be 03             	movsbl (%ebx),%eax
 8048c44:	50                   	push   %eax
 8048c45:	ff d6                	call   *%esi
      output ('0', aux);
      output (x, aux); 
    }
  if (c->flags & ZERO)
    output_dup ('0', pad_cnt, output, aux);
  while (cp > buf)
 8048c47:	83 c4 10             	add    $0x10,%esp
 8048c4a:	39 fb                	cmp    %edi,%ebx
 8048c4c:	75 ec                	jne    8048c3a <format_integer+0x2a8>
 8048c4e:	8b 74 24 08          	mov    0x8(%esp),%esi
    output (*--cp, aux);
  if (c->flags & MINUS)
 8048c52:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
 8048c59:	f6 00 01             	testb  $0x1,(%eax)
 8048c5c:	74 20                	je     8048c7e <format_integer+0x2ec>
    output_dup (' ', pad_cnt, output, aux);
 8048c5e:	83 ec 0c             	sub    $0xc,%esp
 8048c61:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
 8048c68:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
 8048c6f:	89 f2                	mov    %esi,%edx
 8048c71:	b8 20 00 00 00       	mov    $0x20,%eax
 8048c76:	e8 ea fc ff ff       	call   8048965 <output_dup>
 8048c7b:	83 c4 10             	add    $0x10,%esp
}
 8048c7e:	83 c4 7c             	add    $0x7c,%esp
 8048c81:	5b                   	pop    %ebx
 8048c82:	5e                   	pop    %esi
 8048c83:	5f                   	pop    %edi
 8048c84:	5d                   	pop    %ebp
 8048c85:	c3                   	ret    

08048c86 <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
 8048c86:	55                   	push   %ebp
 8048c87:	57                   	push   %edi
 8048c88:	56                   	push   %esi
 8048c89:	53                   	push   %ebx
 8048c8a:	83 ec 1c             	sub    $0x1c,%esp
 8048c8d:	89 c5                	mov    %eax,%ebp
 8048c8f:	89 d6                	mov    %edx,%esi
 8048c91:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
 8048c95:	8b 7c 24 34          	mov    0x34(%esp),%edi
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
 8048c99:	8b 51 04             	mov    0x4(%ecx),%edx
 8048c9c:	39 f2                	cmp    %esi,%edx
 8048c9e:	7e 6c                	jle    8048d0c <format_string+0x86>
 8048ca0:	f6 01 01             	testb  $0x1,(%ecx)
 8048ca3:	75 61                	jne    8048d06 <format_string+0x80>
    output_dup (' ', c->width - length, output, aux);
 8048ca5:	29 f2                	sub    %esi,%edx
 8048ca7:	83 ec 0c             	sub    $0xc,%esp
 8048caa:	57                   	push   %edi
 8048cab:	8b 4c 24 40          	mov    0x40(%esp),%ecx
 8048caf:	b8 20 00 00 00       	mov    $0x20,%eax
 8048cb4:	e8 ac fc ff ff       	call   8048965 <output_dup>
  for (i = 0; i < length; i++)
 8048cb9:	83 c4 10             	add    $0x10,%esp
 8048cbc:	85 f6                	test   %esi,%esi
 8048cbe:	7e 1d                	jle    8048cdd <format_string+0x57>
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
 8048cc0:	bb 00 00 00 00       	mov    $0x0,%ebx
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
    output (string[i], aux);
 8048cc5:	83 ec 08             	sub    $0x8,%esp
 8048cc8:	57                   	push   %edi
 8048cc9:	0f be 44 1d 00       	movsbl 0x0(%ebp,%ebx,1),%eax
 8048cce:	50                   	push   %eax
 8048ccf:	ff 54 24 40          	call   *0x40(%esp)
               void (*output) (char, void *), void *aux) 
{
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
 8048cd3:	83 c3 01             	add    $0x1,%ebx
 8048cd6:	83 c4 10             	add    $0x10,%esp
 8048cd9:	39 de                	cmp    %ebx,%esi
 8048cdb:	7f e8                	jg     8048cc5 <format_string+0x3f>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
 8048cdd:	8b 44 24 0c          	mov    0xc(%esp),%eax
 8048ce1:	8b 50 04             	mov    0x4(%eax),%edx
 8048ce4:	39 d6                	cmp    %edx,%esi
 8048ce6:	7d 28                	jge    8048d10 <format_string+0x8a>
 8048ce8:	f6 00 01             	testb  $0x1,(%eax)
 8048ceb:	74 23                	je     8048d10 <format_string+0x8a>
    output_dup (' ', c->width - length, output, aux);
 8048ced:	29 f2                	sub    %esi,%edx
 8048cef:	83 ec 0c             	sub    $0xc,%esp
 8048cf2:	57                   	push   %edi
 8048cf3:	8b 4c 24 40          	mov    0x40(%esp),%ecx
 8048cf7:	b8 20 00 00 00       	mov    $0x20,%eax
 8048cfc:	e8 64 fc ff ff       	call   8048965 <output_dup>
 8048d01:	83 c4 10             	add    $0x10,%esp
}
 8048d04:	eb 0a                	jmp    8048d10 <format_string+0x8a>
               void (*output) (char, void *), void *aux) 
{
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
 8048d06:	85 f6                	test   %esi,%esi
 8048d08:	7f b6                	jg     8048cc0 <format_string+0x3a>
 8048d0a:	eb e1                	jmp    8048ced <format_string+0x67>
 8048d0c:	85 f6                	test   %esi,%esi
 8048d0e:	7f b0                	jg     8048cc0 <format_string+0x3a>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
    output_dup (' ', c->width - length, output, aux);
}
 8048d10:	83 c4 1c             	add    $0x1c,%esp
 8048d13:	5b                   	pop    %ebx
 8048d14:	5e                   	pop    %esi
 8048d15:	5f                   	pop    %edi
 8048d16:	5d                   	pop    %ebp
 8048d17:	c3                   	ret    

08048d18 <printf>:
   In the kernel, the console is both the video display and first
   serial port.
   In userspace, the console is file descriptor 1. */
int
printf (const char *format, ...) 
{
 8048d18:	83 ec 0c             	sub    $0xc,%esp
  va_list args;
  int retval;

  va_start (args, format);
 8048d1b:	8d 44 24 14          	lea    0x14(%esp),%eax
  retval = vprintf (format, args);
 8048d1f:	83 ec 08             	sub    $0x8,%esp
 8048d22:	50                   	push   %eax
 8048d23:	ff 74 24 1c          	pushl  0x1c(%esp)
 8048d27:	e8 31 16 00 00       	call   804a35d <vprintf>
  va_end (args);

  return retval;
}
 8048d2c:	83 c4 1c             	add    $0x1c,%esp
 8048d2f:	c3                   	ret    

08048d30 <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
 8048d30:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  va_start (args, aux);
 8048d33:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  __vprintf (format, args, output, aux);
 8048d37:	ff 74 24 18          	pushl  0x18(%esp)
 8048d3b:	ff 74 24 18          	pushl  0x18(%esp)
 8048d3f:	50                   	push   %eax
 8048d40:	ff 74 24 1c          	pushl  0x1c(%esp)
 8048d44:	e8 04 00 00 00       	call   8048d4d <__vprintf>
  va_end (args);
}
 8048d49:	83 c4 1c             	add    $0x1c,%esp
 8048d4c:	c3                   	ret    

08048d4d <__vprintf>:
                           void (*output) (char, void *), void *aux);

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
 8048d4d:	55                   	push   %ebp
 8048d4e:	57                   	push   %edi
 8048d4f:	56                   	push   %esi
 8048d50:	53                   	push   %ebx
 8048d51:	83 ec 4c             	sub    $0x4c,%esp
 8048d54:	8b 74 24 60          	mov    0x60(%esp),%esi
 8048d58:	8b 6c 24 64          	mov    0x64(%esp),%ebp
  for (; *format != '\0'; format++)
 8048d5c:	0f b6 06             	movzbl (%esi),%eax
 8048d5f:	84 c0                	test   %al,%al
 8048d61:	0f 84 49 06 00 00    	je     80493b0 <__vprintf+0x663>
    {
      struct printf_conversion c;

      /* Literally copy non-conversions to output. */
      if (*format != '%') 
 8048d67:	3c 25                	cmp    $0x25,%al
 8048d69:	74 19                	je     8048d84 <__vprintf+0x37>
        {
          output (*format, aux);
 8048d6b:	83 ec 08             	sub    $0x8,%esp
 8048d6e:	ff 74 24 74          	pushl  0x74(%esp)
 8048d72:	0f be c0             	movsbl %al,%eax
 8048d75:	50                   	push   %eax
 8048d76:	ff 54 24 78          	call   *0x78(%esp)
          continue;
 8048d7a:	83 c4 10             	add    $0x10,%esp
 8048d7d:	89 f3                	mov    %esi,%ebx
 8048d7f:	e9 12 06 00 00       	jmp    8049396 <__vprintf+0x649>
        }
      format++;
 8048d84:	8d 5e 01             	lea    0x1(%esi),%ebx

      /* %% => %. */
      if (*format == '%') 
 8048d87:	80 7e 01 25          	cmpb   $0x25,0x1(%esi)
 8048d8b:	75 15                	jne    8048da2 <__vprintf+0x55>
        {
          output ('%', aux);
 8048d8d:	83 ec 08             	sub    $0x8,%esp
 8048d90:	ff 74 24 74          	pushl  0x74(%esp)
 8048d94:	6a 25                	push   $0x25
 8048d96:	ff 54 24 78          	call   *0x78(%esp)
          continue;
 8048d9a:	83 c4 10             	add    $0x10,%esp
 8048d9d:	e9 f4 05 00 00       	jmp    8049396 <__vprintf+0x649>
static const char *
parse_conversion (const char *format, struct printf_conversion *c,
                  va_list *args) 
{
  /* Parse flag characters. */
  c->flags = 0;
 8048da2:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
 8048da9:	00 
 8048daa:	bf 00 00 00 00       	mov    $0x0,%edi
 8048daf:	be 00 00 00 00       	mov    $0x0,%esi
 8048db4:	eb 07                	jmp    8048dbd <__vprintf+0x70>
  for (;;) 
    {
      switch (*format++) 
 8048db6:	89 cb                	mov    %ecx,%ebx
 8048db8:	bf 01 00 00 00       	mov    $0x1,%edi
 8048dbd:	8d 4b 01             	lea    0x1(%ebx),%ecx
 8048dc0:	0f b6 41 ff          	movzbl -0x1(%ecx),%eax
 8048dc4:	8d 50 e0             	lea    -0x20(%eax),%edx
 8048dc7:	80 fa 10             	cmp    $0x10,%dl
 8048dca:	77 28                	ja     8048df4 <__vprintf+0xa7>
 8048dcc:	0f b6 d2             	movzbl %dl,%edx
 8048dcf:	ff 24 95 10 a4 04 08 	jmp    *0x804a410(,%edx,4)
        {
        case '-':
          c->flags |= MINUS;
 8048dd6:	83 ce 01             	or     $0x1,%esi
 8048dd9:	eb db                	jmp    8048db6 <__vprintf+0x69>
          break;
        case '+':
          c->flags |= PLUS;
 8048ddb:	83 ce 02             	or     $0x2,%esi
 8048dde:	eb d6                	jmp    8048db6 <__vprintf+0x69>
          break;
        case ' ':
          c->flags |= SPACE;
 8048de0:	83 ce 04             	or     $0x4,%esi
 8048de3:	eb d1                	jmp    8048db6 <__vprintf+0x69>
          break;
        case '#':
          c->flags |= POUND;
 8048de5:	83 ce 08             	or     $0x8,%esi
 8048de8:	eb cc                	jmp    8048db6 <__vprintf+0x69>
          break;
        case '0':
          c->flags |= ZERO;
 8048dea:	83 ce 10             	or     $0x10,%esi
 8048ded:	eb c7                	jmp    8048db6 <__vprintf+0x69>
          break;
        case '\'':
          c->flags |= GROUP;
 8048def:	83 ce 20             	or     $0x20,%esi
 8048df2:	eb c2                	jmp    8048db6 <__vprintf+0x69>
 8048df4:	89 fa                	mov    %edi,%edx
 8048df6:	84 d2                	test   %dl,%dl
 8048df8:	74 13                	je     8048e0d <__vprintf+0xc0>
 8048dfa:	89 74 24 30          	mov    %esi,0x30(%esp)
          format--;
          goto not_a_flag;
        }
    }
 not_a_flag:
  if (c->flags & MINUS)
 8048dfe:	f7 c6 01 00 00 00    	test   $0x1,%esi
 8048e04:	74 07                	je     8048e0d <__vprintf+0xc0>
    c->flags &= ~ZERO;
 8048e06:	83 e6 ef             	and    $0xffffffef,%esi
 8048e09:	89 74 24 30          	mov    %esi,0x30(%esp)
  if (c->flags & PLUS)
 8048e0d:	8b 54 24 30          	mov    0x30(%esp),%edx
 8048e11:	f6 c2 02             	test   $0x2,%dl
 8048e14:	74 07                	je     8048e1d <__vprintf+0xd0>
    c->flags &= ~SPACE;
 8048e16:	83 e2 fb             	and    $0xfffffffb,%edx
 8048e19:	89 54 24 30          	mov    %edx,0x30(%esp)

  /* Parse field width. */
  c->width = 0;
 8048e1d:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
 8048e24:	00 
  if (*format == '*')
 8048e25:	3c 2a                	cmp    $0x2a,%al
 8048e27:	74 12                	je     8048e3b <__vprintf+0xee>
      format++;
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
 8048e29:	0f be d0             	movsbl %al,%edx
 8048e2c:	83 ea 30             	sub    $0x30,%edx
 8048e2f:	b9 00 00 00 00       	mov    $0x0,%ecx
 8048e34:	83 fa 09             	cmp    $0x9,%edx
 8048e37:	76 10                	jbe    8048e49 <__vprintf+0xfc>
 8048e39:	eb 40                	jmp    8048e7b <__vprintf+0x12e>
  /* Parse field width. */
  c->width = 0;
  if (*format == '*')
    {
      format++;
      c->width = va_arg (*args, int);
 8048e3b:	8b 45 00             	mov    0x0(%ebp),%eax
 8048e3e:	89 44 24 34          	mov    %eax,0x34(%esp)
 8048e42:	8d 6d 04             	lea    0x4(%ebp),%ebp
{
  /* Parse flag characters. */
  c->flags = 0;
  for (;;) 
    {
      switch (*format++) 
 8048e45:	89 cb                	mov    %ecx,%ebx
 8048e47:	eb 1f                	jmp    8048e68 <__vprintf+0x11b>
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
        c->width = c->width * 10 + *format - '0';
 8048e49:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
 8048e4c:	0f be c0             	movsbl %al,%eax
 8048e4f:	8d 4c 50 d0          	lea    -0x30(%eax,%edx,2),%ecx
      format++;
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
 8048e53:	83 c3 01             	add    $0x1,%ebx
 8048e56:	0f b6 03             	movzbl (%ebx),%eax
 8048e59:	0f be d0             	movsbl %al,%edx
 8048e5c:	83 ea 30             	sub    $0x30,%edx
 8048e5f:	83 fa 09             	cmp    $0x9,%edx
 8048e62:	76 e5                	jbe    8048e49 <__vprintf+0xfc>
 8048e64:	89 4c 24 34          	mov    %ecx,0x34(%esp)
        c->width = c->width * 10 + *format - '0';
    }
  if (c->width < 0) 
 8048e68:	8b 44 24 34          	mov    0x34(%esp),%eax
 8048e6c:	85 c0                	test   %eax,%eax
 8048e6e:	79 0b                	jns    8048e7b <__vprintf+0x12e>
    {
      c->width = -c->width;
 8048e70:	f7 d8                	neg    %eax
 8048e72:	89 44 24 34          	mov    %eax,0x34(%esp)
      c->flags |= MINUS;
 8048e76:	83 4c 24 30 01       	orl    $0x1,0x30(%esp)
    }
      
  /* Parse precision. */
  c->precision = -1;
 8048e7b:	c7 44 24 38 ff ff ff 	movl   $0xffffffff,0x38(%esp)
 8048e82:	ff 
  if (*format == '.') 
 8048e83:	80 3b 2e             	cmpb   $0x2e,(%ebx)
 8048e86:	0f 85 1b 05 00 00    	jne    80493a7 <__vprintf+0x65a>
    {
      format++;
      if (*format == '*') 
 8048e8c:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 8048e90:	3c 2a                	cmp    $0x2a,%al
 8048e92:	75 0f                	jne    8048ea3 <__vprintf+0x156>
        {
          format++;
 8048e94:	83 c3 02             	add    $0x2,%ebx
          c->precision = va_arg (*args, int);
 8048e97:	8b 45 00             	mov    0x0(%ebp),%eax
 8048e9a:	89 44 24 38          	mov    %eax,0x38(%esp)
 8048e9e:	8d 6d 04             	lea    0x4(%ebp),%ebp
 8048ea1:	eb 3a                	jmp    8048edd <__vprintf+0x190>
      
  /* Parse precision. */
  c->precision = -1;
  if (*format == '.') 
    {
      format++;
 8048ea3:	83 c3 01             	add    $0x1,%ebx
          format++;
          c->precision = va_arg (*args, int);
        }
      else 
        {
          c->precision = 0;
 8048ea6:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
 8048ead:	00 
          for (; isdigit (*format); format++)
 8048eae:	0f be d0             	movsbl %al,%edx
 8048eb1:	83 ea 30             	sub    $0x30,%edx
 8048eb4:	83 fa 09             	cmp    $0x9,%edx
 8048eb7:	77 39                	ja     8048ef2 <__vprintf+0x1a5>
 8048eb9:	b9 00 00 00 00       	mov    $0x0,%ecx
            c->precision = c->precision * 10 + *format - '0';
 8048ebe:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
 8048ec1:	0f be c0             	movsbl %al,%eax
 8048ec4:	8d 4c 50 d0          	lea    -0x30(%eax,%edx,2),%ecx
          c->precision = va_arg (*args, int);
        }
      else 
        {
          c->precision = 0;
          for (; isdigit (*format); format++)
 8048ec8:	83 c3 01             	add    $0x1,%ebx
 8048ecb:	0f b6 03             	movzbl (%ebx),%eax
 8048ece:	0f be d0             	movsbl %al,%edx
 8048ed1:	83 ea 30             	sub    $0x30,%edx
 8048ed4:	83 fa 09             	cmp    $0x9,%edx
 8048ed7:	76 e5                	jbe    8048ebe <__vprintf+0x171>
 8048ed9:	89 4c 24 38          	mov    %ecx,0x38(%esp)
            c->precision = c->precision * 10 + *format - '0';
        }
      if (c->precision < 0) 
 8048edd:	8b 4c 24 38          	mov    0x38(%esp),%ecx
 8048ee1:	85 c9                	test   %ecx,%ecx
 8048ee3:	79 12                	jns    8048ef7 <__vprintf+0x1aa>
        c->precision = -1;
 8048ee5:	c7 44 24 38 ff ff ff 	movl   $0xffffffff,0x38(%esp)
 8048eec:	ff 
 8048eed:	e9 b5 04 00 00       	jmp    80493a7 <__vprintf+0x65a>
    }
  if (c->precision >= 0)
 8048ef2:	b9 00 00 00 00       	mov    $0x0,%ecx
    c->flags &= ~ZERO;
 8048ef7:	83 64 24 30 ef       	andl   $0xffffffef,0x30(%esp)

  /* Parse type. */
  c->type = INT;
 8048efc:	c7 44 24 3c 03 00 00 	movl   $0x3,0x3c(%esp)
 8048f03:	00 
  switch (*format++) 
 8048f04:	8d 73 01             	lea    0x1(%ebx),%esi
 8048f07:	0f b6 03             	movzbl (%ebx),%eax
 8048f0a:	8d 50 98             	lea    -0x68(%eax),%edx
 8048f0d:	80 fa 12             	cmp    $0x12,%dl
 8048f10:	0f 87 06 01 00 00    	ja     804901c <__vprintf+0x2cf>
 8048f16:	0f b6 d2             	movzbl %dl,%edx
 8048f19:	ff 24 95 54 a4 04 08 	jmp    *0x804a454(,%edx,4)
    {
    case 'h':
      if (*format == 'h') 
 8048f20:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 8048f24:	3c 68                	cmp    $0x68,%al
 8048f26:	75 25                	jne    8048f4d <__vprintf+0x200>
        {
          format++;
 8048f28:	8d 73 02             	lea    0x2(%ebx),%esi
          c->type = CHAR;
 8048f2b:	c7 44 24 3c 01 00 00 	movl   $0x1,0x3c(%esp)
 8048f32:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8048f33:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
 8048f37:	8d 50 bb             	lea    -0x45(%eax),%edx
 8048f3a:	80 fa 33             	cmp    $0x33,%dl
 8048f3d:	0f 87 38 04 00 00    	ja     804937b <__vprintf+0x62e>
 8048f43:	0f b6 d2             	movzbl %dl,%edx
 8048f46:	ff 24 95 a0 a4 04 08 	jmp    *0x804a4a0(,%edx,4)
        {
          format++;
          c->type = CHAR;
        }
      else
        c->type = SHORT;
 8048f4d:	c7 44 24 3c 02 00 00 	movl   $0x2,0x3c(%esp)
 8048f54:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8048f55:	8d 50 bb             	lea    -0x45(%eax),%edx
 8048f58:	80 fa 33             	cmp    $0x33,%dl
 8048f5b:	0f 87 1a 04 00 00    	ja     804937b <__vprintf+0x62e>
 8048f61:	0f b6 d2             	movzbl %dl,%edx
 8048f64:	ff 24 95 70 a5 04 08 	jmp    *0x804a570(,%edx,4)
      else
        c->type = SHORT;
      break;
      
    case 'j':
      c->type = INTMAX;
 8048f6b:	c7 44 24 3c 04 00 00 	movl   $0x4,0x3c(%esp)
 8048f72:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8048f73:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 8048f77:	8d 50 bb             	lea    -0x45(%eax),%edx
 8048f7a:	80 fa 33             	cmp    $0x33,%dl
 8048f7d:	0f 87 f8 03 00 00    	ja     804937b <__vprintf+0x62e>
 8048f83:	0f b6 d2             	movzbl %dl,%edx
 8048f86:	ff 24 95 40 a6 04 08 	jmp    *0x804a640(,%edx,4)
    case 'j':
      c->type = INTMAX;
      break;

    case 'l':
      if (*format == 'l')
 8048f8d:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 8048f91:	3c 6c                	cmp    $0x6c,%al
 8048f93:	75 25                	jne    8048fba <__vprintf+0x26d>
        {
          format++;
 8048f95:	8d 73 02             	lea    0x2(%ebx),%esi
          c->type = LONGLONG;
 8048f98:	c7 44 24 3c 06 00 00 	movl   $0x6,0x3c(%esp)
 8048f9f:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8048fa0:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
 8048fa4:	8d 50 bb             	lea    -0x45(%eax),%edx
 8048fa7:	80 fa 33             	cmp    $0x33,%dl
 8048faa:	0f 87 cb 03 00 00    	ja     804937b <__vprintf+0x62e>
 8048fb0:	0f b6 d2             	movzbl %dl,%edx
 8048fb3:	ff 24 95 10 a7 04 08 	jmp    *0x804a710(,%edx,4)
        {
          format++;
          c->type = LONGLONG;
        }
      else
        c->type = LONG;
 8048fba:	c7 44 24 3c 05 00 00 	movl   $0x5,0x3c(%esp)
 8048fc1:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8048fc2:	8d 50 bb             	lea    -0x45(%eax),%edx
 8048fc5:	80 fa 33             	cmp    $0x33,%dl
 8048fc8:	0f 87 ad 03 00 00    	ja     804937b <__vprintf+0x62e>
 8048fce:	0f b6 d2             	movzbl %dl,%edx
 8048fd1:	ff 24 95 e0 a7 04 08 	jmp    *0x804a7e0(,%edx,4)
      else
        c->type = LONG;
      break;

    case 't':
      c->type = PTRDIFFT;
 8048fd8:	c7 44 24 3c 07 00 00 	movl   $0x7,0x3c(%esp)
 8048fdf:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8048fe0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 8048fe4:	8d 50 bb             	lea    -0x45(%eax),%edx
 8048fe7:	80 fa 33             	cmp    $0x33,%dl
 8048fea:	0f 87 8b 03 00 00    	ja     804937b <__vprintf+0x62e>
 8048ff0:	0f b6 d2             	movzbl %dl,%edx
 8048ff3:	ff 24 95 b0 a8 04 08 	jmp    *0x804a8b0(,%edx,4)
    case 't':
      c->type = PTRDIFFT;
      break;

    case 'z':
      c->type = SIZET;
 8048ffa:	c7 44 24 3c 08 00 00 	movl   $0x8,0x3c(%esp)
 8049001:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8049002:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 8049006:	8d 50 bb             	lea    -0x45(%eax),%edx
 8049009:	80 fa 33             	cmp    $0x33,%dl
 804900c:	0f 87 69 03 00 00    	ja     804937b <__vprintf+0x62e>
 8049012:	0f b6 d2             	movzbl %dl,%edx
 8049015:	ff 24 95 80 a9 04 08 	jmp    *0x804a980(,%edx,4)
 804901c:	8d 50 bb             	lea    -0x45(%eax),%edx
 804901f:	80 fa 33             	cmp    $0x33,%dl
 8049022:	0f 87 51 03 00 00    	ja     8049379 <__vprintf+0x62c>
 8049028:	0f b6 d2             	movzbl %dl,%edx
 804902b:	ff 24 95 50 aa 04 08 	jmp    *0x804aa50(,%edx,4)
 8049032:	89 de                	mov    %ebx,%esi
        case 'i': 
          {
            /* Signed integer conversions. */
            intmax_t value;
            
            switch (c.type) 
 8049034:	83 7c 24 3c 08       	cmpl   $0x8,0x3c(%esp)
 8049039:	0f 87 c4 00 00 00    	ja     8049103 <__vprintf+0x3b6>
 804903f:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 8049043:	ff 24 85 20 ab 04 08 	jmp    *0x804ab20(,%eax,4)
              {
              case CHAR: 
                value = (signed char) va_arg (args, int);
 804904a:	0f be 4d 00          	movsbl 0x0(%ebp),%ecx
 804904e:	89 c8                	mov    %ecx,%eax
 8049050:	99                   	cltd   
 8049051:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 8049055:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8049059:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 804905c:	e9 bb 00 00 00       	jmp    804911c <__vprintf+0x3cf>
              case SHORT:
                value = (short) va_arg (args, int);
 8049061:	0f bf 4d 00          	movswl 0x0(%ebp),%ecx
 8049065:	89 c8                	mov    %ecx,%eax
 8049067:	99                   	cltd   
 8049068:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804906c:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8049070:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 8049073:	e9 a4 00 00 00       	jmp    804911c <__vprintf+0x3cf>
              case INT:
                value = va_arg (args, int);
 8049078:	8b 4d 00             	mov    0x0(%ebp),%ecx
 804907b:	89 c8                	mov    %ecx,%eax
 804907d:	99                   	cltd   
 804907e:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 8049082:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8049086:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 8049089:	e9 8e 00 00 00       	jmp    804911c <__vprintf+0x3cf>
              case INTMAX:
                value = va_arg (args, intmax_t);
 804908e:	8b 45 00             	mov    0x0(%ebp),%eax
 8049091:	8b 55 04             	mov    0x4(%ebp),%edx
 8049094:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049098:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804909c:	8d 6d 08             	lea    0x8(%ebp),%ebp
                break;
 804909f:	eb 7b                	jmp    804911c <__vprintf+0x3cf>
              case LONG:
                value = va_arg (args, long);
 80490a1:	8b 4d 00             	mov    0x0(%ebp),%ecx
 80490a4:	89 c8                	mov    %ecx,%eax
 80490a6:	99                   	cltd   
 80490a7:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 80490ab:	89 54 24 0c          	mov    %edx,0xc(%esp)
 80490af:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 80490b2:	eb 68                	jmp    804911c <__vprintf+0x3cf>
              case LONGLONG:
                value = va_arg (args, long long);
 80490b4:	8b 45 00             	mov    0x0(%ebp),%eax
 80490b7:	8b 55 04             	mov    0x4(%ebp),%edx
 80490ba:	89 44 24 08          	mov    %eax,0x8(%esp)
 80490be:	89 54 24 0c          	mov    %edx,0xc(%esp)
 80490c2:	8d 6d 08             	lea    0x8(%ebp),%ebp
                break;
 80490c5:	eb 55                	jmp    804911c <__vprintf+0x3cf>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
 80490c7:	8b 4d 00             	mov    0x0(%ebp),%ecx
 80490ca:	89 c8                	mov    %ecx,%eax
 80490cc:	99                   	cltd   
 80490cd:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 80490d1:	89 54 24 0c          	mov    %edx,0xc(%esp)
 80490d5:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 80490d8:	eb 42                	jmp    804911c <__vprintf+0x3cf>
              case SIZET:
                value = va_arg (args, size_t);
 80490da:	8d 45 04             	lea    0x4(%ebp),%eax
 80490dd:	8b 7d 00             	mov    0x0(%ebp),%edi
 80490e0:	bd 00 00 00 00       	mov    $0x0,%ebp
 80490e5:	89 7c 24 08          	mov    %edi,0x8(%esp)
 80490e9:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
 80490ed:	89 c5                	mov    %eax,%ebp
                if (value > SIZE_MAX / 2)
 80490ef:	81 ff ff ff ff 7f    	cmp    $0x7fffffff,%edi
 80490f5:	76 25                	jbe    804911c <__vprintf+0x3cf>
                  value = value - SIZE_MAX - 1;
 80490f7:	83 44 24 08 00       	addl   $0x0,0x8(%esp)
 80490fc:	83 54 24 0c ff       	adcl   $0xffffffff,0xc(%esp)
 8049101:	eb 19                	jmp    804911c <__vprintf+0x3cf>
                break;
              default:
                NOT_REACHED ();
 8049103:	68 34 b0 04 08       	push   $0x804b034
 8049108:	68 44 ab 04 08       	push   $0x804ab44
 804910d:	68 dc 00 00 00       	push   $0xdc
 8049112:	68 e0 ac 04 08       	push   $0x804ace0
 8049117:	e8 95 0f 00 00       	call   804a0b1 <debug_panic>
              }

            format_integer (value < 0 ? -value : value,
 804911c:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 8049120:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
 8049124:	89 da                	mov    %ebx,%edx
 8049126:	c1 fa 1f             	sar    $0x1f,%edx
 8049129:	89 d7                	mov    %edx,%edi
 804912b:	31 cf                	xor    %ecx,%edi
 804912d:	89 7c 24 10          	mov    %edi,0x10(%esp)
 8049131:	89 d7                	mov    %edx,%edi
 8049133:	33 7c 24 0c          	xor    0xc(%esp),%edi
 8049137:	89 7c 24 14          	mov    %edi,0x14(%esp)
 804913b:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 804913f:	8b 5c 24 14          	mov    0x14(%esp),%ebx
 8049143:	29 d1                	sub    %edx,%ecx
 8049145:	19 d3                	sbb    %edx,%ebx
 8049147:	89 c8                	mov    %ecx,%eax
 8049149:	89 da                	mov    %ebx,%edx
 804914b:	83 ec 0c             	sub    $0xc,%esp
 804914e:	ff 74 24 78          	pushl  0x78(%esp)
 8049152:	ff 74 24 78          	pushl  0x78(%esp)
 8049156:	8d 7c 24 44          	lea    0x44(%esp),%edi
 804915a:	57                   	push   %edi
 804915b:	68 80 ab 04 08       	push   $0x804ab80
 8049160:	8b 4c 24 28          	mov    0x28(%esp),%ecx
 8049164:	c1 e9 1f             	shr    $0x1f,%ecx
 8049167:	51                   	push   %ecx
 8049168:	b9 01 00 00 00       	mov    $0x1,%ecx
 804916d:	e8 20 f8 ff ff       	call   8048992 <format_integer>
                            true, value < 0, &base_d, &c, output, aux);
          }
          break;
 8049172:	83 c4 20             	add    $0x20,%esp
 8049175:	89 f3                	mov    %esi,%ebx
 8049177:	e9 1a 02 00 00       	jmp    8049396 <__vprintf+0x649>
                break;
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
                break;
              case INT:
                value = va_arg (args, unsigned);
 804917c:	8b 75 00             	mov    0x0(%ebp),%esi
 804917f:	bf 00 00 00 00       	mov    $0x0,%edi
 8049184:	89 74 24 18          	mov    %esi,0x18(%esp)
 8049188:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
 804918c:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 804918f:	e9 9d 00 00 00       	jmp    8049231 <__vprintf+0x4e4>
            const struct integer_base *b;

            switch (c.type) 
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
 8049194:	0f b6 55 00          	movzbl 0x0(%ebp),%edx
 8049198:	89 54 24 18          	mov    %edx,0x18(%esp)
 804919c:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 80491a3:	00 
                break;
 80491a4:	89 f3                	mov    %esi,%ebx
            const struct integer_base *b;

            switch (c.type) 
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
 80491a6:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 80491a9:	e9 83 00 00 00       	jmp    8049231 <__vprintf+0x4e4>
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
 80491ae:	0f b7 55 00          	movzwl 0x0(%ebp),%edx
 80491b2:	89 54 24 18          	mov    %edx,0x18(%esp)
 80491b6:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 80491bd:	00 
                break;
 80491be:	89 f3                	mov    %esi,%ebx
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
                break;
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
 80491c0:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 80491c3:	eb 6c                	jmp    8049231 <__vprintf+0x4e4>
              case INT:
                value = va_arg (args, unsigned);
                break;
              case INTMAX:
                value = va_arg (args, uintmax_t);
 80491c5:	8b 4d 00             	mov    0x0(%ebp),%ecx
 80491c8:	8b 5d 04             	mov    0x4(%ebp),%ebx
 80491cb:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 80491cf:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
                break;
 80491d3:	89 f3                	mov    %esi,%ebx
                break;
              case INT:
                value = va_arg (args, unsigned);
                break;
              case INTMAX:
                value = va_arg (args, uintmax_t);
 80491d5:	8d 6d 08             	lea    0x8(%ebp),%ebp
                break;
 80491d8:	eb 57                	jmp    8049231 <__vprintf+0x4e4>
              case LONG:
                value = va_arg (args, unsigned long);
 80491da:	8b 4d 00             	mov    0x0(%ebp),%ecx
 80491dd:	bb 00 00 00 00       	mov    $0x0,%ebx
 80491e2:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 80491e6:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
                break;
 80491ea:	89 f3                	mov    %esi,%ebx
                break;
              case INTMAX:
                value = va_arg (args, uintmax_t);
                break;
              case LONG:
                value = va_arg (args, unsigned long);
 80491ec:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 80491ef:	eb 40                	jmp    8049231 <__vprintf+0x4e4>
              case LONGLONG:
                value = va_arg (args, unsigned long long);
 80491f1:	8b 4d 00             	mov    0x0(%ebp),%ecx
 80491f4:	8b 5d 04             	mov    0x4(%ebp),%ebx
 80491f7:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 80491fb:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
                break;
 80491ff:	89 f3                	mov    %esi,%ebx
                break;
              case LONG:
                value = va_arg (args, unsigned long);
                break;
              case LONGLONG:
                value = va_arg (args, unsigned long long);
 8049201:	8d 6d 08             	lea    0x8(%ebp),%ebp
                break;
 8049204:	eb 2b                	jmp    8049231 <__vprintf+0x4e4>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
 8049206:	8b 7d 00             	mov    0x0(%ebp),%edi
 8049209:	89 7c 24 18          	mov    %edi,0x18(%esp)
 804920d:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 8049214:	00 
#endif
                break;
 8049215:	89 f3                	mov    %esi,%ebx
                break;
              case LONGLONG:
                value = va_arg (args, unsigned long long);
                break;
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
 8049217:	8d 6d 04             	lea    0x4(%ebp),%ebp
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
#endif
                break;
 804921a:	eb 15                	jmp    8049231 <__vprintf+0x4e4>
              case SIZET:
                value = va_arg (args, size_t);
 804921c:	8b 4d 00             	mov    0x0(%ebp),%ecx
 804921f:	bb 00 00 00 00       	mov    $0x0,%ebx
 8049224:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 8049228:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
                break;
 804922c:	89 f3                	mov    %esi,%ebx
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
#endif
                break;
              case SIZET:
                value = va_arg (args, size_t);
 804922e:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
              default:
                NOT_REACHED ();
              }

            switch (*format) 
 8049231:	3c 6f                	cmp    $0x6f,%al
 8049233:	74 3b                	je     8049270 <__vprintf+0x523>
 8049235:	3c 6f                	cmp    $0x6f,%al
 8049237:	7f 06                	jg     804923f <__vprintf+0x4f2>
 8049239:	3c 58                	cmp    $0x58,%al
 804923b:	74 13                	je     8049250 <__vprintf+0x503>
 804923d:	eb 18                	jmp    8049257 <__vprintf+0x50a>
 804923f:	3c 75                	cmp    $0x75,%al
 8049241:	74 06                	je     8049249 <__vprintf+0x4fc>
 8049243:	3c 78                	cmp    $0x78,%al
 8049245:	74 30                	je     8049277 <__vprintf+0x52a>
 8049247:	eb 0e                	jmp    8049257 <__vprintf+0x50a>
              {
              case 'o': b = &base_o; break;
              case 'u': b = &base_d; break;
 8049249:	b8 80 ab 04 08       	mov    $0x804ab80,%eax
 804924e:	eb 2c                	jmp    804927c <__vprintf+0x52f>
              case 'x': b = &base_x; break;
              case 'X': b = &base_X; break;
 8049250:	b8 50 ab 04 08       	mov    $0x804ab50,%eax
 8049255:	eb 25                	jmp    804927c <__vprintf+0x52f>
              default: NOT_REACHED ();
 8049257:	68 34 b0 04 08       	push   $0x804b034
 804925c:	68 44 ab 04 08       	push   $0x804ab44
 8049261:	68 14 01 00 00       	push   $0x114
 8049266:	68 e0 ac 04 08       	push   $0x804ace0
 804926b:	e8 41 0e 00 00       	call   804a0b1 <debug_panic>
                NOT_REACHED ();
              }

            switch (*format) 
              {
              case 'o': b = &base_o; break;
 8049270:	b8 70 ab 04 08       	mov    $0x804ab70,%eax
 8049275:	eb 05                	jmp    804927c <__vprintf+0x52f>
              case 'u': b = &base_d; break;
              case 'x': b = &base_x; break;
 8049277:	b8 60 ab 04 08       	mov    $0x804ab60,%eax
              case 'X': b = &base_X; break;
              default: NOT_REACHED ();
              }

            format_integer (value, false, false, b, &c, output, aux);
 804927c:	83 ec 0c             	sub    $0xc,%esp
 804927f:	ff 74 24 78          	pushl  0x78(%esp)
 8049283:	ff 74 24 78          	pushl  0x78(%esp)
 8049287:	8d 7c 24 44          	lea    0x44(%esp),%edi
 804928b:	57                   	push   %edi
 804928c:	50                   	push   %eax
 804928d:	6a 00                	push   $0x0
 804928f:	b9 00 00 00 00       	mov    $0x0,%ecx
 8049294:	8b 44 24 38          	mov    0x38(%esp),%eax
 8049298:	8b 54 24 3c          	mov    0x3c(%esp),%edx
 804929c:	e8 f1 f6 ff ff       	call   8048992 <format_integer>
          }
          break;
 80492a1:	83 c4 20             	add    $0x20,%esp
 80492a4:	e9 ed 00 00 00       	jmp    8049396 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 80492a9:	89 de                	mov    %ebx,%esi
          break;

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
 80492ab:	8d 7d 04             	lea    0x4(%ebp),%edi
 80492ae:	8b 45 00             	mov    0x0(%ebp),%eax
 80492b1:	88 44 24 2f          	mov    %al,0x2f(%esp)
            format_string (&ch, 1, &c, output, aux);
 80492b5:	83 ec 08             	sub    $0x8,%esp
 80492b8:	ff 74 24 74          	pushl  0x74(%esp)
 80492bc:	ff 74 24 74          	pushl  0x74(%esp)
 80492c0:	8d 4c 24 40          	lea    0x40(%esp),%ecx
 80492c4:	ba 01 00 00 00       	mov    $0x1,%edx
 80492c9:	8d 44 24 3f          	lea    0x3f(%esp),%eax
 80492cd:	e8 b4 f9 ff ff       	call   8048c86 <format_string>
          }
          break;
 80492d2:	83 c4 10             	add    $0x10,%esp
 80492d5:	89 f3                	mov    %esi,%ebx
          break;

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
 80492d7:	89 fd                	mov    %edi,%ebp
            format_string (&ch, 1, &c, output, aux);
          }
          break;
 80492d9:	e9 b8 00 00 00       	jmp    8049396 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 80492de:	89 de                	mov    %ebx,%esi
          break;

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
 80492e0:	8d 7d 04             	lea    0x4(%ebp),%edi
 80492e3:	8b 5d 00             	mov    0x0(%ebp),%ebx
            if (s == NULL)
              s = "(null)";
 80492e6:	85 db                	test   %ebx,%ebx
 80492e8:	b8 d9 ac 04 08       	mov    $0x804acd9,%eax
 80492ed:	0f 44 d8             	cmove  %eax,%ebx

            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
 80492f0:	83 ec 08             	sub    $0x8,%esp
 80492f3:	51                   	push   %ecx
 80492f4:	53                   	push   %ebx
 80492f5:	e8 d9 09 00 00       	call   8049cd3 <strnlen>
 80492fa:	83 c4 08             	add    $0x8,%esp
 80492fd:	ff 74 24 74          	pushl  0x74(%esp)
 8049301:	ff 74 24 74          	pushl  0x74(%esp)
 8049305:	8d 4c 24 40          	lea    0x40(%esp),%ecx
 8049309:	89 c2                	mov    %eax,%edx
 804930b:	89 d8                	mov    %ebx,%eax
 804930d:	e8 74 f9 ff ff       	call   8048c86 <format_string>
          }
          break;
 8049312:	83 c4 10             	add    $0x10,%esp
 8049315:	89 f3                	mov    %esi,%ebx
          break;

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
 8049317:	89 fd                	mov    %edi,%ebp
            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
          }
          break;
 8049319:	eb 7b                	jmp    8049396 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 804931b:	89 de                	mov    %ebx,%esi
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
 804931d:	8d 7d 04             	lea    0x4(%ebp),%edi
 8049320:	8b 45 00             	mov    0x0(%ebp),%eax

            c.flags = POUND;
 8049323:	c7 44 24 30 08 00 00 	movl   $0x8,0x30(%esp)
 804932a:	00 
            format_integer ((uintptr_t) p, false, false,
 804932b:	ba 00 00 00 00       	mov    $0x0,%edx
 8049330:	83 ec 0c             	sub    $0xc,%esp
 8049333:	ff 74 24 78          	pushl  0x78(%esp)
 8049337:	ff 74 24 78          	pushl  0x78(%esp)
 804933b:	8d 4c 24 44          	lea    0x44(%esp),%ecx
 804933f:	51                   	push   %ecx
 8049340:	68 60 ab 04 08       	push   $0x804ab60
 8049345:	6a 00                	push   $0x0
 8049347:	b9 00 00 00 00       	mov    $0x0,%ecx
 804934c:	e8 41 f6 ff ff       	call   8048992 <format_integer>
                            &base_x, &c, output, aux);
          }
          break;
 8049351:	83 c4 20             	add    $0x20,%esp
 8049354:	89 f3                	mov    %esi,%ebx
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
 8049356:	89 fd                	mov    %edi,%ebp

            c.flags = POUND;
            format_integer ((uintptr_t) p, false, false,
                            &base_x, &c, output, aux);
          }
          break;
 8049358:	eb 3c                	jmp    8049396 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 804935a:	89 de                	mov    %ebx,%esi
        case 'g':
        case 'G':
        case 'n':
          /* We don't support floating-point arithmetic,
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
 804935c:	0f be c0             	movsbl %al,%eax
 804935f:	50                   	push   %eax
 8049360:	ff 74 24 70          	pushl  0x70(%esp)
 8049364:	ff 74 24 70          	pushl  0x70(%esp)
 8049368:	68 f2 ac 04 08       	push   $0x804acf2
 804936d:	e8 be f9 ff ff       	call   8048d30 <__printf>
          break;
 8049372:	83 c4 10             	add    $0x10,%esp
 8049375:	89 f3                	mov    %esi,%ebx
 8049377:	eb 1d                	jmp    8049396 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8049379:	89 de                	mov    %ebx,%esi
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
          break;

        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
 804937b:	0f be c0             	movsbl %al,%eax
 804937e:	50                   	push   %eax
 804937f:	ff 74 24 70          	pushl  0x70(%esp)
 8049383:	ff 74 24 70          	pushl  0x70(%esp)
 8049387:	68 08 ad 04 08       	push   $0x804ad08
 804938c:	e8 9f f9 ff ff       	call   8048d30 <__printf>
          break;
 8049391:	83 c4 10             	add    $0x10,%esp
 8049394:	89 f3                	mov    %esi,%ebx

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
  for (; *format != '\0'; format++)
 8049396:	8d 73 01             	lea    0x1(%ebx),%esi
 8049399:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 804939d:	84 c0                	test   %al,%al
 804939f:	0f 85 c2 f9 ff ff    	jne    8048d67 <__vprintf+0x1a>
 80493a5:	eb 09                	jmp    80493b0 <__vprintf+0x663>
            c->precision = c->precision * 10 + *format - '0';
        }
      if (c->precision < 0) 
        c->precision = -1;
    }
  if (c->precision >= 0)
 80493a7:	8b 4c 24 38          	mov    0x38(%esp),%ecx
 80493ab:	e9 4c fb ff ff       	jmp    8048efc <__vprintf+0x1af>
        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
          break;
        }
    }
}
 80493b0:	83 c4 4c             	add    $0x4c,%esp
 80493b3:	5b                   	pop    %ebx
 80493b4:	5e                   	pop    %esi
 80493b5:	5f                   	pop    %edi
 80493b6:	5d                   	pop    %ebp
 80493b7:	c3                   	ret    

080493b8 <vsnprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) 
{
 80493b8:	53                   	push   %ebx
 80493b9:	83 ec 18             	sub    $0x18,%esp
 80493bc:	8b 44 24 24          	mov    0x24(%esp),%eax
 80493c0:	8b 54 24 28          	mov    0x28(%esp),%edx
 80493c4:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
 80493c8:	8b 5c 24 20          	mov    0x20(%esp),%ebx
 80493cc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  aux.length = 0;
 80493d0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 80493d7:	00 
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
 80493d8:	85 c0                	test   %eax,%eax
 80493da:	74 24                	je     8049400 <vsnprintf+0x48>
 80493dc:	83 e8 01             	sub    $0x1,%eax
 80493df:	89 44 24 0c          	mov    %eax,0xc(%esp)

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
 80493e3:	8d 44 24 04          	lea    0x4(%esp),%eax
 80493e7:	50                   	push   %eax
 80493e8:	68 43 89 04 08       	push   $0x8048943
 80493ed:	51                   	push   %ecx
 80493ee:	52                   	push   %edx
 80493ef:	e8 59 f9 ff ff       	call   8048d4d <__vprintf>

  /* Add null terminator. */
  if (buf_size > 0)
    *aux.p = '\0';
 80493f4:	8b 44 24 14          	mov    0x14(%esp),%eax
 80493f8:	c6 00 00             	movb   $0x0,(%eax)
 80493fb:	83 c4 10             	add    $0x10,%esp
 80493fe:	eb 1c                	jmp    804941c <vsnprintf+0x64>
{
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
  aux.length = 0;
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
 8049400:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 8049407:	00 

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
 8049408:	8d 44 24 04          	lea    0x4(%esp),%eax
 804940c:	50                   	push   %eax
 804940d:	68 43 89 04 08       	push   $0x8048943
 8049412:	51                   	push   %ecx
 8049413:	52                   	push   %edx
 8049414:	e8 34 f9 ff ff       	call   8048d4d <__vprintf>
 8049419:	83 c4 10             	add    $0x10,%esp

  /* Add null terminator. */
  if (buf_size > 0)
    *aux.p = '\0';

  return aux.length;
 804941c:	8b 44 24 08          	mov    0x8(%esp),%eax
}
 8049420:	83 c4 18             	add    $0x18,%esp
 8049423:	5b                   	pop    %ebx
 8049424:	c3                   	ret    

08049425 <snprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
snprintf (char *buffer, size_t buf_size, const char *format, ...) 
{
 8049425:	83 ec 0c             	sub    $0xc,%esp
  va_list args;
  int retval;

  va_start (args, format);
 8049428:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  retval = vsnprintf (buffer, buf_size, format, args);
 804942c:	50                   	push   %eax
 804942d:	ff 74 24 1c          	pushl  0x1c(%esp)
 8049431:	ff 74 24 1c          	pushl  0x1c(%esp)
 8049435:	ff 74 24 1c          	pushl  0x1c(%esp)
 8049439:	e8 7a ff ff ff       	call   80493b8 <vsnprintf>
  va_end (args);

  return retval;
}
 804943e:	83 c4 1c             	add    $0x1c,%esp
 8049441:	c3                   	ret    

08049442 <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
 8049442:	55                   	push   %ebp
 8049443:	57                   	push   %edi
 8049444:	56                   	push   %esi
 8049445:	53                   	push   %ebx
 8049446:	83 ec 1c             	sub    $0x1c,%esp
 8049449:	0f b6 44 24 3c       	movzbl 0x3c(%esp),%eax
 804944e:	88 44 24 0f          	mov    %al,0xf(%esp)
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
 8049452:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
 8049457:	0f 84 cb 01 00 00    	je     8049628 <hex_dump+0x1e6>
    {
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
 804945d:	8b 74 24 30          	mov    0x30(%esp),%esi
 8049461:	83 e6 0f             	and    $0xf,%esi
      end = per_line;
      if (end - start > size)
 8049464:	b8 10 00 00 00       	mov    $0x10,%eax
 8049469:	29 f0                	sub    %esi,%eax
 804946b:	89 44 24 08          	mov    %eax,0x8(%esp)
 804946f:	3b 44 24 38          	cmp    0x38(%esp),%eax
 8049473:	0f 86 6e 01 00 00    	jbe    80495e7 <hex_dump+0x1a5>
        end = start + size;
 8049479:	89 f7                	mov    %esi,%edi
 804947b:	03 7c 24 38          	add    0x38(%esp),%edi
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
 804947f:	83 ec 04             	sub    $0x4,%esp
 8049482:	8b 44 24 34          	mov    0x34(%esp),%eax
 8049486:	83 e0 f0             	and    $0xfffffff0,%eax
 8049489:	ba 00 00 00 00       	mov    $0x0,%edx
 804948e:	52                   	push   %edx
 804948f:	50                   	push   %eax
 8049490:	68 1f ad 04 08       	push   $0x804ad1f
 8049495:	e8 7e f8 ff ff       	call   8048d18 <printf>
      for (i = 0; i < start; i++)
 804949a:	83 c4 10             	add    $0x10,%esp
 804949d:	85 f6                	test   %esi,%esi
 804949f:	74 26                	je     80494c7 <hex_dump+0x85>
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
      if (end - start > size)
        end = start + size;
      n = end - start;
 80494a1:	8b 44 24 38          	mov    0x38(%esp),%eax
 80494a5:	89 44 24 08          	mov    %eax,0x8(%esp)
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
 80494a9:	bb 00 00 00 00       	mov    $0x0,%ebx
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
 80494ae:	83 ec 0c             	sub    $0xc,%esp
 80494b1:	68 27 ad 04 08       	push   $0x804ad27
 80494b6:	e8 5d f8 ff ff       	call   8048d18 <printf>
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
 80494bb:	83 c3 01             	add    $0x1,%ebx
 80494be:	83 c4 10             	add    $0x10,%esp
 80494c1:	39 de                	cmp    %ebx,%esi
 80494c3:	77 e9                	ja     80494ae <hex_dump+0x6c>
 80494c5:	eb 0a                	jmp    80494d1 <hex_dump+0x8f>
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
      if (end - start > size)
        end = start + size;
      n = end - start;
 80494c7:	8b 44 24 38          	mov    0x38(%esp),%eax
 80494cb:	89 44 24 08          	mov    %eax,0x8(%esp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
 80494cf:	89 f3                	mov    %esi,%ebx
        printf ("   ");
      for (; i < end; i++) 
 80494d1:	39 df                	cmp    %ebx,%edi
 80494d3:	76 34                	jbe    8049509 <hex_dump+0xc7>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
 80494d5:	8b 6c 24 34          	mov    0x34(%esp),%ebp
 80494d9:	29 f5                	sub    %esi,%ebp
      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
 80494db:	83 fb 07             	cmp    $0x7,%ebx
 80494de:	b8 20 00 00 00       	mov    $0x20,%eax
 80494e3:	b9 2d 00 00 00       	mov    $0x2d,%ecx
 80494e8:	0f 44 c1             	cmove  %ecx,%eax
 80494eb:	83 ec 04             	sub    $0x4,%esp
 80494ee:	50                   	push   %eax
 80494ef:	0f b6 44 1d 00       	movzbl 0x0(%ebp,%ebx,1),%eax
 80494f4:	50                   	push   %eax
 80494f5:	68 2b ad 04 08       	push   $0x804ad2b
 80494fa:	e8 19 f8 ff ff       	call   8048d18 <printf>

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
 80494ff:	83 c3 01             	add    $0x1,%ebx
 8049502:	83 c4 10             	add    $0x10,%esp
 8049505:	39 fb                	cmp    %edi,%ebx
 8049507:	72 d2                	jb     80494db <hex_dump+0x99>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
 8049509:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
 804950e:	0f 84 ae 00 00 00    	je     80495c2 <hex_dump+0x180>
        {
          for (; i < per_line; i++)
 8049514:	83 fb 0f             	cmp    $0xf,%ebx
 8049517:	77 18                	ja     8049531 <hex_dump+0xef>
            printf ("   ");
 8049519:	83 ec 0c             	sub    $0xc,%esp
 804951c:	68 27 ad 04 08       	push   $0x804ad27
 8049521:	e8 f2 f7 ff ff       	call   8048d18 <printf>
      for (; i < end; i++) 
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
        {
          for (; i < per_line; i++)
 8049526:	83 c3 01             	add    $0x1,%ebx
 8049529:	83 c4 10             	add    $0x10,%esp
 804952c:	83 fb 10             	cmp    $0x10,%ebx
 804952f:	75 e8                	jne    8049519 <hex_dump+0xd7>
            printf ("   ");
          printf ("|");
 8049531:	83 ec 0c             	sub    $0xc,%esp
 8049534:	6a 7c                	push   $0x7c
 8049536:	e8 88 0d 00 00       	call   804a2c3 <putchar>
          for (i = 0; i < start; i++)
 804953b:	83 c4 10             	add    $0x10,%esp
 804953e:	85 f6                	test   %esi,%esi
 8049540:	0f 84 d3 00 00 00    	je     8049619 <hex_dump+0x1d7>
 8049546:	bb 00 00 00 00       	mov    $0x0,%ebx
            printf (" ");
 804954b:	83 ec 0c             	sub    $0xc,%esp
 804954e:	6a 20                	push   $0x20
 8049550:	e8 6e 0d 00 00       	call   804a2c3 <putchar>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
 8049555:	83 c3 01             	add    $0x1,%ebx
 8049558:	83 c4 10             	add    $0x10,%esp
 804955b:	39 de                	cmp    %ebx,%esi
 804955d:	75 ec                	jne    804954b <hex_dump+0x109>
            printf (" ");
          for (; i < end; i++)
 804955f:	39 fe                	cmp    %edi,%esi
 8049561:	73 36                	jae    8049599 <hex_dump+0x157>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
 8049563:	89 f3                	mov    %esi,%ebx
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
 8049565:	8b 6c 24 34          	mov    0x34(%esp),%ebp
 8049569:	29 f5                	sub    %esi,%ebp
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
 804956b:	be 2e 00 00 00       	mov    $0x2e,%esi
                    isprint (buf[i - start]) ? buf[i - start] : '.');
 8049570:	0f b6 44 1d 00       	movzbl 0x0(%ebp,%ebx,1),%eax
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
 8049575:	0f b6 d0             	movzbl %al,%edx
 8049578:	83 ea 20             	sub    $0x20,%edx
 804957b:	0f b6 c0             	movzbl %al,%eax
 804957e:	83 fa 5e             	cmp    $0x5e,%edx
 8049581:	0f 47 c6             	cmova  %esi,%eax
 8049584:	83 ec 0c             	sub    $0xc,%esp
 8049587:	50                   	push   %eax
 8049588:	e8 36 0d 00 00       	call   804a2c3 <putchar>
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
 804958d:	83 c3 01             	add    $0x1,%ebx
 8049590:	83 c4 10             	add    $0x10,%esp
 8049593:	39 fb                	cmp    %edi,%ebx
 8049595:	72 d9                	jb     8049570 <hex_dump+0x12e>
 8049597:	eb 02                	jmp    804959b <hex_dump+0x159>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
 8049599:	89 f3                	mov    %esi,%ebx
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
 804959b:	83 fb 0f             	cmp    $0xf,%ebx
 804959e:	77 15                	ja     80495b5 <hex_dump+0x173>
            printf (" ");
 80495a0:	83 ec 0c             	sub    $0xc,%esp
 80495a3:	6a 20                	push   $0x20
 80495a5:	e8 19 0d 00 00       	call   804a2c3 <putchar>
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
 80495aa:	83 c3 01             	add    $0x1,%ebx
 80495ad:	83 c4 10             	add    $0x10,%esp
 80495b0:	83 fb 0f             	cmp    $0xf,%ebx
 80495b3:	76 eb                	jbe    80495a0 <hex_dump+0x15e>
            printf (" ");
          printf ("|");
 80495b5:	83 ec 0c             	sub    $0xc,%esp
 80495b8:	6a 7c                	push   $0x7c
 80495ba:	e8 04 0d 00 00       	call   804a2c3 <putchar>
 80495bf:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
 80495c2:	83 ec 0c             	sub    $0xc,%esp
 80495c5:	6a 0a                	push   $0xa
 80495c7:	e8 f7 0c 00 00       	call   804a2c3 <putchar>

      ofs += n;
 80495cc:	8b 44 24 18          	mov    0x18(%esp),%eax
 80495d0:	01 44 24 40          	add    %eax,0x40(%esp)
      buf += n;
 80495d4:	01 44 24 44          	add    %eax,0x44(%esp)
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
 80495d8:	83 c4 10             	add    $0x10,%esp
 80495db:	29 44 24 38          	sub    %eax,0x38(%esp)
 80495df:	0f 85 78 fe ff ff    	jne    804945d <hex_dump+0x1b>
 80495e5:	eb 41                	jmp    8049628 <hex_dump+0x1e6>
      if (end - start > size)
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
 80495e7:	83 ec 04             	sub    $0x4,%esp
 80495ea:	8b 44 24 34          	mov    0x34(%esp),%eax
 80495ee:	83 e0 f0             	and    $0xfffffff0,%eax
 80495f1:	ba 00 00 00 00       	mov    $0x0,%edx
 80495f6:	52                   	push   %edx
 80495f7:	50                   	push   %eax
 80495f8:	68 1f ad 04 08       	push   $0x804ad1f
 80495fd:	e8 16 f7 ff ff       	call   8048d18 <printf>
      for (i = 0; i < start; i++)
 8049602:	83 c4 10             	add    $0x10,%esp
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
 8049605:	bf 10 00 00 00       	mov    $0x10,%edi
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
 804960a:	89 f3                	mov    %esi,%ebx
 804960c:	85 f6                	test   %esi,%esi
 804960e:	0f 84 c1 fe ff ff    	je     80494d5 <hex_dump+0x93>
 8049614:	e9 90 fe ff ff       	jmp    80494a9 <hex_dump+0x67>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
 8049619:	89 f3                	mov    %esi,%ebx
            printf (" ");
          for (; i < end; i++)
 804961b:	85 ff                	test   %edi,%edi
 804961d:	0f 85 42 ff ff ff    	jne    8049565 <hex_dump+0x123>
 8049623:	e9 78 ff ff ff       	jmp    80495a0 <hex_dump+0x15e>

      ofs += n;
      buf += n;
      size -= n;
    }
}
 8049628:	83 c4 1c             	add    $0x1c,%esp
 804962b:	5b                   	pop    %ebx
 804962c:	5e                   	pop    %esi
 804962d:	5f                   	pop    %edi
 804962e:	5d                   	pop    %ebp
 804962f:	c3                   	ret    

08049630 <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
 8049630:	57                   	push   %edi
 8049631:	56                   	push   %esi
 8049632:	83 ec 04             	sub    $0x4,%esp
 8049635:	8b 74 24 10          	mov    0x10(%esp),%esi
 8049639:	8b 7c 24 14          	mov    0x14(%esp),%edi
  if (size == 1)
 804963d:	89 f0                	mov    %esi,%eax
 804963f:	83 f0 01             	xor    $0x1,%eax
 8049642:	09 f8                	or     %edi,%eax
 8049644:	74 22                	je     8049668 <print_human_readable_size+0x38>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
 8049646:	83 ff 00             	cmp    $0x0,%edi
 8049649:	77 0d                	ja     8049658 <print_human_readable_size+0x28>
 804964b:	b9 1c c1 04 08       	mov    $0x804c11c,%ecx
 8049650:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
 8049656:	76 46                	jbe    804969e <print_human_readable_size+0x6e>
 8049658:	b9 1c c1 04 08       	mov    $0x804c11c,%ecx
 804965d:	83 3d 20 c1 04 08 00 	cmpl   $0x0,0x804c120
 8049664:	75 14                	jne    804967a <print_human_readable_size+0x4a>
 8049666:	eb 36                	jmp    804969e <print_human_readable_size+0x6e>
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
  if (size == 1)
    printf ("1 byte");
 8049668:	83 ec 0c             	sub    $0xc,%esp
 804966b:	68 34 ad 04 08       	push   $0x804ad34
 8049670:	e8 a3 f6 ff ff       	call   8048d18 <printf>
 8049675:	83 c4 10             	add    $0x10,%esp
 8049678:	eb 35                	jmp    80496af <print_human_readable_size+0x7f>
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
        size /= 1024;
 804967a:	89 f0                	mov    %esi,%eax
 804967c:	89 fa                	mov    %edi,%edx
 804967e:	0f ac f8 0a          	shrd   $0xa,%edi,%eax
 8049682:	c1 ea 0a             	shr    $0xa,%edx
 8049685:	89 c6                	mov    %eax,%esi
 8049687:	89 d7                	mov    %edx,%edi
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
 8049689:	83 c1 04             	add    $0x4,%ecx
 804968c:	83 fa 00             	cmp    $0x0,%edx
 804968f:	77 07                	ja     8049698 <print_human_readable_size+0x68>
 8049691:	3d ff 03 00 00       	cmp    $0x3ff,%eax
 8049696:	76 06                	jbe    804969e <print_human_readable_size+0x6e>
 8049698:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
 804969c:	75 dc                	jne    804967a <print_human_readable_size+0x4a>
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
 804969e:	ff 31                	pushl  (%ecx)
 80496a0:	57                   	push   %edi
 80496a1:	56                   	push   %esi
 80496a2:	68 3b ad 04 08       	push   $0x804ad3b
 80496a7:	e8 6c f6 ff ff       	call   8048d18 <printf>
 80496ac:	83 c4 10             	add    $0x10,%esp
    }
}
 80496af:	83 c4 04             	add    $0x4,%esp
 80496b2:	5e                   	pop    %esi
 80496b3:	5f                   	pop    %edi
 80496b4:	c3                   	ret    

080496b5 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
 80496b5:	56                   	push   %esi
 80496b6:	53                   	push   %ebx
 80496b7:	83 ec 04             	sub    $0x4,%esp
 80496ba:	8b 44 24 10          	mov    0x10(%esp),%eax
 80496be:	8b 74 24 14          	mov    0x14(%esp),%esi
 80496c2:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
 80496c6:	85 db                	test   %ebx,%ebx
 80496c8:	0f 94 c2             	sete   %dl
 80496cb:	85 c0                	test   %eax,%eax
 80496cd:	75 22                	jne    80496f1 <memcpy+0x3c>
 80496cf:	84 d2                	test   %dl,%dl
 80496d1:	75 1e                	jne    80496f1 <memcpy+0x3c>
 80496d3:	83 ec 0c             	sub    $0xc,%esp
 80496d6:	68 8b ad 04 08       	push   $0x804ad8b
 80496db:	68 a4 ad 04 08       	push   $0x804ada4
 80496e0:	68 e4 ab 04 08       	push   $0x804abe4
 80496e5:	6a 0c                	push   $0xc
 80496e7:	68 bb ad 04 08       	push   $0x804adbb
 80496ec:	e8 c0 09 00 00       	call   804a0b1 <debug_panic>
  ASSERT (src != NULL || size == 0);
 80496f1:	85 f6                	test   %esi,%esi
 80496f3:	75 04                	jne    80496f9 <memcpy+0x44>
 80496f5:	84 d2                	test   %dl,%dl
 80496f7:	74 0b                	je     8049704 <memcpy+0x4f>

  while (size-- > 0)
 80496f9:	ba 00 00 00 00       	mov    $0x0,%edx
 80496fe:	85 db                	test   %ebx,%ebx
 8049700:	75 20                	jne    8049722 <memcpy+0x6d>
 8049702:	eb 2c                	jmp    8049730 <memcpy+0x7b>
{
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);
 8049704:	83 ec 0c             	sub    $0xc,%esp
 8049707:	68 ce ad 04 08       	push   $0x804adce
 804970c:	68 a4 ad 04 08       	push   $0x804ada4
 8049711:	68 e4 ab 04 08       	push   $0x804abe4
 8049716:	6a 0d                	push   $0xd
 8049718:	68 bb ad 04 08       	push   $0x804adbb
 804971d:	e8 8f 09 00 00       	call   804a0b1 <debug_panic>

  while (size-- > 0)
    *dst++ = *src++;
 8049722:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
 8049726:	88 0c 10             	mov    %cl,(%eax,%edx,1)
 8049729:	83 c2 01             	add    $0x1,%edx
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
 804972c:	39 da                	cmp    %ebx,%edx
 804972e:	75 f2                	jne    8049722 <memcpy+0x6d>
    *dst++ = *src++;

  return dst_;
}
 8049730:	83 c4 04             	add    $0x4,%esp
 8049733:	5b                   	pop    %ebx
 8049734:	5e                   	pop    %esi
 8049735:	c3                   	ret    

08049736 <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
 8049736:	57                   	push   %edi
 8049737:	56                   	push   %esi
 8049738:	53                   	push   %ebx
 8049739:	8b 44 24 10          	mov    0x10(%esp),%eax
 804973d:	8b 5c 24 14          	mov    0x14(%esp),%ebx
 8049741:	8b 7c 24 18          	mov    0x18(%esp),%edi
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
 8049745:	85 ff                	test   %edi,%edi
 8049747:	0f 94 c2             	sete   %dl
 804974a:	85 c0                	test   %eax,%eax
 804974c:	75 22                	jne    8049770 <memmove+0x3a>
 804974e:	84 d2                	test   %dl,%dl
 8049750:	75 1e                	jne    8049770 <memmove+0x3a>
 8049752:	83 ec 0c             	sub    $0xc,%esp
 8049755:	68 8b ad 04 08       	push   $0x804ad8b
 804975a:	68 a4 ad 04 08       	push   $0x804ada4
 804975f:	68 dc ab 04 08       	push   $0x804abdc
 8049764:	6a 1d                	push   $0x1d
 8049766:	68 bb ad 04 08       	push   $0x804adbb
 804976b:	e8 41 09 00 00       	call   804a0b1 <debug_panic>
  ASSERT (src != NULL || size == 0);
 8049770:	85 db                	test   %ebx,%ebx
 8049772:	75 22                	jne    8049796 <memmove+0x60>
 8049774:	84 d2                	test   %dl,%dl
 8049776:	75 1e                	jne    8049796 <memmove+0x60>
 8049778:	83 ec 0c             	sub    $0xc,%esp
 804977b:	68 ce ad 04 08       	push   $0x804adce
 8049780:	68 a4 ad 04 08       	push   $0x804ada4
 8049785:	68 dc ab 04 08       	push   $0x804abdc
 804978a:	6a 1e                	push   $0x1e
 804978c:	68 bb ad 04 08       	push   $0x804adbb
 8049791:	e8 1b 09 00 00       	call   804a0b1 <debug_panic>

  if (dst < src) 
 8049796:	39 d8                	cmp    %ebx,%eax
 8049798:	73 1b                	jae    80497b5 <memmove+0x7f>
    {
      while (size-- > 0)
 804979a:	85 ff                	test   %edi,%edi
 804979c:	74 38                	je     80497d6 <memmove+0xa0>
 804979e:	ba 00 00 00 00       	mov    $0x0,%edx
        *dst++ = *src++;
 80497a3:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
 80497a7:	88 0c 10             	mov    %cl,(%eax,%edx,1)
 80497aa:	83 c2 01             	add    $0x1,%edx
  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
    {
      while (size-- > 0)
 80497ad:	39 fa                	cmp    %edi,%edx
 80497af:	75 f2                	jne    80497a3 <memmove+0x6d>
 80497b1:	01 f8                	add    %edi,%eax
 80497b3:	eb 21                	jmp    80497d6 <memmove+0xa0>
        *dst++ = *src++;
    }
  else 
    {
      dst += size;
 80497b5:	8d 34 38             	lea    (%eax,%edi,1),%esi
      src += size;
      while (size-- > 0)
 80497b8:	8d 57 ff             	lea    -0x1(%edi),%edx
 80497bb:	85 ff                	test   %edi,%edi
 80497bd:	74 15                	je     80497d4 <memmove+0x9e>
 80497bf:	89 f0                	mov    %esi,%eax
 80497c1:	29 f8                	sub    %edi,%eax
        *--dst = *--src;
 80497c3:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
 80497c7:	88 0c 10             	mov    %cl,(%eax,%edx,1)
    }
  else 
    {
      dst += size;
      src += size;
      while (size-- > 0)
 80497ca:	83 ea 01             	sub    $0x1,%edx
 80497cd:	83 fa ff             	cmp    $0xffffffff,%edx
 80497d0:	75 ed                	jne    80497bf <memmove+0x89>
 80497d2:	eb 02                	jmp    80497d6 <memmove+0xa0>
      while (size-- > 0)
        *dst++ = *src++;
    }
  else 
    {
      dst += size;
 80497d4:	89 f0                	mov    %esi,%eax
      while (size-- > 0)
        *--dst = *--src;
    }

  return dst;
}
 80497d6:	5b                   	pop    %ebx
 80497d7:	5e                   	pop    %esi
 80497d8:	5f                   	pop    %edi
 80497d9:	c3                   	ret    

080497da <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
 80497da:	57                   	push   %edi
 80497db:	56                   	push   %esi
 80497dc:	53                   	push   %ebx
 80497dd:	8b 5c 24 10          	mov    0x10(%esp),%ebx
 80497e1:	8b 74 24 14          	mov    0x14(%esp),%esi
 80497e5:	8b 44 24 18          	mov    0x18(%esp),%eax
  const unsigned char *a = a_;
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
 80497e9:	85 c0                	test   %eax,%eax
 80497eb:	0f 94 c2             	sete   %dl
 80497ee:	85 db                	test   %ebx,%ebx
 80497f0:	75 22                	jne    8049814 <memcmp+0x3a>
 80497f2:	84 d2                	test   %dl,%dl
 80497f4:	75 1e                	jne    8049814 <memcmp+0x3a>
 80497f6:	83 ec 0c             	sub    $0xc,%esp
 80497f9:	68 e7 ad 04 08       	push   $0x804ade7
 80497fe:	68 a4 ad 04 08       	push   $0x804ada4
 8049803:	68 d4 ab 04 08       	push   $0x804abd4
 8049808:	6a 3a                	push   $0x3a
 804980a:	68 bb ad 04 08       	push   $0x804adbb
 804980f:	e8 9d 08 00 00       	call   804a0b1 <debug_panic>
  ASSERT (b != NULL || size == 0);
 8049814:	85 f6                	test   %esi,%esi
 8049816:	75 04                	jne    804981c <memcmp+0x42>
 8049818:	84 d2                	test   %dl,%dl
 804981a:	74 18                	je     8049834 <memcmp+0x5a>

  for (; size-- > 0; a++, b++)
 804981c:	8d 78 ff             	lea    -0x1(%eax),%edi
 804981f:	85 c0                	test   %eax,%eax
 8049821:	74 56                	je     8049879 <memcmp+0x9f>
    if (*a != *b)
 8049823:	0f b6 13             	movzbl (%ebx),%edx
 8049826:	0f b6 0e             	movzbl (%esi),%ecx
 8049829:	38 ca                	cmp    %cl,%dl
 804982b:	75 35                	jne    8049862 <memcmp+0x88>
 804982d:	b8 00 00 00 00       	mov    $0x0,%eax
 8049832:	eb 3a                	jmp    804986e <memcmp+0x94>
{
  const unsigned char *a = a_;
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);
 8049834:	83 ec 0c             	sub    $0xc,%esp
 8049837:	68 fe ad 04 08       	push   $0x804adfe
 804983c:	68 a4 ad 04 08       	push   $0x804ada4
 8049841:	68 d4 ab 04 08       	push   $0x804abd4
 8049846:	6a 3b                	push   $0x3b
 8049848:	68 bb ad 04 08       	push   $0x804adbb
 804984d:	e8 5f 08 00 00       	call   804a0b1 <debug_panic>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
 8049852:	0f b6 54 03 01       	movzbl 0x1(%ebx,%eax,1),%edx
 8049857:	83 c0 01             	add    $0x1,%eax
 804985a:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
 804985e:	38 ca                	cmp    %cl,%dl
 8049860:	74 0c                	je     804986e <memcmp+0x94>
      return *a > *b ? +1 : -1;
 8049862:	38 d1                	cmp    %dl,%cl
 8049864:	19 c0                	sbb    %eax,%eax
 8049866:	83 e0 02             	and    $0x2,%eax
 8049869:	83 e8 01             	sub    $0x1,%eax
 804986c:	eb 10                	jmp    804987e <memcmp+0xa4>
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
 804986e:	39 f8                	cmp    %edi,%eax
 8049870:	75 e0                	jne    8049852 <memcmp+0x78>
    if (*a != *b)
      return *a > *b ? +1 : -1;
  return 0;
 8049872:	b8 00 00 00 00       	mov    $0x0,%eax
 8049877:	eb 05                	jmp    804987e <memcmp+0xa4>
 8049879:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804987e:	5b                   	pop    %ebx
 804987f:	5e                   	pop    %esi
 8049880:	5f                   	pop    %edi
 8049881:	c3                   	ret    

08049882 <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
 8049882:	83 ec 0c             	sub    $0xc,%esp
 8049885:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 8049889:	8b 54 24 14          	mov    0x14(%esp),%edx
  const unsigned char *a = (const unsigned char *) a_;
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
 804988d:	85 c9                	test   %ecx,%ecx
 804988f:	75 1e                	jne    80498af <strcmp+0x2d>
 8049891:	83 ec 0c             	sub    $0xc,%esp
 8049894:	68 15 ae 04 08       	push   $0x804ae15
 8049899:	68 a4 ad 04 08       	push   $0x804ada4
 804989e:	68 cc ab 04 08       	push   $0x804abcc
 80498a3:	6a 4e                	push   $0x4e
 80498a5:	68 bb ad 04 08       	push   $0x804adbb
 80498aa:	e8 02 08 00 00       	call   804a0b1 <debug_panic>
  ASSERT (b != NULL);
 80498af:	85 d2                	test   %edx,%edx
 80498b1:	74 0d                	je     80498c0 <strcmp+0x3e>

  while (*a != '\0' && *a == *b) 
 80498b3:	0f b6 01             	movzbl (%ecx),%eax
 80498b6:	84 c0                	test   %al,%al
 80498b8:	74 35                	je     80498ef <strcmp+0x6d>
 80498ba:	3a 02                	cmp    (%edx),%al
 80498bc:	74 20                	je     80498de <strcmp+0x5c>
 80498be:	eb 2f                	jmp    80498ef <strcmp+0x6d>
{
  const unsigned char *a = (const unsigned char *) a_;
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);
 80498c0:	83 ec 0c             	sub    $0xc,%esp
 80498c3:	68 1f ae 04 08       	push   $0x804ae1f
 80498c8:	68 a4 ad 04 08       	push   $0x804ada4
 80498cd:	68 cc ab 04 08       	push   $0x804abcc
 80498d2:	6a 4f                	push   $0x4f
 80498d4:	68 bb ad 04 08       	push   $0x804adbb
 80498d9:	e8 d3 07 00 00       	call   804a0b1 <debug_panic>

  while (*a != '\0' && *a == *b) 
    {
      a++;
 80498de:	83 c1 01             	add    $0x1,%ecx
      b++;
 80498e1:	83 c2 01             	add    $0x1,%edx
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
 80498e4:	0f b6 01             	movzbl (%ecx),%eax
 80498e7:	84 c0                	test   %al,%al
 80498e9:	74 04                	je     80498ef <strcmp+0x6d>
 80498eb:	3a 02                	cmp    (%edx),%al
 80498ed:	74 ef                	je     80498de <strcmp+0x5c>
    {
      a++;
      b++;
    }

  return *a < *b ? -1 : *a > *b;
 80498ef:	0f b6 12             	movzbl (%edx),%edx
 80498f2:	38 c2                	cmp    %al,%dl
 80498f4:	77 08                	ja     80498fe <strcmp+0x7c>
 80498f6:	0f 92 c0             	setb   %al
 80498f9:	0f b6 c0             	movzbl %al,%eax
 80498fc:	eb 05                	jmp    8049903 <strcmp+0x81>
 80498fe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
 8049903:	83 c4 0c             	add    $0xc,%esp
 8049906:	c3                   	ret    

08049907 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
 8049907:	53                   	push   %ebx
 8049908:	83 ec 08             	sub    $0x8,%esp
 804990b:	8b 44 24 10          	mov    0x10(%esp),%eax
 804990f:	8b 54 24 14          	mov    0x14(%esp),%edx
 8049913:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  const unsigned char *block = block_;
  unsigned char ch = ch_;
 8049917:	89 d3                	mov    %edx,%ebx

  ASSERT (block != NULL || size == 0);
 8049919:	85 c0                	test   %eax,%eax
 804991b:	75 04                	jne    8049921 <memchr+0x1a>
 804991d:	85 c9                	test   %ecx,%ecx
 804991f:	75 0f                	jne    8049930 <memchr+0x29>

  for (; size-- > 0; block++)
 8049921:	85 c9                	test   %ecx,%ecx
 8049923:	74 3e                	je     8049963 <memchr+0x5c>
    if (*block == ch)
 8049925:	3a 10                	cmp    (%eax),%dl
 8049927:	74 3f                	je     8049968 <memchr+0x61>
 8049929:	8d 50 01             	lea    0x1(%eax),%edx
 804992c:	01 c1                	add    %eax,%ecx
 804992e:	eb 26                	jmp    8049956 <memchr+0x4f>
memchr (const void *block_, int ch_, size_t size) 
{
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);
 8049930:	83 ec 0c             	sub    $0xc,%esp
 8049933:	68 29 ae 04 08       	push   $0x804ae29
 8049938:	68 a4 ad 04 08       	push   $0x804ada4
 804993d:	68 c4 ab 04 08       	push   $0x804abc4
 8049942:	6a 63                	push   $0x63
 8049944:	68 bb ad 04 08       	push   $0x804adbb
 8049949:	e8 63 07 00 00       	call   804a0b1 <debug_panic>
 804994e:	83 c2 01             	add    $0x1,%edx

  for (; size-- > 0; block++)
    if (*block == ch)
 8049951:	3a 5a ff             	cmp    -0x1(%edx),%bl
 8049954:	74 12                	je     8049968 <memchr+0x61>
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
 8049956:	89 d0                	mov    %edx,%eax
 8049958:	39 ca                	cmp    %ecx,%edx
 804995a:	75 f2                	jne    804994e <memchr+0x47>
    if (*block == ch)
      return (void *) block;

  return NULL;
 804995c:	b8 00 00 00 00       	mov    $0x0,%eax
 8049961:	eb 05                	jmp    8049968 <memchr+0x61>
 8049963:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049968:	83 c4 08             	add    $0x8,%esp
 804996b:	5b                   	pop    %ebx
 804996c:	c3                   	ret    

0804996d <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
 804996d:	53                   	push   %ebx
 804996e:	83 ec 08             	sub    $0x8,%esp
 8049971:	8b 44 24 10          	mov    0x10(%esp),%eax
 8049975:	8b 54 24 14          	mov    0x14(%esp),%edx
  char c = c_;

  ASSERT (string != NULL);
 8049979:	85 c0                	test   %eax,%eax
 804997b:	74 0b                	je     8049988 <strchr+0x1b>
 804997d:	89 d1                	mov    %edx,%ecx

  for (;;) 
    if (*string == c)
 804997f:	0f b6 18             	movzbl (%eax),%ebx
 8049982:	38 da                	cmp    %bl,%dl
 8049984:	75 20                	jne    80499a6 <strchr+0x39>
 8049986:	eb 40                	jmp    80499c8 <strchr+0x5b>
char *
strchr (const char *string, int c_) 
{
  char c = c_;

  ASSERT (string != NULL);
 8049988:	83 ec 0c             	sub    $0xc,%esp
 804998b:	68 44 ae 04 08       	push   $0x804ae44
 8049990:	68 a4 ad 04 08       	push   $0x804ada4
 8049995:	68 bc ab 04 08       	push   $0x804abbc
 804999a:	6a 75                	push   $0x75
 804999c:	68 bb ad 04 08       	push   $0x804adbb
 80499a1:	e8 0b 07 00 00       	call   804a0b1 <debug_panic>

  for (;;) 
    if (*string == c)
      return (char *) string;
    else if (*string == '\0')
 80499a6:	84 db                	test   %bl,%bl
 80499a8:	75 06                	jne    80499b0 <strchr+0x43>
 80499aa:	eb 10                	jmp    80499bc <strchr+0x4f>
 80499ac:	84 d2                	test   %dl,%dl
 80499ae:	74 13                	je     80499c3 <strchr+0x56>
      return NULL;
    else
      string++;
 80499b0:	83 c0 01             	add    $0x1,%eax
  char c = c_;

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
 80499b3:	0f b6 10             	movzbl (%eax),%edx
 80499b6:	38 d1                	cmp    %dl,%cl
 80499b8:	75 f2                	jne    80499ac <strchr+0x3f>
 80499ba:	eb 0c                	jmp    80499c8 <strchr+0x5b>
      return (char *) string;
    else if (*string == '\0')
      return NULL;
 80499bc:	b8 00 00 00 00       	mov    $0x0,%eax
 80499c1:	eb 05                	jmp    80499c8 <strchr+0x5b>
 80499c3:	b8 00 00 00 00       	mov    $0x0,%eax
    else
      string++;
}
 80499c8:	83 c4 08             	add    $0x8,%esp
 80499cb:	5b                   	pop    %ebx
 80499cc:	c3                   	ret    

080499cd <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
 80499cd:	57                   	push   %edi
 80499ce:	56                   	push   %esi
 80499cf:	53                   	push   %ebx
 80499d0:	8b 74 24 10          	mov    0x10(%esp),%esi
 80499d4:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
 80499d8:	0f b6 06             	movzbl (%esi),%eax
 80499db:	84 c0                	test   %al,%al
 80499dd:	74 26                	je     8049a05 <strcspn+0x38>
 80499df:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (stop, string[length]) != NULL)
 80499e4:	83 ec 08             	sub    $0x8,%esp
 80499e7:	0f be c0             	movsbl %al,%eax
 80499ea:	50                   	push   %eax
 80499eb:	57                   	push   %edi
 80499ec:	e8 7c ff ff ff       	call   804996d <strchr>
 80499f1:	83 c4 10             	add    $0x10,%esp
 80499f4:	85 c0                	test   %eax,%eax
 80499f6:	75 12                	jne    8049a0a <strcspn+0x3d>
size_t
strcspn (const char *string, const char *stop) 
{
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
 80499f8:	83 c3 01             	add    $0x1,%ebx
 80499fb:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
 80499ff:	84 c0                	test   %al,%al
 8049a01:	75 e1                	jne    80499e4 <strcspn+0x17>
 8049a03:	eb 05                	jmp    8049a0a <strcspn+0x3d>
 8049a05:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (stop, string[length]) != NULL)
      break;
  return length;
}
 8049a0a:	89 d8                	mov    %ebx,%eax
 8049a0c:	5b                   	pop    %ebx
 8049a0d:	5e                   	pop    %esi
 8049a0e:	5f                   	pop    %edi
 8049a0f:	c3                   	ret    

08049a10 <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
 8049a10:	56                   	push   %esi
 8049a11:	53                   	push   %ebx
 8049a12:	83 ec 04             	sub    $0x4,%esp
 8049a15:	8b 5c 24 10          	mov    0x10(%esp),%ebx
 8049a19:	8b 74 24 14          	mov    0x14(%esp),%esi
  for (; *string != '\0'; string++)
 8049a1d:	0f b6 13             	movzbl (%ebx),%edx
 8049a20:	84 d2                	test   %dl,%dl
 8049a22:	74 20                	je     8049a44 <strpbrk+0x34>
    if (strchr (stop, *string) != NULL)
 8049a24:	83 ec 08             	sub    $0x8,%esp
 8049a27:	0f be d2             	movsbl %dl,%edx
 8049a2a:	52                   	push   %edx
 8049a2b:	56                   	push   %esi
 8049a2c:	e8 3c ff ff ff       	call   804996d <strchr>
 8049a31:	83 c4 10             	add    $0x10,%esp
 8049a34:	85 c0                	test   %eax,%eax
 8049a36:	75 13                	jne    8049a4b <strpbrk+0x3b>
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
  for (; *string != '\0'; string++)
 8049a38:	83 c3 01             	add    $0x1,%ebx
 8049a3b:	0f b6 13             	movzbl (%ebx),%edx
 8049a3e:	84 d2                	test   %dl,%dl
 8049a40:	75 e2                	jne    8049a24 <strpbrk+0x14>
 8049a42:	eb 09                	jmp    8049a4d <strpbrk+0x3d>
    if (strchr (stop, *string) != NULL)
      return (char *) string;
  return NULL;
 8049a44:	b8 00 00 00 00       	mov    $0x0,%eax
 8049a49:	eb 02                	jmp    8049a4d <strpbrk+0x3d>
 8049a4b:	89 d8                	mov    %ebx,%eax
}
 8049a4d:	83 c4 04             	add    $0x4,%esp
 8049a50:	5b                   	pop    %ebx
 8049a51:	5e                   	pop    %esi
 8049a52:	c3                   	ret    

08049a53 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
 8049a53:	53                   	push   %ebx
 8049a54:	8b 54 24 08          	mov    0x8(%esp),%edx
  char c = c_;
 8049a58:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
  const char *p = NULL;

  for (; *string != '\0'; string++)
 8049a5d:	0f b6 0a             	movzbl (%edx),%ecx
 8049a60:	84 c9                	test   %cl,%cl
 8049a62:	74 16                	je     8049a7a <strrchr+0x27>
 8049a64:	b8 00 00 00 00       	mov    $0x0,%eax
    if (*string == c)
 8049a69:	38 cb                	cmp    %cl,%bl
 8049a6b:	0f 44 c2             	cmove  %edx,%eax
strrchr (const char *string, int c_) 
{
  char c = c_;
  const char *p = NULL;

  for (; *string != '\0'; string++)
 8049a6e:	83 c2 01             	add    $0x1,%edx
 8049a71:	0f b6 0a             	movzbl (%edx),%ecx
 8049a74:	84 c9                	test   %cl,%cl
 8049a76:	75 f1                	jne    8049a69 <strrchr+0x16>
 8049a78:	eb 05                	jmp    8049a7f <strrchr+0x2c>
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
  char c = c_;
  const char *p = NULL;
 8049a7a:	b8 00 00 00 00       	mov    $0x0,%eax

  for (; *string != '\0'; string++)
    if (*string == c)
      p = string;
  return (char *) p;
}
 8049a7f:	5b                   	pop    %ebx
 8049a80:	c3                   	ret    

08049a81 <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
 8049a81:	57                   	push   %edi
 8049a82:	56                   	push   %esi
 8049a83:	53                   	push   %ebx
 8049a84:	8b 74 24 10          	mov    0x10(%esp),%esi
 8049a88:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
 8049a8c:	0f b6 06             	movzbl (%esi),%eax
 8049a8f:	84 c0                	test   %al,%al
 8049a91:	74 26                	je     8049ab9 <strspn+0x38>
 8049a93:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (skip, string[length]) == NULL)
 8049a98:	83 ec 08             	sub    $0x8,%esp
 8049a9b:	0f be c0             	movsbl %al,%eax
 8049a9e:	50                   	push   %eax
 8049a9f:	57                   	push   %edi
 8049aa0:	e8 c8 fe ff ff       	call   804996d <strchr>
 8049aa5:	83 c4 10             	add    $0x10,%esp
 8049aa8:	85 c0                	test   %eax,%eax
 8049aaa:	74 12                	je     8049abe <strspn+0x3d>
size_t
strspn (const char *string, const char *skip) 
{
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
 8049aac:	83 c3 01             	add    $0x1,%ebx
 8049aaf:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
 8049ab3:	84 c0                	test   %al,%al
 8049ab5:	75 e1                	jne    8049a98 <strspn+0x17>
 8049ab7:	eb 05                	jmp    8049abe <strspn+0x3d>
 8049ab9:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (skip, string[length]) == NULL)
      break;
  return length;
}
 8049abe:	89 d8                	mov    %ebx,%eax
 8049ac0:	5b                   	pop    %ebx
 8049ac1:	5e                   	pop    %esi
 8049ac2:	5f                   	pop    %edi
 8049ac3:	c3                   	ret    

08049ac4 <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
 8049ac4:	55                   	push   %ebp
 8049ac5:	57                   	push   %edi
 8049ac6:	56                   	push   %esi
 8049ac7:	53                   	push   %ebx
 8049ac8:	83 ec 0c             	sub    $0xc,%esp
 8049acb:	8b 5c 24 20          	mov    0x20(%esp),%ebx
 8049acf:	8b 74 24 24          	mov    0x24(%esp),%esi
  char *token;
  
  ASSERT (delimiters != NULL);
 8049ad3:	85 f6                	test   %esi,%esi
 8049ad5:	75 21                	jne    8049af8 <strtok_r+0x34>
 8049ad7:	83 ec 0c             	sub    $0xc,%esp
 8049ada:	68 53 ae 04 08       	push   $0x804ae53
 8049adf:	68 a4 ad 04 08       	push   $0x804ada4
 8049ae4:	68 b0 ab 04 08       	push   $0x804abb0
 8049ae9:	68 ef 00 00 00       	push   $0xef
 8049aee:	68 bb ad 04 08       	push   $0x804adbb
 8049af3:	e8 b9 05 00 00       	call   804a0b1 <debug_panic>
  ASSERT (save_ptr != NULL);
 8049af8:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
 8049afd:	75 21                	jne    8049b20 <strtok_r+0x5c>
 8049aff:	83 ec 0c             	sub    $0xc,%esp
 8049b02:	68 66 ae 04 08       	push   $0x804ae66
 8049b07:	68 a4 ad 04 08       	push   $0x804ada4
 8049b0c:	68 b0 ab 04 08       	push   $0x804abb0
 8049b11:	68 f0 00 00 00       	push   $0xf0
 8049b16:	68 bb ad 04 08       	push   $0x804adbb
 8049b1b:	e8 91 05 00 00       	call   804a0b1 <debug_panic>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
 8049b20:	85 db                	test   %ebx,%ebx
 8049b22:	75 41                	jne    8049b65 <strtok_r+0xa1>
    s = *save_ptr;
 8049b24:	8b 44 24 28          	mov    0x28(%esp),%eax
 8049b28:	8b 18                	mov    (%eax),%ebx
  ASSERT (s != NULL);
 8049b2a:	85 db                	test   %ebx,%ebx
 8049b2c:	75 37                	jne    8049b65 <strtok_r+0xa1>
 8049b2e:	83 ec 0c             	sub    $0xc,%esp
 8049b31:	68 5c ae 04 08       	push   $0x804ae5c
 8049b36:	68 a4 ad 04 08       	push   $0x804ada4
 8049b3b:	68 b0 ab 04 08       	push   $0x804abb0
 8049b40:	68 f6 00 00 00       	push   $0xf6
 8049b45:	68 bb ad 04 08       	push   $0x804adbb
 8049b4a:	e8 62 05 00 00       	call   804a0b1 <debug_panic>
  while (strchr (delimiters, *s) != NULL) 
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
 8049b4f:	89 f8                	mov    %edi,%eax
 8049b51:	84 c0                	test   %al,%al
 8049b53:	75 0d                	jne    8049b62 <strtok_r+0x9e>
        {
          *save_ptr = s;
 8049b55:	8b 44 24 28          	mov    0x28(%esp),%eax
 8049b59:	89 18                	mov    %ebx,(%eax)
          return NULL;
 8049b5b:	b8 00 00 00 00       	mov    $0x0,%eax
 8049b60:	eb 58                	jmp    8049bba <strtok_r+0xf6>
        }

      s++;
 8049b62:	83 c3 01             	add    $0x1,%ebx
  if (s == NULL)
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
 8049b65:	0f b6 3b             	movzbl (%ebx),%edi
 8049b68:	83 ec 08             	sub    $0x8,%esp
 8049b6b:	89 f8                	mov    %edi,%eax
 8049b6d:	0f be c0             	movsbl %al,%eax
 8049b70:	50                   	push   %eax
 8049b71:	56                   	push   %esi
 8049b72:	e8 f6 fd ff ff       	call   804996d <strchr>
 8049b77:	83 c4 10             	add    $0x10,%esp
 8049b7a:	85 c0                	test   %eax,%eax
 8049b7c:	75 d1                	jne    8049b4f <strtok_r+0x8b>
 8049b7e:	89 df                	mov    %ebx,%edi
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
  while (strchr (delimiters, *s) == NULL)
    s++;
 8049b80:	83 c7 01             	add    $0x1,%edi
      s++;
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
  while (strchr (delimiters, *s) == NULL)
 8049b83:	0f b6 2f             	movzbl (%edi),%ebp
 8049b86:	83 ec 08             	sub    $0x8,%esp
 8049b89:	89 e8                	mov    %ebp,%eax
 8049b8b:	0f be c0             	movsbl %al,%eax
 8049b8e:	50                   	push   %eax
 8049b8f:	56                   	push   %esi
 8049b90:	e8 d8 fd ff ff       	call   804996d <strchr>
 8049b95:	83 c4 10             	add    $0x10,%esp
 8049b98:	85 c0                	test   %eax,%eax
 8049b9a:	74 e4                	je     8049b80 <strtok_r+0xbc>
    s++;
  if (*s != '\0') 
 8049b9c:	89 e8                	mov    %ebp,%eax
 8049b9e:	84 c0                	test   %al,%al
 8049ba0:	74 10                	je     8049bb2 <strtok_r+0xee>
    {
      *s = '\0';
 8049ba2:	c6 07 00             	movb   $0x0,(%edi)
      *save_ptr = s + 1;
 8049ba5:	83 c7 01             	add    $0x1,%edi
 8049ba8:	8b 44 24 28          	mov    0x28(%esp),%eax
 8049bac:	89 38                	mov    %edi,(%eax)
 8049bae:	89 d8                	mov    %ebx,%eax
 8049bb0:	eb 08                	jmp    8049bba <strtok_r+0xf6>
    }
  else 
    *save_ptr = s;
 8049bb2:	8b 44 24 28          	mov    0x28(%esp),%eax
 8049bb6:	89 38                	mov    %edi,(%eax)
 8049bb8:	89 d8                	mov    %ebx,%eax
  return token;
}
 8049bba:	83 c4 0c             	add    $0xc,%esp
 8049bbd:	5b                   	pop    %ebx
 8049bbe:	5e                   	pop    %esi
 8049bbf:	5f                   	pop    %edi
 8049bc0:	5d                   	pop    %ebp
 8049bc1:	c3                   	ret    

08049bc2 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
 8049bc2:	56                   	push   %esi
 8049bc3:	53                   	push   %ebx
 8049bc4:	83 ec 04             	sub    $0x4,%esp
 8049bc7:	8b 44 24 10          	mov    0x10(%esp),%eax
 8049bcb:	8b 5c 24 14          	mov    0x14(%esp),%ebx
 8049bcf:	8b 74 24 18          	mov    0x18(%esp),%esi
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
 8049bd3:	85 c0                	test   %eax,%eax
 8049bd5:	75 04                	jne    8049bdb <memset+0x19>
 8049bd7:	85 f6                	test   %esi,%esi
 8049bd9:	75 0b                	jne    8049be6 <memset+0x24>
 8049bdb:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
  
  while (size-- > 0)
 8049bde:	89 c2                	mov    %eax,%edx
 8049be0:	85 f6                	test   %esi,%esi
 8049be2:	75 23                	jne    8049c07 <memset+0x45>
 8049be4:	eb 2b                	jmp    8049c11 <memset+0x4f>
void *
memset (void *dst_, int value, size_t size) 
{
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
 8049be6:	83 ec 0c             	sub    $0xc,%esp
 8049be9:	68 8b ad 04 08       	push   $0x804ad8b
 8049bee:	68 a4 ad 04 08       	push   $0x804ada4
 8049bf3:	68 a8 ab 04 08       	push   $0x804aba8
 8049bf8:	68 1b 01 00 00       	push   $0x11b
 8049bfd:	68 bb ad 04 08       	push   $0x804adbb
 8049c02:	e8 aa 04 00 00       	call   804a0b1 <debug_panic>
  
  while (size-- > 0)
    *dst++ = value;
 8049c07:	83 c2 01             	add    $0x1,%edx
 8049c0a:	88 5a ff             	mov    %bl,-0x1(%edx)
{
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
 8049c0d:	39 d1                	cmp    %edx,%ecx
 8049c0f:	75 f6                	jne    8049c07 <memset+0x45>
    *dst++ = value;

  return dst_;
}
 8049c11:	83 c4 04             	add    $0x4,%esp
 8049c14:	5b                   	pop    %ebx
 8049c15:	5e                   	pop    %esi
 8049c16:	c3                   	ret    

08049c17 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
 8049c17:	83 ec 0c             	sub    $0xc,%esp
 8049c1a:	8b 54 24 10          	mov    0x10(%esp),%edx
  const char *p;

  ASSERT (string != NULL);
 8049c1e:	85 d2                	test   %edx,%edx
 8049c20:	74 09                	je     8049c2b <strlen+0x14>

  for (p = string; *p != '\0'; p++)
 8049c22:	89 d0                	mov    %edx,%eax
 8049c24:	80 3a 00             	cmpb   $0x0,(%edx)
 8049c27:	74 2d                	je     8049c56 <strlen+0x3f>
 8049c29:	eb 21                	jmp    8049c4c <strlen+0x35>
size_t
strlen (const char *string) 
{
  const char *p;

  ASSERT (string != NULL);
 8049c2b:	83 ec 0c             	sub    $0xc,%esp
 8049c2e:	68 44 ae 04 08       	push   $0x804ae44
 8049c33:	68 a4 ad 04 08       	push   $0x804ada4
 8049c38:	68 a0 ab 04 08       	push   $0x804aba0
 8049c3d:	68 29 01 00 00       	push   $0x129
 8049c42:	68 bb ad 04 08       	push   $0x804adbb
 8049c47:	e8 65 04 00 00       	call   804a0b1 <debug_panic>

  for (p = string; *p != '\0'; p++)
 8049c4c:	89 d0                	mov    %edx,%eax
 8049c4e:	83 c0 01             	add    $0x1,%eax
 8049c51:	80 38 00             	cmpb   $0x0,(%eax)
 8049c54:	75 f8                	jne    8049c4e <strlen+0x37>
    continue;
  return p - string;
 8049c56:	29 d0                	sub    %edx,%eax
}
 8049c58:	83 c4 0c             	add    $0xc,%esp
 8049c5b:	c3                   	ret    

08049c5c <strstr>:
/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
{
 8049c5c:	55                   	push   %ebp
 8049c5d:	57                   	push   %edi
 8049c5e:	56                   	push   %esi
 8049c5f:	53                   	push   %ebx
 8049c60:	83 ec 1c             	sub    $0x1c,%esp
 8049c63:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  size_t haystack_len = strlen (haystack);
 8049c67:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
 8049c6c:	b8 00 00 00 00       	mov    $0x0,%eax
 8049c71:	89 d9                	mov    %ebx,%ecx
 8049c73:	8b 7c 24 30          	mov    0x30(%esp),%edi
 8049c77:	f2 ae                	repnz scas %es:(%edi),%al
 8049c79:	f7 d1                	not    %ecx
 8049c7b:	8d 51 ff             	lea    -0x1(%ecx),%edx
  size_t needle_len = strlen (needle);
 8049c7e:	89 d9                	mov    %ebx,%ecx
 8049c80:	89 ef                	mov    %ebp,%edi
 8049c82:	f2 ae                	repnz scas %es:(%edi),%al
 8049c84:	89 c8                	mov    %ecx,%eax
 8049c86:	f7 d0                	not    %eax
 8049c88:	8d 78 ff             	lea    -0x1(%eax),%edi

  if (haystack_len >= needle_len) 
 8049c8b:	39 fa                	cmp    %edi,%edx
 8049c8d:	72 33                	jb     8049cc2 <strstr+0x66>
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
 8049c8f:	29 fa                	sub    %edi,%edx
 8049c91:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8049c95:	bb 00 00 00 00       	mov    $0x0,%ebx
 8049c9a:	89 de                	mov    %ebx,%esi
 8049c9c:	03 74 24 30          	add    0x30(%esp),%esi
        if (!memcmp (haystack + i, needle, needle_len))
 8049ca0:	83 ec 04             	sub    $0x4,%esp
 8049ca3:	57                   	push   %edi
 8049ca4:	55                   	push   %ebp
 8049ca5:	56                   	push   %esi
 8049ca6:	e8 2f fb ff ff       	call   80497da <memcmp>
 8049cab:	83 c4 10             	add    $0x10,%esp
 8049cae:	85 c0                	test   %eax,%eax
 8049cb0:	74 17                	je     8049cc9 <strstr+0x6d>

  if (haystack_len >= needle_len) 
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
 8049cb2:	83 c3 01             	add    $0x1,%ebx
 8049cb5:	3b 5c 24 0c          	cmp    0xc(%esp),%ebx
 8049cb9:	76 df                	jbe    8049c9a <strstr+0x3e>
        if (!memcmp (haystack + i, needle, needle_len))
          return (char *) haystack + i;
    }

  return NULL;
 8049cbb:	b8 00 00 00 00       	mov    $0x0,%eax
 8049cc0:	eb 09                	jmp    8049ccb <strstr+0x6f>
 8049cc2:	b8 00 00 00 00       	mov    $0x0,%eax
 8049cc7:	eb 02                	jmp    8049ccb <strstr+0x6f>
  if (haystack_len >= needle_len) 
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
        if (!memcmp (haystack + i, needle, needle_len))
 8049cc9:	89 f0                	mov    %esi,%eax
          return (char *) haystack + i;
    }

  return NULL;
}
 8049ccb:	83 c4 1c             	add    $0x1c,%esp
 8049cce:	5b                   	pop    %ebx
 8049ccf:	5e                   	pop    %esi
 8049cd0:	5f                   	pop    %edi
 8049cd1:	5d                   	pop    %ebp
 8049cd2:	c3                   	ret    

08049cd3 <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
 8049cd3:	8b 54 24 04          	mov    0x4(%esp),%edx
 8049cd7:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
 8049cdb:	80 3a 00             	cmpb   $0x0,(%edx)
 8049cde:	74 18                	je     8049cf8 <strnlen+0x25>
 8049ce0:	85 c9                	test   %ecx,%ecx
 8049ce2:	74 14                	je     8049cf8 <strnlen+0x25>
 8049ce4:	b8 00 00 00 00       	mov    $0x0,%eax
 8049ce9:	83 c0 01             	add    $0x1,%eax
 8049cec:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
 8049cf0:	74 0b                	je     8049cfd <strnlen+0x2a>
 8049cf2:	39 c1                	cmp    %eax,%ecx
 8049cf4:	77 f3                	ja     8049ce9 <strnlen+0x16>
 8049cf6:	f3 c3                	repz ret 
 8049cf8:	b8 00 00 00 00       	mov    $0x0,%eax
    continue;
  return length;
}
 8049cfd:	f3 c3                	repz ret 

08049cff <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
 8049cff:	55                   	push   %ebp
 8049d00:	57                   	push   %edi
 8049d01:	56                   	push   %esi
 8049d02:	53                   	push   %ebx
 8049d03:	83 ec 0c             	sub    $0xc,%esp
 8049d06:	8b 74 24 20          	mov    0x20(%esp),%esi
 8049d0a:	8b 6c 24 24          	mov    0x24(%esp),%ebp
 8049d0e:	8b 54 24 28          	mov    0x28(%esp),%edx
  size_t src_len;

  ASSERT (dst != NULL);
 8049d12:	85 f6                	test   %esi,%esi
 8049d14:	75 21                	jne    8049d37 <strlcpy+0x38>
 8049d16:	83 ec 0c             	sub    $0xc,%esp
 8049d19:	68 77 ae 04 08       	push   $0x804ae77
 8049d1e:	68 a4 ad 04 08       	push   $0x804ada4
 8049d23:	68 98 ab 04 08       	push   $0x804ab98
 8049d28:	68 4a 01 00 00       	push   $0x14a
 8049d2d:	68 bb ad 04 08       	push   $0x804adbb
 8049d32:	e8 7a 03 00 00       	call   804a0b1 <debug_panic>
  ASSERT (src != NULL);
 8049d37:	85 ed                	test   %ebp,%ebp
 8049d39:	75 21                	jne    8049d5c <strlcpy+0x5d>
 8049d3b:	83 ec 0c             	sub    $0xc,%esp
 8049d3e:	68 83 ae 04 08       	push   $0x804ae83
 8049d43:	68 a4 ad 04 08       	push   $0x804ada4
 8049d48:	68 98 ab 04 08       	push   $0x804ab98
 8049d4d:	68 4b 01 00 00       	push   $0x14b
 8049d52:	68 bb ad 04 08       	push   $0x804adbb
 8049d57:	e8 55 03 00 00       	call   804a0b1 <debug_panic>

  src_len = strlen (src);
 8049d5c:	b8 00 00 00 00       	mov    $0x0,%eax
 8049d61:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 8049d66:	89 ef                	mov    %ebp,%edi
 8049d68:	f2 ae                	repnz scas %es:(%edi),%al
 8049d6a:	f7 d1                	not    %ecx
 8049d6c:	8d 59 ff             	lea    -0x1(%ecx),%ebx
  if (size > 0) 
 8049d6f:	85 d2                	test   %edx,%edx
 8049d71:	74 1c                	je     8049d8f <strlcpy+0x90>
    {
      size_t dst_len = size - 1;
 8049d73:	83 ea 01             	sub    $0x1,%edx
 8049d76:	39 d3                	cmp    %edx,%ebx
 8049d78:	89 d7                	mov    %edx,%edi
 8049d7a:	0f 46 fb             	cmovbe %ebx,%edi
      if (src_len < dst_len)
        dst_len = src_len;
      memcpy (dst, src, dst_len);
 8049d7d:	83 ec 04             	sub    $0x4,%esp
 8049d80:	57                   	push   %edi
 8049d81:	55                   	push   %ebp
 8049d82:	56                   	push   %esi
 8049d83:	e8 2d f9 ff ff       	call   80496b5 <memcpy>
      dst[dst_len] = '\0';
 8049d88:	c6 04 3e 00          	movb   $0x0,(%esi,%edi,1)
 8049d8c:	83 c4 10             	add    $0x10,%esp
    }
  return src_len;
}
 8049d8f:	89 d8                	mov    %ebx,%eax
 8049d91:	83 c4 0c             	add    $0xc,%esp
 8049d94:	5b                   	pop    %ebx
 8049d95:	5e                   	pop    %esi
 8049d96:	5f                   	pop    %edi
 8049d97:	5d                   	pop    %ebp
 8049d98:	c3                   	ret    

08049d99 <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
 8049d99:	55                   	push   %ebp
 8049d9a:	57                   	push   %edi
 8049d9b:	56                   	push   %esi
 8049d9c:	53                   	push   %ebx
 8049d9d:	83 ec 0c             	sub    $0xc,%esp
 8049da0:	8b 54 24 24          	mov    0x24(%esp),%edx
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
 8049da4:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
 8049da9:	75 21                	jne    8049dcc <strlcat+0x33>
 8049dab:	83 ec 0c             	sub    $0xc,%esp
 8049dae:	68 77 ae 04 08       	push   $0x804ae77
 8049db3:	68 a4 ad 04 08       	push   $0x804ada4
 8049db8:	68 90 ab 04 08       	push   $0x804ab90
 8049dbd:	68 68 01 00 00       	push   $0x168
 8049dc2:	68 bb ad 04 08       	push   $0x804adbb
 8049dc7:	e8 e5 02 00 00       	call   804a0b1 <debug_panic>
  ASSERT (src != NULL);
 8049dcc:	85 d2                	test   %edx,%edx
 8049dce:	75 21                	jne    8049df1 <strlcat+0x58>
 8049dd0:	83 ec 0c             	sub    $0xc,%esp
 8049dd3:	68 83 ae 04 08       	push   $0x804ae83
 8049dd8:	68 a4 ad 04 08       	push   $0x804ada4
 8049ddd:	68 90 ab 04 08       	push   $0x804ab90
 8049de2:	68 69 01 00 00       	push   $0x169
 8049de7:	68 bb ad 04 08       	push   $0x804adbb
 8049dec:	e8 c0 02 00 00       	call   804a0b1 <debug_panic>

  src_len = strlen (src);
 8049df1:	be ff ff ff ff       	mov    $0xffffffff,%esi
 8049df6:	b8 00 00 00 00       	mov    $0x0,%eax
 8049dfb:	89 f1                	mov    %esi,%ecx
 8049dfd:	89 d7                	mov    %edx,%edi
 8049dff:	f2 ae                	repnz scas %es:(%edi),%al
 8049e01:	f7 d1                	not    %ecx
 8049e03:	8d 69 ff             	lea    -0x1(%ecx),%ebp
  dst_len = strlen (dst);
 8049e06:	89 f1                	mov    %esi,%ecx
 8049e08:	8b 7c 24 20          	mov    0x20(%esp),%edi
 8049e0c:	f2 ae                	repnz scas %es:(%edi),%al
 8049e0e:	89 c8                	mov    %ecx,%eax
 8049e10:	f7 d0                	not    %eax
 8049e12:	8d 58 ff             	lea    -0x1(%eax),%ebx
  if (size > 0 && dst_len < size) 
 8049e15:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
 8049e1a:	74 2c                	je     8049e48 <strlcat+0xaf>
 8049e1c:	3b 5c 24 28          	cmp    0x28(%esp),%ebx
 8049e20:	73 26                	jae    8049e48 <strlcat+0xaf>
    {
      size_t copy_cnt = size - dst_len - 1;
 8049e22:	8b 44 24 28          	mov    0x28(%esp),%eax
 8049e26:	8d 70 ff             	lea    -0x1(%eax),%esi
 8049e29:	29 de                	sub    %ebx,%esi
 8049e2b:	39 f5                	cmp    %esi,%ebp
 8049e2d:	0f 46 f5             	cmovbe %ebp,%esi
      if (src_len < copy_cnt)
        copy_cnt = src_len;
      memcpy (dst + dst_len, src, copy_cnt);
 8049e30:	89 df                	mov    %ebx,%edi
 8049e32:	03 7c 24 20          	add    0x20(%esp),%edi
 8049e36:	83 ec 04             	sub    $0x4,%esp
 8049e39:	56                   	push   %esi
 8049e3a:	52                   	push   %edx
 8049e3b:	57                   	push   %edi
 8049e3c:	e8 74 f8 ff ff       	call   80496b5 <memcpy>
      dst[dst_len + copy_cnt] = '\0';
 8049e41:	c6 04 37 00          	movb   $0x0,(%edi,%esi,1)
 8049e45:	83 c4 10             	add    $0x10,%esp
    }
  return src_len + dst_len;
 8049e48:	8d 44 1d 00          	lea    0x0(%ebp,%ebx,1),%eax
}
 8049e4c:	83 c4 0c             	add    $0xc,%esp
 8049e4f:	5b                   	pop    %ebx
 8049e50:	5e                   	pop    %esi
 8049e51:	5f                   	pop    %edi
 8049e52:	5d                   	pop    %ebp
 8049e53:	c3                   	ret    

08049e54 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
 8049e54:	55                   	push   %ebp
 8049e55:	57                   	push   %edi
 8049e56:	56                   	push   %esi
 8049e57:	53                   	push   %ebx
 8049e58:	83 ec 1c             	sub    $0x1c,%esp
 8049e5b:	89 04 24             	mov    %eax,(%esp)
 8049e5e:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049e62:	8b 74 24 30          	mov    0x30(%esp),%esi
 8049e66:	8b 7c 24 34          	mov    0x34(%esp),%edi
  if ((d >> 32) == 0) 
 8049e6a:	85 ff                	test   %edi,%edi
 8049e6c:	75 43                	jne    8049eb1 <udiv64+0x5d>
             <=> [b - 1/d] < b
         which is a tautology.

         Therefore, this code is correct and will not trap. */
      uint64_t b = 1ULL << 32;
      uint32_t n1 = n >> 32;
 8049e6e:	8b 44 24 04          	mov    0x4(%esp),%eax
      uint32_t n0 = n; 
      uint32_t d0 = d;

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
 8049e72:	ba 00 00 00 00       	mov    $0x0,%edx
 8049e77:	f7 f6                	div    %esi
 8049e79:	89 c7                	mov    %eax,%edi
 8049e7b:	89 d0                	mov    %edx,%eax
 8049e7d:	89 c2                	mov    %eax,%edx
 8049e7f:	b8 00 00 00 00       	mov    $0x0,%eax
 8049e84:	8b 0c 24             	mov    (%esp),%ecx
 8049e87:	bb 00 00 00 00       	mov    $0x0,%ebx
 8049e8c:	01 c8                	add    %ecx,%eax
 8049e8e:	11 da                	adc    %ebx,%edx
{
  uint32_t n1 = n >> 32;
  uint32_t n0 = n;
  uint32_t q, r;

  asm ("divl %4"
 8049e90:	f7 f6                	div    %esi
      uint64_t b = 1ULL << 32;
      uint32_t n1 = n >> 32;
      uint32_t n0 = n; 
      uint32_t d0 = d;

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
 8049e92:	89 f9                	mov    %edi,%ecx
 8049e94:	89 cf                	mov    %ecx,%edi
 8049e96:	be 00 00 00 00       	mov    $0x0,%esi
 8049e9b:	ba 00 00 00 00       	mov    $0x0,%edx
 8049ea0:	01 c6                	add    %eax,%esi
 8049ea2:	11 d7                	adc    %edx,%edi
 8049ea4:	89 74 24 08          	mov    %esi,0x8(%esp)
 8049ea8:	89 7c 24 0c          	mov    %edi,0xc(%esp)
 8049eac:	e9 05 01 00 00       	jmp    8049fb6 <udiv64+0x162>
 8049eb1:	89 fa                	mov    %edi,%edx
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
 8049eb3:	8b 0c 24             	mov    (%esp),%ecx
 8049eb6:	8b 5c 24 04          	mov    0x4(%esp),%ebx
 8049eba:	39 df                	cmp    %ebx,%edi
 8049ebc:	0f 87 e4 00 00 00    	ja     8049fa6 <udiv64+0x152>
 8049ec2:	72 08                	jb     8049ecc <udiv64+0x78>
 8049ec4:	39 ce                	cmp    %ecx,%esi
 8049ec6:	0f 87 da 00 00 00    	ja     8049fa6 <udiv64+0x152>
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
 8049ecc:	89 d0                	mov    %edx,%eax
  /* This technique is portable, but there are better ways to do
     it on particular systems.  With sufficiently new enough GCC,
     you can use __builtin_clz() to take advantage of GCC's
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
 8049ece:	bd 00 00 00 00       	mov    $0x0,%ebp
  if (x <= 0x0000FFFF)
 8049ed3:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
 8049ed9:	77 08                	ja     8049ee3 <udiv64+0x8f>
    {
      n += 16;
      x <<= 16; 
 8049edb:	c1 e0 10             	shl    $0x10,%eax
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
  if (x <= 0x0000FFFF)
    {
      n += 16;
 8049ede:	bd 10 00 00 00       	mov    $0x10,%ebp
      x <<= 16; 
    }
  if (x <= 0x00FFFFFF)
 8049ee3:	3d ff ff ff 00       	cmp    $0xffffff,%eax
 8049ee8:	77 06                	ja     8049ef0 <udiv64+0x9c>
    {
      n += 8;
 8049eea:	83 c5 08             	add    $0x8,%ebp
      x <<= 8; 
 8049eed:	c1 e0 08             	shl    $0x8,%eax
    }
  if (x <= 0x0FFFFFFF)
 8049ef0:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
 8049ef5:	77 06                	ja     8049efd <udiv64+0xa9>
    {
      n += 4;
 8049ef7:	83 c5 04             	add    $0x4,%ebp
      x <<= 4;
 8049efa:	c1 e0 04             	shl    $0x4,%eax
    }
  if (x <= 0x3FFFFFFF)
 8049efd:	3d ff ff ff 3f       	cmp    $0x3fffffff,%eax
 8049f02:	77 06                	ja     8049f0a <udiv64+0xb6>
    {
      n += 2;
 8049f04:	83 c5 02             	add    $0x2,%ebp
      x <<= 2; 
 8049f07:	c1 e0 02             	shl    $0x2,%eax
    }
  if (x <= 0x7FFFFFFF)
    n++;
 8049f0a:	3d 00 00 00 80       	cmp    $0x80000000,%eax
 8049f0f:	83 d5 00             	adc    $0x0,%ebp
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
 8049f12:	8b 04 24             	mov    (%esp),%eax
 8049f15:	8b 54 24 04          	mov    0x4(%esp),%edx
 8049f19:	0f ac d0 01          	shrd   $0x1,%edx,%eax
 8049f1d:	d1 ea                	shr    %edx
 8049f1f:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049f23:	89 54 24 0c          	mov    %edx,0xc(%esp)
{
  uint32_t n1 = n >> 32;
  uint32_t n0 = n;
  uint32_t q, r;

  asm ("divl %4"
 8049f27:	89 f0                	mov    %esi,%eax
 8049f29:	89 fa                	mov    %edi,%edx
 8049f2b:	89 e9                	mov    %ebp,%ecx
 8049f2d:	0f a5 f2             	shld   %cl,%esi,%edx
 8049f30:	d3 e0                	shl    %cl,%eax
 8049f32:	f6 c1 20             	test   $0x20,%cl
 8049f35:	74 02                	je     8049f39 <udiv64+0xe5>
 8049f37:	89 c2                	mov    %eax,%edx
 8049f39:	89 d3                	mov    %edx,%ebx
 8049f3b:	8b 54 24 0c          	mov    0xc(%esp),%edx
 8049f3f:	8b 44 24 08          	mov    0x8(%esp),%eax
 8049f43:	f7 f3                	div    %ebx
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
 8049f45:	b9 1f 00 00 00       	mov    $0x1f,%ecx
 8049f4a:	29 e9                	sub    %ebp,%ecx
 8049f4c:	d3 e8                	shr    %cl,%eax
 8049f4e:	89 c2                	mov    %eax,%edx
 8049f50:	b9 00 00 00 00       	mov    $0x0,%ecx
 8049f55:	89 44 24 10          	mov    %eax,0x10(%esp)
 8049f59:	89 4c 24 14          	mov    %ecx,0x14(%esp)
          return n - (q - 1) * d < d ? q - 1 : q; 
 8049f5d:	83 c2 ff             	add    $0xffffffff,%edx
 8049f60:	83 d1 ff             	adc    $0xffffffff,%ecx
 8049f63:	89 cb                	mov    %ecx,%ebx
 8049f65:	89 54 24 08          	mov    %edx,0x8(%esp)
 8049f69:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 8049f6d:	89 fd                	mov    %edi,%ebp
 8049f6f:	0f af ea             	imul   %edx,%ebp
 8049f72:	89 d8                	mov    %ebx,%eax
 8049f74:	0f af c6             	imul   %esi,%eax
 8049f77:	01 c5                	add    %eax,%ebp
 8049f79:	89 f0                	mov    %esi,%eax
 8049f7b:	f7 e2                	mul    %edx
 8049f7d:	01 ea                	add    %ebp,%edx
 8049f7f:	8b 0c 24             	mov    (%esp),%ecx
 8049f82:	8b 5c 24 04          	mov    0x4(%esp),%ebx
 8049f86:	29 c1                	sub    %eax,%ecx
 8049f88:	19 d3                	sbb    %edx,%ebx
 8049f8a:	39 df                	cmp    %ebx,%edi
 8049f8c:	77 28                	ja     8049fb6 <udiv64+0x162>
 8049f8e:	72 04                	jb     8049f94 <udiv64+0x140>
 8049f90:	39 ce                	cmp    %ecx,%esi
 8049f92:	77 22                	ja     8049fb6 <udiv64+0x162>
 8049f94:	8b 44 24 10          	mov    0x10(%esp),%eax
 8049f98:	8b 54 24 14          	mov    0x14(%esp),%edx
 8049f9c:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049fa0:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8049fa4:	eb 10                	jmp    8049fb6 <udiv64+0x162>
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
        return 0;
 8049fa6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 8049fad:	00 
 8049fae:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 8049fb5:	00 
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
          return n - (q - 1) * d < d ? q - 1 : q; 
        }
    }
}
 8049fb6:	8b 44 24 08          	mov    0x8(%esp),%eax
 8049fba:	8b 54 24 0c          	mov    0xc(%esp),%edx
 8049fbe:	83 c4 1c             	add    $0x1c,%esp
 8049fc1:	5b                   	pop    %ebx
 8049fc2:	5e                   	pop    %esi
 8049fc3:	5f                   	pop    %edi
 8049fc4:	5d                   	pop    %ebp
 8049fc5:	c3                   	ret    

08049fc6 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
 8049fc6:	57                   	push   %edi
 8049fc7:	56                   	push   %esi
 8049fc8:	53                   	push   %ebx
 8049fc9:	83 ec 08             	sub    $0x8,%esp
 8049fcc:	89 04 24             	mov    %eax,(%esp)
 8049fcf:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049fd3:	8b 74 24 18          	mov    0x18(%esp),%esi
 8049fd7:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
 8049fdb:	85 d2                	test   %edx,%edx
 8049fdd:	79 07                	jns    8049fe6 <sdiv64+0x20>
 8049fdf:	f7 d8                	neg    %eax
 8049fe1:	83 d2 00             	adc    $0x0,%edx
 8049fe4:	f7 da                	neg    %edx
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
 8049fe6:	89 f1                	mov    %esi,%ecx
 8049fe8:	89 fb                	mov    %edi,%ebx
 8049fea:	85 ff                	test   %edi,%edi
 8049fec:	79 07                	jns    8049ff5 <sdiv64+0x2f>
 8049fee:	f7 d9                	neg    %ecx
 8049ff0:	83 d3 00             	adc    $0x0,%ebx
 8049ff3:	f7 db                	neg    %ebx
  uint64_t q_abs = udiv64 (n_abs, d_abs);
 8049ff5:	53                   	push   %ebx
 8049ff6:	51                   	push   %ecx
 8049ff7:	e8 58 fe ff ff       	call   8049e54 <udiv64>
 8049ffc:	83 c4 08             	add    $0x8,%esp
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
 8049fff:	8b 4c 24 04          	mov    0x4(%esp),%ecx
 804a003:	f7 d1                	not    %ecx
 804a005:	c1 e9 1f             	shr    $0x1f,%ecx
 804a008:	89 fb                	mov    %edi,%ebx
 804a00a:	c1 eb 1f             	shr    $0x1f,%ebx
 804a00d:	38 d9                	cmp    %bl,%cl
 804a00f:	75 07                	jne    804a018 <sdiv64+0x52>
 804a011:	f7 d8                	neg    %eax
 804a013:	83 d2 00             	adc    $0x0,%edx
 804a016:	f7 da                	neg    %edx
}
 804a018:	83 c4 08             	add    $0x8,%esp
 804a01b:	5b                   	pop    %ebx
 804a01c:	5e                   	pop    %esi
 804a01d:	5f                   	pop    %edi
 804a01e:	c3                   	ret    

0804a01f <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
 804a01f:	83 ec 04             	sub    $0x4,%esp
  return sdiv64 (n, d);
 804a022:	ff 74 24 14          	pushl  0x14(%esp)
 804a026:	ff 74 24 14          	pushl  0x14(%esp)
 804a02a:	8b 44 24 10          	mov    0x10(%esp),%eax
 804a02e:	8b 54 24 14          	mov    0x14(%esp),%edx
 804a032:	e8 8f ff ff ff       	call   8049fc6 <sdiv64>
}
 804a037:	83 c4 0c             	add    $0xc,%esp
 804a03a:	c3                   	ret    

0804a03b <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
 804a03b:	57                   	push   %edi
 804a03c:	56                   	push   %esi
 804a03d:	53                   	push   %ebx
 804a03e:	8b 5c 24 10          	mov    0x10(%esp),%ebx
 804a042:	8b 74 24 18          	mov    0x18(%esp),%esi
 804a046:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
/* Divides signed 64-bit N by signed 64-bit D and returns the
   remainder. */
static int32_t
smod64 (int64_t n, int64_t d)
{
  return n - d * sdiv64 (n, d);
 804a04a:	57                   	push   %edi
 804a04b:	56                   	push   %esi
 804a04c:	89 d8                	mov    %ebx,%eax
 804a04e:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 804a052:	e8 6f ff ff ff       	call   8049fc6 <sdiv64>
 804a057:	83 c4 08             	add    $0x8,%esp

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
  return smod64 (n, d);
 804a05a:	0f af f0             	imul   %eax,%esi
 804a05d:	89 d8                	mov    %ebx,%eax
 804a05f:	29 f0                	sub    %esi,%eax
 804a061:	99                   	cltd   
}
 804a062:	5b                   	pop    %ebx
 804a063:	5e                   	pop    %esi
 804a064:	5f                   	pop    %edi
 804a065:	c3                   	ret    

0804a066 <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
 804a066:	83 ec 04             	sub    $0x4,%esp
  return udiv64 (n, d);
 804a069:	ff 74 24 14          	pushl  0x14(%esp)
 804a06d:	ff 74 24 14          	pushl  0x14(%esp)
 804a071:	8b 44 24 10          	mov    0x10(%esp),%eax
 804a075:	8b 54 24 14          	mov    0x14(%esp),%edx
 804a079:	e8 d6 fd ff ff       	call   8049e54 <udiv64>
}
 804a07e:	83 c4 0c             	add    $0xc,%esp
 804a081:	c3                   	ret    

0804a082 <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
 804a082:	57                   	push   %edi
 804a083:	56                   	push   %esi
 804a084:	53                   	push   %ebx
 804a085:	8b 5c 24 10          	mov    0x10(%esp),%ebx
 804a089:	8b 74 24 18          	mov    0x18(%esp),%esi
 804a08d:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   remainder. */
static uint32_t
umod64 (uint64_t n, uint64_t d)
{
  return n - d * udiv64 (n, d);
 804a091:	57                   	push   %edi
 804a092:	56                   	push   %esi
 804a093:	89 d8                	mov    %ebx,%eax
 804a095:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 804a099:	e8 b6 fd ff ff       	call   8049e54 <udiv64>
 804a09e:	83 c4 08             	add    $0x8,%esp

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
  return umod64 (n, d);
 804a0a1:	0f af f0             	imul   %eax,%esi
 804a0a4:	89 d8                	mov    %ebx,%eax
 804a0a6:	29 f0                	sub    %esi,%eax
 804a0a8:	ba 00 00 00 00       	mov    $0x0,%edx
}
 804a0ad:	5b                   	pop    %ebx
 804a0ae:	5e                   	pop    %esi
 804a0af:	5f                   	pop    %edi
 804a0b0:	c3                   	ret    

0804a0b1 <debug_panic>:
/* Aborts the user program, printing the source file name, line
   number, and function name, plus a user-specific message. */
void
debug_panic (const char *file, int line, const char *function,
             const char *message, ...)
{
 804a0b1:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  printf ("User process ABORT at %s:%d in %s(): ", file, line, function);
 804a0b4:	ff 74 24 18          	pushl  0x18(%esp)
 804a0b8:	ff 74 24 18          	pushl  0x18(%esp)
 804a0bc:	ff 74 24 18          	pushl  0x18(%esp)
 804a0c0:	68 58 b0 04 08       	push   $0x804b058
 804a0c5:	e8 4e ec ff ff       	call   8048d18 <printf>

  va_start (args, message);
 804a0ca:	8d 44 24 30          	lea    0x30(%esp),%eax
  vprintf (message, args);
 804a0ce:	83 c4 08             	add    $0x8,%esp
 804a0d1:	50                   	push   %eax
 804a0d2:	ff 74 24 28          	pushl  0x28(%esp)
 804a0d6:	e8 82 02 00 00       	call   804a35d <vprintf>
  printf ("\n");
 804a0db:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 804a0e2:	e8 dc 01 00 00       	call   804a2c3 <putchar>
  va_end (args);

  debug_backtrace ();
 804a0e7:	e8 a3 02 00 00       	call   804a38f <debug_backtrace>
  
  exit (1);
 804a0ec:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a0f3:	e8 20 00 00 00       	call   804a118 <exit>

0804a0f8 <halt>:
          retval;                                               \
        })

void
halt (void) 
{
 804a0f8:	83 ec 0c             	sub    $0xc,%esp
  syscall0 (SYS_HALT);
 804a0fb:	6a 00                	push   $0x0
 804a0fd:	cd 30                	int    $0x30
 804a0ff:	83 c4 04             	add    $0x4,%esp
  NOT_REACHED ();
 804a102:	68 34 b0 04 08       	push   $0x804b034
 804a107:	68 f4 ab 04 08       	push   $0x804abf4
 804a10c:	6a 47                	push   $0x47
 804a10e:	68 8f ae 04 08       	push   $0x804ae8f
 804a113:	e8 99 ff ff ff       	call   804a0b1 <debug_panic>

0804a118 <exit>:
}

void
exit (int status)
{
 804a118:	83 ec 0c             	sub    $0xc,%esp
  syscall1 (SYS_EXIT, status);
 804a11b:	8b 44 24 10          	mov    0x10(%esp),%eax
 804a11f:	50                   	push   %eax
 804a120:	6a 01                	push   $0x1
 804a122:	cd 30                	int    $0x30
 804a124:	83 c4 08             	add    $0x8,%esp
  NOT_REACHED ();
 804a127:	68 34 b0 04 08       	push   $0x804b034
 804a12c:	68 ec ab 04 08       	push   $0x804abec
 804a131:	6a 4e                	push   $0x4e
 804a133:	68 8f ae 04 08       	push   $0x804ae8f
 804a138:	e8 74 ff ff ff       	call   804a0b1 <debug_panic>

0804a13d <exec>:
}

pid_t
exec (const char *file)
{
  return (pid_t) syscall1 (SYS_EXEC, file);
 804a13d:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a141:	50                   	push   %eax
 804a142:	6a 02                	push   $0x2
 804a144:	cd 30                	int    $0x30
 804a146:	83 c4 08             	add    $0x8,%esp
}
 804a149:	c3                   	ret    

0804a14a <wait>:

int
wait (pid_t pid)
{
  return syscall1 (SYS_WAIT, pid);
 804a14a:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a14e:	50                   	push   %eax
 804a14f:	6a 03                	push   $0x3
 804a151:	cd 30                	int    $0x30
 804a153:	83 c4 08             	add    $0x8,%esp
}
 804a156:	c3                   	ret    

0804a157 <create>:

bool
create (const char *file, unsigned initial_size)
{
  return syscall2 (SYS_CREATE, file, initial_size);
 804a157:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a15b:	8b 4c 24 04          	mov    0x4(%esp),%ecx
 804a15f:	50                   	push   %eax
 804a160:	51                   	push   %ecx
 804a161:	6a 04                	push   $0x4
 804a163:	cd 30                	int    $0x30
 804a165:	83 c4 0c             	add    $0xc,%esp
 804a168:	85 c0                	test   %eax,%eax
 804a16a:	0f 95 c0             	setne  %al
}
 804a16d:	c3                   	ret    

0804a16e <remove>:

bool
remove (const char *file)
{
  return syscall1 (SYS_REMOVE, file);
 804a16e:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a172:	50                   	push   %eax
 804a173:	6a 05                	push   $0x5
 804a175:	cd 30                	int    $0x30
 804a177:	83 c4 08             	add    $0x8,%esp
 804a17a:	85 c0                	test   %eax,%eax
 804a17c:	0f 95 c0             	setne  %al
}
 804a17f:	c3                   	ret    

0804a180 <open>:

int
open (const char *file)
{
  return syscall1 (SYS_OPEN, file);
 804a180:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a184:	50                   	push   %eax
 804a185:	6a 06                	push   $0x6
 804a187:	cd 30                	int    $0x30
 804a189:	83 c4 08             	add    $0x8,%esp
}
 804a18c:	c3                   	ret    

0804a18d <filesize>:

int
filesize (int fd) 
{
  return syscall1 (SYS_FILESIZE, fd);
 804a18d:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a191:	50                   	push   %eax
 804a192:	6a 07                	push   $0x7
 804a194:	cd 30                	int    $0x30
 804a196:	83 c4 08             	add    $0x8,%esp
}
 804a199:	c3                   	ret    

0804a19a <read>:

int
read (int fd, void *buffer, unsigned size)
{
  return syscall3 (SYS_READ, fd, buffer, size);
 804a19a:	8b 44 24 0c          	mov    0xc(%esp),%eax
 804a19e:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 804a1a2:	8b 54 24 04          	mov    0x4(%esp),%edx
 804a1a6:	50                   	push   %eax
 804a1a7:	51                   	push   %ecx
 804a1a8:	52                   	push   %edx
 804a1a9:	6a 08                	push   $0x8
 804a1ab:	cd 30                	int    $0x30
 804a1ad:	83 c4 10             	add    $0x10,%esp
}
 804a1b0:	c3                   	ret    

0804a1b1 <write>:

int
write (int fd, const void *buffer, unsigned size)
{
  return syscall3 (SYS_WRITE, fd, buffer, size);
 804a1b1:	8b 44 24 0c          	mov    0xc(%esp),%eax
 804a1b5:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 804a1b9:	8b 54 24 04          	mov    0x4(%esp),%edx
 804a1bd:	50                   	push   %eax
 804a1be:	51                   	push   %ecx
 804a1bf:	52                   	push   %edx
 804a1c0:	6a 09                	push   $0x9
 804a1c2:	cd 30                	int    $0x30
 804a1c4:	83 c4 10             	add    $0x10,%esp
}
 804a1c7:	c3                   	ret    

0804a1c8 <seek>:

void
seek (int fd, unsigned position) 
{
  syscall2 (SYS_SEEK, fd, position);
 804a1c8:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a1cc:	8b 4c 24 04          	mov    0x4(%esp),%ecx
 804a1d0:	50                   	push   %eax
 804a1d1:	51                   	push   %ecx
 804a1d2:	6a 0a                	push   $0xa
 804a1d4:	cd 30                	int    $0x30
 804a1d6:	83 c4 0c             	add    $0xc,%esp
 804a1d9:	c3                   	ret    

0804a1da <tell>:
}

unsigned
tell (int fd) 
{
  return syscall1 (SYS_TELL, fd);
 804a1da:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a1de:	50                   	push   %eax
 804a1df:	6a 0b                	push   $0xb
 804a1e1:	cd 30                	int    $0x30
 804a1e3:	83 c4 08             	add    $0x8,%esp
}
 804a1e6:	c3                   	ret    

0804a1e7 <close>:

void
close (int fd)
{
  syscall1 (SYS_CLOSE, fd);
 804a1e7:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a1eb:	50                   	push   %eax
 804a1ec:	6a 0c                	push   $0xc
 804a1ee:	cd 30                	int    $0x30
 804a1f0:	83 c4 08             	add    $0x8,%esp
 804a1f3:	c3                   	ret    

0804a1f4 <mmap>:
}

mapid_t
mmap (int fd, void *addr)
{
  return syscall2 (SYS_MMAP, fd, addr);
 804a1f4:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a1f8:	8b 4c 24 04          	mov    0x4(%esp),%ecx
 804a1fc:	50                   	push   %eax
 804a1fd:	51                   	push   %ecx
 804a1fe:	6a 0d                	push   $0xd
 804a200:	cd 30                	int    $0x30
 804a202:	83 c4 0c             	add    $0xc,%esp
}
 804a205:	c3                   	ret    

0804a206 <munmap>:

void
munmap (mapid_t mapid)
{
  syscall1 (SYS_MUNMAP, mapid);
 804a206:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a20a:	50                   	push   %eax
 804a20b:	6a 0e                	push   $0xe
 804a20d:	cd 30                	int    $0x30
 804a20f:	83 c4 08             	add    $0x8,%esp
 804a212:	c3                   	ret    

0804a213 <chdir>:
}

bool
chdir (const char *dir)
{
  return syscall1 (SYS_CHDIR, dir);
 804a213:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a217:	50                   	push   %eax
 804a218:	6a 0f                	push   $0xf
 804a21a:	cd 30                	int    $0x30
 804a21c:	83 c4 08             	add    $0x8,%esp
 804a21f:	85 c0                	test   %eax,%eax
 804a221:	0f 95 c0             	setne  %al
}
 804a224:	c3                   	ret    

0804a225 <mkdir>:

bool
mkdir (const char *dir)
{
  return syscall1 (SYS_MKDIR, dir);
 804a225:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a229:	50                   	push   %eax
 804a22a:	6a 10                	push   $0x10
 804a22c:	cd 30                	int    $0x30
 804a22e:	83 c4 08             	add    $0x8,%esp
 804a231:	85 c0                	test   %eax,%eax
 804a233:	0f 95 c0             	setne  %al
}
 804a236:	c3                   	ret    

0804a237 <readdir>:

bool
readdir (int fd, char name[READDIR_MAX_LEN + 1]) 
{
  return syscall2 (SYS_READDIR, fd, name);
 804a237:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a23b:	8b 4c 24 04          	mov    0x4(%esp),%ecx
 804a23f:	50                   	push   %eax
 804a240:	51                   	push   %ecx
 804a241:	6a 11                	push   $0x11
 804a243:	cd 30                	int    $0x30
 804a245:	83 c4 0c             	add    $0xc,%esp
 804a248:	85 c0                	test   %eax,%eax
 804a24a:	0f 95 c0             	setne  %al
}
 804a24d:	c3                   	ret    

0804a24e <isdir>:

bool
isdir (int fd) 
{
  return syscall1 (SYS_ISDIR, fd);
 804a24e:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a252:	50                   	push   %eax
 804a253:	6a 12                	push   $0x12
 804a255:	cd 30                	int    $0x30
 804a257:	83 c4 08             	add    $0x8,%esp
 804a25a:	85 c0                	test   %eax,%eax
 804a25c:	0f 95 c0             	setne  %al
}
 804a25f:	c3                   	ret    

0804a260 <inumber>:

int
inumber (int fd) 
{
  return syscall1 (SYS_INUMBER, fd);
 804a260:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a264:	50                   	push   %eax
 804a265:	6a 13                	push   $0x13
 804a267:	cd 30                	int    $0x30
 804a269:	83 c4 08             	add    $0x8,%esp
}
 804a26c:	c3                   	ret    

0804a26d <flush>:
}

/* Flushes the buffer in AUX. */
static void
flush (struct vhprintf_aux *aux)
{
 804a26d:	53                   	push   %ebx
 804a26e:	83 ec 08             	sub    $0x8,%esp
 804a271:	89 c3                	mov    %eax,%ebx
  if (aux->p > aux->buf)
 804a273:	8b 40 40             	mov    0x40(%eax),%eax
 804a276:	39 d8                	cmp    %ebx,%eax
 804a278:	76 12                	jbe    804a28c <flush+0x1f>
    write (aux->handle, aux->buf, aux->p - aux->buf);
 804a27a:	83 ec 04             	sub    $0x4,%esp
 804a27d:	29 d8                	sub    %ebx,%eax
 804a27f:	50                   	push   %eax
 804a280:	53                   	push   %ebx
 804a281:	ff 73 48             	pushl  0x48(%ebx)
 804a284:	e8 28 ff ff ff       	call   804a1b1 <write>
 804a289:	83 c4 10             	add    $0x10,%esp
  aux->p = aux->buf;
 804a28c:	89 5b 40             	mov    %ebx,0x40(%ebx)
}
 804a28f:	83 c4 08             	add    $0x8,%esp
 804a292:	5b                   	pop    %ebx
 804a293:	c3                   	ret    

0804a294 <add_char>:

/* Adds C to the buffer in AUX, flushing it if the buffer fills
   up. */
static void
add_char (char c, void *aux_) 
{
 804a294:	53                   	push   %ebx
 804a295:	83 ec 08             	sub    $0x8,%esp
 804a298:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  struct vhprintf_aux *aux = aux_;
  *aux->p++ = c;
 804a29c:	8b 43 40             	mov    0x40(%ebx),%eax
 804a29f:	8d 50 01             	lea    0x1(%eax),%edx
 804a2a2:	89 53 40             	mov    %edx,0x40(%ebx)
 804a2a5:	8b 54 24 10          	mov    0x10(%esp),%edx
 804a2a9:	88 10                	mov    %dl,(%eax)
  if (aux->p >= aux->buf + sizeof aux->buf)
 804a2ab:	8d 43 40             	lea    0x40(%ebx),%eax
 804a2ae:	39 43 40             	cmp    %eax,0x40(%ebx)
 804a2b1:	72 07                	jb     804a2ba <add_char+0x26>
    flush (aux);
 804a2b3:	89 d8                	mov    %ebx,%eax
 804a2b5:	e8 b3 ff ff ff       	call   804a26d <flush>
  aux->char_cnt++;
 804a2ba:	83 43 44 01          	addl   $0x1,0x44(%ebx)
}
 804a2be:	83 c4 08             	add    $0x8,%esp
 804a2c1:	5b                   	pop    %ebx
 804a2c2:	c3                   	ret    

0804a2c3 <putchar>:
}

/* Writes C to the console. */
int
putchar (int c) 
{
 804a2c3:	53                   	push   %ebx
 804a2c4:	83 ec 1c             	sub    $0x1c,%esp
 804a2c7:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  char c2 = c;
 804a2cb:	88 5c 24 13          	mov    %bl,0x13(%esp)
  write (STDOUT_FILENO, &c2, 1);
 804a2cf:	6a 01                	push   $0x1
 804a2d1:	8d 44 24 17          	lea    0x17(%esp),%eax
 804a2d5:	50                   	push   %eax
 804a2d6:	6a 01                	push   $0x1
 804a2d8:	e8 d4 fe ff ff       	call   804a1b1 <write>
  return c;
}
 804a2dd:	89 d8                	mov    %ebx,%eax
 804a2df:	83 c4 28             	add    $0x28,%esp
 804a2e2:	5b                   	pop    %ebx
 804a2e3:	c3                   	ret    

0804a2e4 <puts>:

/* Writes string S to the console, followed by a new-line
   character. */
int
puts (const char *s) 
{
 804a2e4:	57                   	push   %edi
 804a2e5:	83 ec 0c             	sub    $0xc,%esp
 804a2e8:	8b 54 24 14          	mov    0x14(%esp),%edx
  write (STDOUT_FILENO, s, strlen (s));
 804a2ec:	b8 00 00 00 00       	mov    $0x0,%eax
 804a2f1:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 804a2f6:	89 d7                	mov    %edx,%edi
 804a2f8:	f2 ae                	repnz scas %es:(%edi),%al
 804a2fa:	f7 d1                	not    %ecx
 804a2fc:	83 e9 01             	sub    $0x1,%ecx
 804a2ff:	51                   	push   %ecx
 804a300:	52                   	push   %edx
 804a301:	6a 01                	push   $0x1
 804a303:	e8 a9 fe ff ff       	call   804a1b1 <write>
  putchar ('\n');
 804a308:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 804a30f:	e8 af ff ff ff       	call   804a2c3 <putchar>

  return 0;
}
 804a314:	b8 00 00 00 00       	mov    $0x0,%eax
 804a319:	83 c4 18             	add    $0x18,%esp
 804a31c:	5f                   	pop    %edi
 804a31d:	c3                   	ret    

0804a31e <vhprintf>:
/* Formats the printf() format specification FORMAT with
   arguments given in ARGS and writes the output to the given
   HANDLE. */
int
vhprintf (int handle, const char *format, va_list args) 
{
 804a31e:	53                   	push   %ebx
 804a31f:	83 ec 58             	sub    $0x58,%esp
  struct vhprintf_aux aux;
  aux.p = aux.buf;
 804a322:	8d 5c 24 04          	lea    0x4(%esp),%ebx
 804a326:	89 5c 24 44          	mov    %ebx,0x44(%esp)
  aux.char_cnt = 0;
 804a32a:	c7 44 24 48 00 00 00 	movl   $0x0,0x48(%esp)
 804a331:	00 
  aux.handle = handle;
 804a332:	8b 44 24 60          	mov    0x60(%esp),%eax
 804a336:	89 44 24 4c          	mov    %eax,0x4c(%esp)
  __vprintf (format, args, add_char, &aux);
 804a33a:	53                   	push   %ebx
 804a33b:	68 94 a2 04 08       	push   $0x804a294
 804a340:	ff 74 24 70          	pushl  0x70(%esp)
 804a344:	ff 74 24 70          	pushl  0x70(%esp)
 804a348:	e8 00 ea ff ff       	call   8048d4d <__vprintf>
  flush (&aux);
 804a34d:	89 d8                	mov    %ebx,%eax
 804a34f:	e8 19 ff ff ff       	call   804a26d <flush>
  return aux.char_cnt;
}
 804a354:	8b 44 24 58          	mov    0x58(%esp),%eax
 804a358:	83 c4 68             	add    $0x68,%esp
 804a35b:	5b                   	pop    %ebx
 804a35c:	c3                   	ret    

0804a35d <vprintf>:

/* The standard vprintf() function,
   which is like printf() but uses a va_list. */
int
vprintf (const char *format, va_list args) 
{
 804a35d:	83 ec 10             	sub    $0x10,%esp
  return vhprintf (STDOUT_FILENO, format, args);
 804a360:	ff 74 24 18          	pushl  0x18(%esp)
 804a364:	ff 74 24 18          	pushl  0x18(%esp)
 804a368:	6a 01                	push   $0x1
 804a36a:	e8 af ff ff ff       	call   804a31e <vhprintf>
}
 804a36f:	83 c4 1c             	add    $0x1c,%esp
 804a372:	c3                   	ret    

0804a373 <hprintf>:

/* Like printf(), but writes output to the given HANDLE. */
int
hprintf (int handle, const char *format, ...) 
{
 804a373:	83 ec 0c             	sub    $0xc,%esp
  va_list args;
  int retval;

  va_start (args, format);
 804a376:	8d 44 24 18          	lea    0x18(%esp),%eax
  retval = vhprintf (handle, format, args);
 804a37a:	83 ec 04             	sub    $0x4,%esp
 804a37d:	50                   	push   %eax
 804a37e:	ff 74 24 1c          	pushl  0x1c(%esp)
 804a382:	ff 74 24 1c          	pushl  0x1c(%esp)
 804a386:	e8 93 ff ff ff       	call   804a31e <vhprintf>
  va_end (args);

  return retval;
}
 804a38b:	83 c4 1c             	add    $0x1c,%esp
 804a38e:	c3                   	ret    

0804a38f <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
 804a38f:	55                   	push   %ebp
 804a390:	89 e5                	mov    %esp,%ebp
 804a392:	53                   	push   %ebx
 804a393:	83 ec 0c             	sub    $0xc,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
 804a396:	ff 75 04             	pushl  0x4(%ebp)
 804a399:	68 a8 ae 04 08       	push   $0x804aea8
 804a39e:	e8 75 e9 ff ff       	call   8048d18 <printf>
  for (frame = __builtin_frame_address (1);
 804a3a3:	8b 5d 00             	mov    0x0(%ebp),%ebx
 804a3a6:	83 c4 10             	add    $0x10,%esp
 804a3a9:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
 804a3af:	76 27                	jbe    804a3d8 <debug_backtrace+0x49>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
 804a3b1:	83 3b 00             	cmpl   $0x0,(%ebx)
 804a3b4:	74 22                	je     804a3d8 <debug_backtrace+0x49>
       frame = frame[0]) 
    printf (" %p", frame[1]);
 804a3b6:	83 ec 08             	sub    $0x8,%esp
 804a3b9:	ff 73 04             	pushl  0x4(%ebx)
 804a3bc:	68 b3 ae 04 08       	push   $0x804aeb3
 804a3c1:	e8 52 e9 ff ff       	call   8048d18 <printf>
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
 804a3c6:	8b 1b                	mov    (%ebx),%ebx
{
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
 804a3c8:	83 c4 10             	add    $0x10,%esp
 804a3cb:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
 804a3d1:	76 05                	jbe    804a3d8 <debug_backtrace+0x49>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
 804a3d3:	83 3b 00             	cmpl   $0x0,(%ebx)
 804a3d6:	75 de                	jne    804a3b6 <debug_backtrace+0x27>
       frame = frame[0]) 
    printf (" %p", frame[1]);
  printf (".\n");
 804a3d8:	83 ec 0c             	sub    $0xc,%esp
 804a3db:	68 b9 ad 04 08       	push   $0x804adb9
 804a3e0:	e8 ff fe ff ff       	call   804a2e4 <puts>

  if (!explained) 
 804a3e5:	83 c4 10             	add    $0x10,%esp
 804a3e8:	80 3d 80 c6 04 08 00 	cmpb   $0x0,0x804c680
 804a3ef:	75 17                	jne    804a408 <debug_backtrace+0x79>
    {
      explained = true;
 804a3f1:	c6 05 80 c6 04 08 01 	movb   $0x1,0x804c680
      printf ("The `backtrace' program can make call stacks useful.\n"
 804a3f8:	83 ec 0c             	sub    $0xc,%esp
 804a3fb:	68 80 b0 04 08       	push   $0x804b080
 804a400:	e8 df fe ff ff       	call   804a2e4 <puts>
 804a405:	83 c4 10             	add    $0x10,%esp
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
 804a408:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804a40b:	c9                   	leave  
 804a40c:	c3                   	ret    
