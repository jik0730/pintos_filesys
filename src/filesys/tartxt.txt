
build/tests/filesys/extended/tar:     file format elf32-i386


Disassembly of section .text:

08048094 <do_write>:
          && do_write (archive_fd, header, 512, write_error));
}

static bool
do_write (int fd, const char *buffer, int size, bool *write_error) 
{
 8048094:	56                   	push   %esi
 8048095:	53                   	push   %ebx
 8048096:	83 ec 08             	sub    $0x8,%esp
 8048099:	89 cb                	mov    %ecx,%ebx
 804809b:	8b 74 24 14          	mov    0x14(%esp),%esi
  if (write (fd, buffer, size) == size) 
 804809f:	51                   	push   %ecx
 80480a0:	52                   	push   %edx
 80480a1:	50                   	push   %eax
 80480a2:	e8 5a 29 00 00       	call   804aa01 <write>
 80480a7:	83 c4 10             	add    $0x10,%esp
 80480aa:	39 c3                	cmp    %eax,%ebx
 80480ac:	74 1c                	je     80480ca <do_write+0x36>
    return true;
  else
    {
      if (!*write_error) 
 80480ae:	0f b6 1e             	movzbl (%esi),%ebx
 80480b1:	84 db                	test   %bl,%bl
 80480b3:	75 1c                	jne    80480d1 <do_write+0x3d>
        {
          printf ("error writing archive\n");
 80480b5:	83 ec 0c             	sub    $0xc,%esp
 80480b8:	68 5d b4 04 08       	push   $0x804b45d
 80480bd:	e8 72 2a 00 00       	call   804ab34 <puts>
          *write_error = true; 
 80480c2:	c6 06 01             	movb   $0x1,(%esi)
 80480c5:	83 c4 10             	add    $0x10,%esp
 80480c8:	eb 0c                	jmp    80480d6 <do_write+0x42>

static bool
do_write (int fd, const char *buffer, int size, bool *write_error) 
{
  if (write (fd, buffer, size) == size) 
    return true;
 80480ca:	bb 01 00 00 00       	mov    $0x1,%ebx
 80480cf:	eb 05                	jmp    80480d6 <do_write+0x42>
      if (!*write_error) 
        {
          printf ("error writing archive\n");
          *write_error = true; 
        }
      return false; 
 80480d1:	bb 00 00 00 00       	mov    $0x0,%ebx
    }
}
 80480d6:	89 d8                	mov    %ebx,%eax
 80480d8:	83 c4 04             	add    $0x4,%esp
 80480db:	5b                   	pop    %ebx
 80480dc:	5e                   	pop    %esi
 80480dd:	c3                   	ret    

080480de <archive_file>:
}

static bool
archive_file (char file_name[], size_t file_name_size,
              int archive_fd, bool *write_error) 
{
 80480de:	55                   	push   %ebp
 80480df:	57                   	push   %edi
 80480e0:	56                   	push   %esi
 80480e1:	53                   	push   %ebx
 80480e2:	83 ec 38             	sub    $0x38,%esp
 80480e5:	89 d5                	mov    %edx,%ebp
 80480e7:	89 ce                	mov    %ecx,%esi
 80480e9:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  int file_fd = open (file_name);
 80480ed:	89 44 24 18          	mov    %eax,0x18(%esp)
 80480f1:	50                   	push   %eax
 80480f2:	e8 d9 28 00 00       	call   804a9d0 <open>
 80480f7:	89 44 24 24          	mov    %eax,0x24(%esp)
  if (file_fd >= 0) 
 80480fb:	83 c4 10             	add    $0x10,%esp
 80480fe:	85 c0                	test   %eax,%eax
 8048100:	0f 88 45 02 00 00    	js     804834b <archive_file+0x26d>
 8048106:	89 c7                	mov    %eax,%edi
    {
      bool success;

      if (inumber (file_fd) != inumber (archive_fd)) 
 8048108:	83 ec 0c             	sub    $0xc,%esp
 804810b:	50                   	push   %eax
 804810c:	e8 9f 29 00 00       	call   804aab0 <inumber>
 8048111:	89 c3                	mov    %eax,%ebx
 8048113:	89 34 24             	mov    %esi,(%esp)
 8048116:	e8 95 29 00 00       	call   804aab0 <inumber>
 804811b:	83 c4 10             	add    $0x10,%esp
                                         archive_fd, write_error);      
        }
      else
        {
          /* Nothing to do: don't try to archive the archive file. */
          success = true;
 804811e:	be 01 00 00 00       	mov    $0x1,%esi
  int file_fd = open (file_name);
  if (file_fd >= 0) 
    {
      bool success;

      if (inumber (file_fd) != inumber (archive_fd)) 
 8048123:	39 c3                	cmp    %eax,%ebx
 8048125:	0f 84 0d 02 00 00    	je     8048338 <archive_file+0x25a>
        {
          if (!isdir (file_fd))
 804812b:	83 ec 0c             	sub    $0xc,%esp
 804812e:	57                   	push   %edi
 804812f:	e8 6a 29 00 00       	call   804aa9e <isdir>
 8048134:	83 c4 10             	add    $0x10,%esp
 8048137:	84 c0                	test   %al,%al
 8048139:	0f 85 08 01 00 00    	jne    8048247 <archive_file+0x169>
archive_ordinary_file (const char *file_name, int file_fd,
                       int archive_fd, bool *write_error)
{
  bool read_error = false;
  bool success = true;
  int file_size = filesize (file_fd);
 804813f:	83 ec 0c             	sub    $0xc,%esp
 8048142:	57                   	push   %edi
 8048143:	e8 95 28 00 00       	call   804a9dd <filesize>
 8048148:	89 c7                	mov    %eax,%edi
static bool
write_header (const char *file_name, enum ustar_type type, int size,
              int archive_fd, bool *write_error) 
{
  static char header[512];
  return (ustar_make_header (file_name, type, size, header)
 804814a:	68 00 cc 04 08       	push   $0x804cc00
 804814f:	50                   	push   %eax
 8048150:	6a 30                	push   $0x30
 8048152:	ff 74 24 28          	pushl  0x28(%esp)
 8048156:	e8 48 24 00 00       	call   804a5a3 <ustar_make_header>
          && do_write (archive_fd, header, 512, write_error));
 804815b:	83 c4 20             	add    $0x20,%esp
  bool success = true;
  int file_size = filesize (file_fd);

  if (!write_header (file_name, USTAR_REGULAR, file_size,
                     archive_fd, write_error))
    return false;
 804815e:	be 00 00 00 00       	mov    $0x0,%esi
write_header (const char *file_name, enum ustar_type type, int size,
              int archive_fd, bool *write_error) 
{
  static char header[512];
  return (ustar_make_header (file_name, type, size, header)
          && do_write (archive_fd, header, 512, write_error));
 8048163:	84 c0                	test   %al,%al
 8048165:	0f 84 cd 01 00 00    	je     8048338 <archive_file+0x25a>
 804816b:	83 ec 0c             	sub    $0xc,%esp
 804816e:	ff 74 24 4c          	pushl  0x4c(%esp)
 8048172:	b9 00 02 00 00       	mov    $0x200,%ecx
 8048177:	ba 00 cc 04 08       	mov    $0x804cc00,%edx
 804817c:	8b 44 24 20          	mov    0x20(%esp),%eax
 8048180:	e8 0f ff ff ff       	call   8048094 <do_write>
{
  bool read_error = false;
  bool success = true;
  int file_size = filesize (file_fd);

  if (!write_header (file_name, USTAR_REGULAR, file_size,
 8048185:	83 c4 10             	add    $0x10,%esp
 8048188:	84 c0                	test   %al,%al
 804818a:	0f 84 95 01 00 00    	je     8048325 <archive_file+0x247>
                     archive_fd, write_error))
    return false;

  while (file_size > 0) 
 8048190:	85 ff                	test   %edi,%edi
 8048192:	0f 8e 94 01 00 00    	jle    804832c <archive_file+0x24e>
 8048198:	be 01 00 00 00       	mov    $0x1,%esi
 804819d:	c6 44 24 18 00       	movb   $0x0,0x18(%esp)
    {
      static char buf[512];
      int chunk_size = file_size > 512 ? 512 : file_size;
 80481a2:	81 ff 00 02 00 00    	cmp    $0x200,%edi
 80481a8:	bd 00 02 00 00       	mov    $0x200,%ebp
 80481ad:	0f 4e ef             	cmovle %edi,%ebp
      int read_retval = read (file_fd, buf, chunk_size);
 80481b0:	83 ec 04             	sub    $0x4,%esp
 80481b3:	55                   	push   %ebp
 80481b4:	68 00 ce 04 08       	push   $0x804ce00
 80481b9:	ff 74 24 20          	pushl  0x20(%esp)
 80481bd:	e8 28 28 00 00       	call   804a9ea <read>
      int bytes_read = read_retval > 0 ? read_retval : 0;
 80481c2:	83 c4 10             	add    $0x10,%esp
 80481c5:	85 c0                	test   %eax,%eax
 80481c7:	bb 00 00 00 00       	mov    $0x0,%ebx
 80481cc:	0f 49 d8             	cmovns %eax,%ebx

      if (bytes_read != chunk_size && !read_error) 
 80481cf:	39 dd                	cmp    %ebx,%ebp
 80481d1:	0f 95 c0             	setne  %al
 80481d4:	38 44 24 18          	cmp    %al,0x18(%esp)
 80481d8:	73 1e                	jae    80481f8 <archive_file+0x11a>
        {
          printf ("%s: read error\n", file_name);
 80481da:	83 ec 08             	sub    $0x8,%esp
 80481dd:	ff 74 24 14          	pushl  0x14(%esp)
 80481e1:	68 73 b4 04 08       	push   $0x804b473
 80481e6:	e8 1b 0f 00 00       	call   8049106 <printf>
 80481eb:	83 c4 10             	add    $0x10,%esp
          read_error = true;
          success = false;
 80481ee:	be 00 00 00 00       	mov    $0x0,%esi
      int bytes_read = read_retval > 0 ? read_retval : 0;

      if (bytes_read != chunk_size && !read_error) 
        {
          printf ("%s: read error\n", file_name);
          read_error = true;
 80481f3:	c6 44 24 18 01       	movb   $0x1,0x18(%esp)
          success = false;
        }

      memset (buf + bytes_read, 0, 512 - bytes_read);
 80481f8:	b8 00 02 00 00       	mov    $0x200,%eax
 80481fd:	29 d8                	sub    %ebx,%eax
 80481ff:	81 c3 00 ce 04 08    	add    $0x804ce00,%ebx
 8048205:	83 ec 04             	sub    $0x4,%esp
 8048208:	50                   	push   %eax
 8048209:	6a 00                	push   $0x0
 804820b:	53                   	push   %ebx
 804820c:	e8 9f 1d 00 00       	call   8049fb0 <memset>
      if (!do_write (archive_fd, buf, 512, write_error))
 8048211:	83 c4 04             	add    $0x4,%esp
 8048214:	ff 74 24 4c          	pushl  0x4c(%esp)
 8048218:	b9 00 02 00 00       	mov    $0x200,%ecx
 804821d:	ba 00 ce 04 08       	mov    $0x804ce00,%edx
 8048222:	8b 44 24 20          	mov    0x20(%esp),%eax
 8048226:	e8 69 fe ff ff       	call   8048094 <do_write>
 804822b:	83 c4 10             	add    $0x10,%esp
        success = false;
 804822e:	84 c0                	test   %al,%al
 8048230:	b8 00 00 00 00       	mov    $0x0,%eax
 8048235:	0f 44 f0             	cmove  %eax,%esi

      file_size -= chunk_size;
 8048238:	29 ef                	sub    %ebp,%edi

  if (!write_header (file_name, USTAR_REGULAR, file_size,
                     archive_fd, write_error))
    return false;

  while (file_size > 0) 
 804823a:	85 ff                	test   %edi,%edi
 804823c:	0f 8f 60 ff ff ff    	jg     80481a2 <archive_file+0xc4>
 8048242:	e9 f1 00 00 00       	jmp    8048338 <archive_file+0x25a>
                   int archive_fd, bool *write_error)
{
  size_t dir_len;
  bool success = true;

  dir_len = strlen (file_name);
 8048247:	b8 00 00 00 00       	mov    $0x0,%eax
 804824c:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 8048251:	8b 7c 24 0c          	mov    0xc(%esp),%edi
 8048255:	f2 ae                	repnz scas %es:(%edi),%al
 8048257:	f7 d1                	not    %ecx
 8048259:	8d 59 ff             	lea    -0x1(%ecx),%ebx
  if (dir_len + 1 + READDIR_MAX_LEN + 1 > file_name_size) 
 804825c:	83 c1 0f             	add    $0xf,%ecx
 804825f:	39 cd                	cmp    %ecx,%ebp
 8048261:	73 1e                	jae    8048281 <archive_file+0x1a3>
    {
      printf ("%s: file name too long\n", file_name);
 8048263:	83 ec 08             	sub    $0x8,%esp
 8048266:	ff 74 24 14          	pushl  0x14(%esp)
 804826a:	68 83 b4 04 08       	push   $0x804b483
 804826f:	e8 92 0e 00 00       	call   8049106 <printf>
 8048274:	83 c4 10             	add    $0x10,%esp
      return false;
 8048277:	be 00 00 00 00       	mov    $0x0,%esi
 804827c:	e9 b7 00 00 00       	jmp    8048338 <archive_file+0x25a>
static bool
write_header (const char *file_name, enum ustar_type type, int size,
              int archive_fd, bool *write_error) 
{
  static char header[512];
  return (ustar_make_header (file_name, type, size, header)
 8048281:	68 00 cc 04 08       	push   $0x804cc00
 8048286:	6a 00                	push   $0x0
 8048288:	6a 35                	push   $0x35
 804828a:	ff 74 24 18          	pushl  0x18(%esp)
 804828e:	e8 10 23 00 00       	call   804a5a3 <ustar_make_header>
          && do_write (archive_fd, header, 512, write_error));
 8048293:	83 c4 10             	add    $0x10,%esp
      printf ("%s: file name too long\n", file_name);
      return false;
    }

  if (!write_header (file_name, USTAR_DIRECTORY, 0, archive_fd, write_error))
    return false;
 8048296:	be 00 00 00 00       	mov    $0x0,%esi
write_header (const char *file_name, enum ustar_type type, int size,
              int archive_fd, bool *write_error) 
{
  static char header[512];
  return (ustar_make_header (file_name, type, size, header)
          && do_write (archive_fd, header, 512, write_error));
 804829b:	84 c0                	test   %al,%al
 804829d:	0f 84 95 00 00 00    	je     8048338 <archive_file+0x25a>
 80482a3:	83 ec 0c             	sub    $0xc,%esp
 80482a6:	ff 74 24 4c          	pushl  0x4c(%esp)
 80482aa:	b9 00 02 00 00       	mov    $0x200,%ecx
 80482af:	ba 00 cc 04 08       	mov    $0x804cc00,%edx
 80482b4:	8b 44 24 20          	mov    0x20(%esp),%eax
 80482b8:	e8 d7 fd ff ff       	call   8048094 <do_write>
    {
      printf ("%s: file name too long\n", file_name);
      return false;
    }

  if (!write_header (file_name, USTAR_DIRECTORY, 0, archive_fd, write_error))
 80482bd:	83 c4 10             	add    $0x10,%esp
 80482c0:	84 c0                	test   %al,%al
 80482c2:	74 6f                	je     8048333 <archive_file+0x255>
    return false;
      
  file_name[dir_len] = '/';
 80482c4:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
 80482c8:	89 c8                	mov    %ecx,%eax
 80482ca:	01 d8                	add    %ebx,%eax
 80482cc:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 80482d0:	c6 00 2f             	movb   $0x2f,(%eax)
static bool
archive_directory (char file_name[], size_t file_name_size, int file_fd,
                   int archive_fd, bool *write_error)
{
  size_t dir_len;
  bool success = true;
 80482d3:	be 01 00 00 00       	mov    $0x1,%esi

  if (!write_header (file_name, USTAR_DIRECTORY, 0, archive_fd, write_error))
    return false;
      
  file_name[dir_len] = '/';
  while (readdir (file_fd, &file_name[dir_len + 1])) 
 80482d8:	8d 5c 19 01          	lea    0x1(%ecx,%ebx,1),%ebx
    if (!archive_file (file_name, file_name_size, archive_fd, write_error))
      success = false;
 80482dc:	bf 00 00 00 00       	mov    $0x0,%edi
 80482e1:	89 6c 24 18          	mov    %ebp,0x18(%esp)
 80482e5:	8b 6c 24 14          	mov    0x14(%esp),%ebp
 80482e9:	eb 20                	jmp    804830b <archive_file+0x22d>
  if (!write_header (file_name, USTAR_DIRECTORY, 0, archive_fd, write_error))
    return false;
      
  file_name[dir_len] = '/';
  while (readdir (file_fd, &file_name[dir_len + 1])) 
    if (!archive_file (file_name, file_name_size, archive_fd, write_error))
 80482eb:	83 ec 0c             	sub    $0xc,%esp
 80482ee:	ff 74 24 4c          	pushl  0x4c(%esp)
 80482f2:	8b 4c 24 20          	mov    0x20(%esp),%ecx
 80482f6:	8b 54 24 28          	mov    0x28(%esp),%edx
 80482fa:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80482fe:	e8 db fd ff ff       	call   80480de <archive_file>
 8048303:	83 c4 10             	add    $0x10,%esp
      success = false;
 8048306:	84 c0                	test   %al,%al
 8048308:	0f 44 f7             	cmove  %edi,%esi

  if (!write_header (file_name, USTAR_DIRECTORY, 0, archive_fd, write_error))
    return false;
      
  file_name[dir_len] = '/';
  while (readdir (file_fd, &file_name[dir_len + 1])) 
 804830b:	83 ec 08             	sub    $0x8,%esp
 804830e:	53                   	push   %ebx
 804830f:	55                   	push   %ebp
 8048310:	e8 72 27 00 00       	call   804aa87 <readdir>
 8048315:	83 c4 10             	add    $0x10,%esp
 8048318:	84 c0                	test   %al,%al
 804831a:	75 cf                	jne    80482eb <archive_file+0x20d>
    if (!archive_file (file_name, file_name_size, archive_fd, write_error))
      success = false;
  file_name[dir_len] = '\0';
 804831c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8048320:	c6 00 00             	movb   $0x0,(%eax)
 8048323:	eb 13                	jmp    8048338 <archive_file+0x25a>
  bool success = true;
  int file_size = filesize (file_fd);

  if (!write_header (file_name, USTAR_REGULAR, file_size,
                     archive_fd, write_error))
    return false;
 8048325:	be 00 00 00 00       	mov    $0x0,%esi
 804832a:	eb 0c                	jmp    8048338 <archive_file+0x25a>

  while (file_size > 0) 
 804832c:	be 01 00 00 00       	mov    $0x1,%esi
 8048331:	eb 05                	jmp    8048338 <archive_file+0x25a>
      printf ("%s: file name too long\n", file_name);
      return false;
    }

  if (!write_header (file_name, USTAR_DIRECTORY, 0, archive_fd, write_error))
    return false;
 8048333:	be 00 00 00 00       	mov    $0x0,%esi
        {
          /* Nothing to do: don't try to archive the archive file. */
          success = true;
        }
  
      close (file_fd);
 8048338:	83 ec 0c             	sub    $0xc,%esp
 804833b:	ff 74 24 20          	pushl  0x20(%esp)
 804833f:	e8 f3 26 00 00       	call   804aa37 <close>

      return success;
 8048344:	83 c4 10             	add    $0x10,%esp
 8048347:	89 f0                	mov    %esi,%eax
 8048349:	eb 19                	jmp    8048364 <archive_file+0x286>
    }
  else
    {
      printf ("%s: open failed\n", file_name);
 804834b:	83 ec 08             	sub    $0x8,%esp
 804834e:	ff 74 24 14          	pushl  0x14(%esp)
 8048352:	68 9b b4 04 08       	push   $0x804b49b
 8048357:	e8 aa 0d 00 00       	call   8049106 <printf>
      return false;
 804835c:	83 c4 10             	add    $0x10,%esp
 804835f:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
 8048364:	83 c4 2c             	add    $0x2c,%esp
 8048367:	5b                   	pop    %ebx
 8048368:	5e                   	pop    %esi
 8048369:	5f                   	pop    %edi
 804836a:	5d                   	pop    %ebp
 804836b:	c3                   	ret    

0804836c <main>:
static bool make_tar_archive (const char *archive_name,
                              char *files[], size_t file_cnt);

int
main (int argc, char *argv[]) 
{
 804836c:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 8048370:	83 e4 f0             	and    $0xfffffff0,%esp
 8048373:	ff 71 fc             	pushl  -0x4(%ecx)
 8048376:	55                   	push   %ebp
 8048377:	89 e5                	mov    %esp,%ebp
 8048379:	57                   	push   %edi
 804837a:	56                   	push   %esi
 804837b:	53                   	push   %ebx
 804837c:	51                   	push   %ecx
 804837d:	81 ec a8 00 00 00    	sub    $0xa8,%esp
 8048383:	8b 31                	mov    (%ecx),%esi
 8048385:	8b 41 04             	mov    0x4(%ecx),%eax
 8048388:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
  if (argc < 3)
 804838e:	83 fe 02             	cmp    $0x2,%esi
 8048391:	7f 19                	jg     80483ac <main+0x40>
}

static void
usage (void) 
{
  printf ("tar, tar archive creator\n"
 8048393:	83 ec 0c             	sub    $0xc,%esp
 8048396:	68 30 b8 04 08       	push   $0x804b830
 804839b:	e8 94 27 00 00       	call   804ab34 <puts>
          "Usage: tar ARCHIVE FILE...\n"
          "where ARCHIVE is the tar archive to create\n"
          "  and FILE... is a list of files or directories to put into it.\n"
          "(ARCHIVE itself will not be included in the archive, even if it\n"
          "is in a directory to be archived.)\n");
  exit (EXIT_FAILURE);
 80483a0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 80483a7:	e8 bc 25 00 00       	call   804a968 <exit>
main (int argc, char *argv[]) 
{
  if (argc < 3)
    usage ();

  return (make_tar_archive (argv[1], argv + 2, argc - 2)
 80483ac:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
 80483b2:	8b 78 04             	mov    0x4(%eax),%edi
make_tar_archive (const char *archive_name, char *files[], size_t file_cnt) 
{
  static const char zeros[512];
  int archive_fd;
  bool success = true;
  bool write_error = false;
 80483b5:	c6 85 67 ff ff ff 00 	movb   $0x0,-0x99(%ebp)
  size_t i;
  
  if (!create (archive_name, 0)) 
 80483bc:	83 ec 08             	sub    $0x8,%esp
 80483bf:	6a 00                	push   $0x0
 80483c1:	57                   	push   %edi
 80483c2:	e8 e0 25 00 00       	call   804a9a7 <create>
 80483c7:	89 c3                	mov    %eax,%ebx
 80483c9:	83 c4 10             	add    $0x10,%esp
 80483cc:	84 c0                	test   %al,%al
 80483ce:	75 16                	jne    80483e6 <main+0x7a>
    {
      printf ("%s: create failed\n", archive_name);
 80483d0:	83 ec 08             	sub    $0x8,%esp
 80483d3:	57                   	push   %edi
 80483d4:	68 ac b4 04 08       	push   $0x804b4ac
 80483d9:	e8 28 0d 00 00       	call   8049106 <printf>
 80483de:	83 c4 10             	add    $0x10,%esp
 80483e1:	e9 0d 01 00 00       	jmp    80484f3 <main+0x187>
      return false;
    }
  archive_fd = open (archive_name);
 80483e6:	83 ec 0c             	sub    $0xc,%esp
 80483e9:	57                   	push   %edi
 80483ea:	e8 e1 25 00 00       	call   804a9d0 <open>
 80483ef:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
  if (archive_fd < 0)
 80483f5:	83 c4 10             	add    $0x10,%esp
 80483f8:	85 c0                	test   %eax,%eax
 80483fa:	78 0c                	js     8048408 <main+0x9c>
    {
      printf ("%s: open failed\n", archive_name);
      return false;
    }

  for (i = 0; i < file_cnt; i++) 
 80483fc:	83 fe 02             	cmp    $0x2,%esi
 80483ff:	75 22                	jne    8048423 <main+0xb7>
 8048401:	be 01 00 00 00       	mov    $0x1,%esi
 8048406:	eb 7f                	jmp    8048487 <main+0x11b>
      return false;
    }
  archive_fd = open (archive_name);
  if (archive_fd < 0)
    {
      printf ("%s: open failed\n", archive_name);
 8048408:	83 ec 08             	sub    $0x8,%esp
 804840b:	57                   	push   %edi
 804840c:	68 9b b4 04 08       	push   $0x804b49b
 8048411:	e8 f0 0c 00 00       	call   8049106 <printf>
 8048416:	83 c4 10             	add    $0x10,%esp
      return false;
 8048419:	bb 00 00 00 00       	mov    $0x0,%ebx
 804841e:	e9 d0 00 00 00       	jmp    80484f3 <main+0x187>
 8048423:	8d 46 fe             	lea    -0x2(%esi),%eax
 8048426:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
    }

  for (i = 0; i < file_cnt; i++) 
 804842c:	be 01 00 00 00       	mov    $0x1,%esi
 8048431:	bb 00 00 00 00       	mov    $0x0,%ebx
    {
      char file_name[128];
      
      strlcpy (file_name, files[i], sizeof file_name);
 8048436:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
 804843c:	83 ec 04             	sub    $0x4,%esp
 804843f:	68 80 00 00 00       	push   $0x80
 8048444:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
 804844a:	ff 74 98 08          	pushl  0x8(%eax,%ebx,4)
 804844e:	57                   	push   %edi
 804844f:	e8 99 1c 00 00       	call   804a0ed <strlcpy>
      if (!archive_file (file_name, sizeof file_name,
 8048454:	8d 85 67 ff ff ff    	lea    -0x99(%ebp),%eax
 804845a:	89 04 24             	mov    %eax,(%esp)
 804845d:	8b 8d 50 ff ff ff    	mov    -0xb0(%ebp),%ecx
 8048463:	ba 80 00 00 00       	mov    $0x80,%edx
 8048468:	89 f8                	mov    %edi,%eax
 804846a:	e8 6f fc ff ff       	call   80480de <archive_file>
 804846f:	83 c4 10             	add    $0x10,%esp
 8048472:	84 c0                	test   %al,%al
                         archive_fd, &write_error))
        success = false;
 8048474:	b8 00 00 00 00       	mov    $0x0,%eax
 8048479:	0f 44 f0             	cmove  %eax,%esi
    {
      printf ("%s: open failed\n", archive_name);
      return false;
    }

  for (i = 0; i < file_cnt; i++) 
 804847c:	83 c3 01             	add    $0x1,%ebx
 804847f:	39 9d 4c ff ff ff    	cmp    %ebx,-0xb4(%ebp)
 8048485:	75 b5                	jne    804843c <main+0xd0>
      if (!archive_file (file_name, sizeof file_name,
                         archive_fd, &write_error))
        success = false;
    }

  if (!do_write (archive_fd, zeros, 512, &write_error)
 8048487:	83 ec 0c             	sub    $0xc,%esp
 804848a:	8d 85 67 ff ff ff    	lea    -0x99(%ebp),%eax
 8048490:	50                   	push   %eax
 8048491:	b9 00 02 00 00       	mov    $0x200,%ecx
 8048496:	ba 00 d0 04 08       	mov    $0x804d000,%edx
 804849b:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
 80484a1:	e8 ee fb ff ff       	call   8048094 <do_write>
 80484a6:	83 c4 10             	add    $0x10,%esp
 80484a9:	84 c0                	test   %al,%al
 80484ab:	74 2e                	je     80484db <main+0x16f>
      || !do_write (archive_fd, zeros, 512, &write_error)) 
 80484ad:	83 ec 0c             	sub    $0xc,%esp
 80484b0:	8d 85 67 ff ff ff    	lea    -0x99(%ebp),%eax
 80484b6:	50                   	push   %eax
 80484b7:	b9 00 02 00 00       	mov    $0x200,%ecx
 80484bc:	ba 00 d0 04 08       	mov    $0x804d000,%edx
 80484c1:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
 80484c7:	e8 c8 fb ff ff       	call   8048094 <do_write>
 80484cc:	83 c4 10             	add    $0x10,%esp
 80484cf:	84 c0                	test   %al,%al
    success = false;
 80484d1:	b8 00 00 00 00       	mov    $0x0,%eax
 80484d6:	0f 44 f0             	cmove  %eax,%esi
 80484d9:	eb 05                	jmp    80484e0 <main+0x174>
 80484db:	be 00 00 00 00       	mov    $0x0,%esi

  close (archive_fd);
 80484e0:	83 ec 0c             	sub    $0xc,%esp
 80484e3:	ff b5 50 ff ff ff    	pushl  -0xb0(%ebp)
 80484e9:	e8 49 25 00 00       	call   804aa37 <close>
 80484ee:	83 c4 10             	add    $0x10,%esp

  return success;
 80484f1:	89 f3                	mov    %esi,%ebx
 80484f3:	83 f3 01             	xor    $0x1,%ebx
 80484f6:	0f b6 c3             	movzbl %bl,%eax
  if (argc < 3)
    usage ();

  return (make_tar_archive (argv[1], argv + 2, argc - 2)
          ? EXIT_SUCCESS : EXIT_FAILURE);
}
 80484f9:	8d 65 f0             	lea    -0x10(%ebp),%esp
 80484fc:	59                   	pop    %ecx
 80484fd:	5b                   	pop    %ebx
 80484fe:	5e                   	pop    %esi
 80484ff:	5f                   	pop    %edi
 8048500:	5d                   	pop    %ebp
 8048501:	8d 61 fc             	lea    -0x4(%ecx),%esp
 8048504:	c3                   	ret    

08048505 <vmsg>:
const char *test_name;
bool quiet = false;

static void
vmsg (const char *format, va_list args, const char *suffix) 
{
 8048505:	55                   	push   %ebp
 8048506:	57                   	push   %edi
 8048507:	56                   	push   %esi
 8048508:	53                   	push   %ebx
 8048509:	83 ec 1c             	sub    $0x1c,%esp
 804850c:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048510:	89 d5                	mov    %edx,%ebp
 8048512:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
     that'll (typically) ensure that it gets sent to the console
     atomically.  Otherwise kernel messages like "foo: exit(0)"
     can end up being interleaved if we're unlucky. */
  static char buf[1024];

  snprintf (buf, sizeof buf, "(%s) ", test_name);
 8048516:	ff 35 44 d7 04 08    	pushl  0x804d744
 804851c:	68 bf b4 04 08       	push   $0x804b4bf
 8048521:	68 00 04 00 00       	push   $0x400
 8048526:	68 20 d2 04 08       	push   $0x804d220
 804852b:	e8 e3 12 00 00       	call   8049813 <snprintf>
  vsnprintf (buf + strlen (buf), sizeof buf - strlen (buf), format, args);
 8048530:	be ff ff ff ff       	mov    $0xffffffff,%esi
 8048535:	bf 20 d2 04 08       	mov    $0x804d220,%edi
 804853a:	bb 00 00 00 00       	mov    $0x0,%ebx
 804853f:	89 f1                	mov    %esi,%ecx
 8048541:	89 d8                	mov    %ebx,%eax
 8048543:	f2 ae                	repnz scas %es:(%edi),%al
 8048545:	f7 d1                	not    %ecx
 8048547:	83 e9 01             	sub    $0x1,%ecx
 804854a:	55                   	push   %ebp
 804854b:	ff 74 24 1c          	pushl  0x1c(%esp)
 804854f:	bd 00 04 00 00       	mov    $0x400,%ebp
 8048554:	89 e8                	mov    %ebp,%eax
 8048556:	29 c8                	sub    %ecx,%eax
 8048558:	50                   	push   %eax
 8048559:	81 c1 20 d2 04 08    	add    $0x804d220,%ecx
 804855f:	51                   	push   %ecx
 8048560:	e8 41 12 00 00       	call   80497a6 <vsnprintf>
  strlcpy (buf + strlen (buf), suffix, sizeof buf - strlen (buf));
 8048565:	bf 20 d2 04 08       	mov    $0x804d220,%edi
 804856a:	89 f1                	mov    %esi,%ecx
 804856c:	89 d8                	mov    %ebx,%eax
 804856e:	f2 ae                	repnz scas %es:(%edi),%al
 8048570:	f7 d1                	not    %ecx
 8048572:	83 e9 01             	sub    $0x1,%ecx
 8048575:	83 c4 1c             	add    $0x1c,%esp
 8048578:	29 cd                	sub    %ecx,%ebp
 804857a:	55                   	push   %ebp
 804857b:	ff 74 24 14          	pushl  0x14(%esp)
 804857f:	81 c1 20 d2 04 08    	add    $0x804d220,%ecx
 8048585:	51                   	push   %ecx
 8048586:	e8 62 1b 00 00       	call   804a0ed <strlcpy>
  write (STDOUT_FILENO, buf, strlen (buf));
 804858b:	bf 20 d2 04 08       	mov    $0x804d220,%edi
 8048590:	89 f1                	mov    %esi,%ecx
 8048592:	89 d8                	mov    %ebx,%eax
 8048594:	f2 ae                	repnz scas %es:(%edi),%al
 8048596:	f7 d1                	not    %ecx
 8048598:	83 e9 01             	sub    $0x1,%ecx
 804859b:	83 c4 0c             	add    $0xc,%esp
 804859e:	51                   	push   %ecx
 804859f:	68 20 d2 04 08       	push   $0x804d220
 80485a4:	6a 01                	push   $0x1
 80485a6:	e8 56 24 00 00       	call   804aa01 <write>
}
 80485ab:	83 c4 2c             	add    $0x2c,%esp
 80485ae:	5b                   	pop    %ebx
 80485af:	5e                   	pop    %esi
 80485b0:	5f                   	pop    %edi
 80485b1:	5d                   	pop    %ebp
 80485b2:	c3                   	ret    

080485b3 <msg>:
void
msg (const char *format, ...) 
{
  va_list args;

  if (quiet)
 80485b3:	80 3d 00 d2 04 08 00 	cmpb   $0x0,0x804d200
 80485ba:	75 18                	jne    80485d4 <msg+0x21>
  write (STDOUT_FILENO, buf, strlen (buf));
}

void
msg (const char *format, ...) 
{
 80485bc:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  if (quiet)
    return;
  va_start (args, format);
  vmsg (format, args, "\n");
 80485bf:	b9 cd b4 04 08       	mov    $0x804b4cd,%ecx
 80485c4:	8d 54 24 14          	lea    0x14(%esp),%edx
 80485c8:	8b 44 24 10          	mov    0x10(%esp),%eax
 80485cc:	e8 34 ff ff ff       	call   8048505 <vmsg>
  va_end (args);
}
 80485d1:	83 c4 0c             	add    $0xc,%esp
 80485d4:	f3 c3                	repz ret 

080485d6 <fail>:

void
fail (const char *format, ...) 
{
 80485d6:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  va_start (args, format);
  vmsg (format, args, ": FAILED\n");
 80485d9:	b9 c5 b4 04 08       	mov    $0x804b4c5,%ecx
 80485de:	8d 54 24 14          	lea    0x14(%esp),%edx
 80485e2:	8b 44 24 10          	mov    0x10(%esp),%eax
 80485e6:	e8 1a ff ff ff       	call   8048505 <vmsg>
  va_end (args);

  exit (1);
 80485eb:	83 ec 0c             	sub    $0xc,%esp
 80485ee:	6a 01                	push   $0x1
 80485f0:	e8 73 23 00 00       	call   804a968 <exit>

080485f5 <shuffle>:
    }
}

void
shuffle (void *buf_, size_t cnt, size_t size) 
{
 80485f5:	55                   	push   %ebp
 80485f6:	57                   	push   %edi
 80485f7:	56                   	push   %esi
 80485f8:	53                   	push   %ebx
 80485f9:	83 ec 1c             	sub    $0x1c,%esp
 80485fc:	8b 44 24 34          	mov    0x34(%esp),%eax
  char *buf = buf_;
  size_t i;

  for (i = 0; i < cnt; i++)
 8048600:	85 c0                	test   %eax,%eax
 8048602:	74 71                	je     8048675 <shuffle+0x80>
 8048604:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048608:	be 00 00 00 00       	mov    $0x0,%esi
 804860d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 8048614:	00 
    {
      size_t j = i + random_ulong () % (cnt - i);
 8048615:	e8 00 07 00 00       	call   8048d1a <random_ulong>
      swap (buf + i * size, buf + j * size, size);
 804861a:	ba 00 00 00 00       	mov    $0x0,%edx
 804861f:	f7 74 24 0c          	divl   0xc(%esp)
 8048623:	03 54 24 08          	add    0x8(%esp),%edx
 8048627:	0f af 54 24 38       	imul   0x38(%esp),%edx
 804862c:	89 f5                	mov    %esi,%ebp
{
  uint8_t *a = a_;
  uint8_t *b = b_;
  size_t i;

  for (i = 0; i < size; i++) 
 804862e:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
 8048633:	74 30                	je     8048665 <shuffle+0x70>
 8048635:	89 f1                	mov    %esi,%ecx
 8048637:	03 4c 24 30          	add    0x30(%esp),%ecx
 804863b:	89 f7                	mov    %esi,%edi
 804863d:	03 7c 24 38          	add    0x38(%esp),%edi
 8048641:	03 7c 24 30          	add    0x30(%esp),%edi
    {
      uint8_t t = a[i];
 8048645:	0f b6 19             	movzbl (%ecx),%ebx
 8048648:	88 5c 24 07          	mov    %bl,0x7(%esp)
 804864c:	89 c8                	mov    %ecx,%eax
 804864e:	29 e8                	sub    %ebp,%eax
      a[i] = b[i];
 8048650:	0f b6 1c 10          	movzbl (%eax,%edx,1),%ebx
 8048654:	88 19                	mov    %bl,(%ecx)
      b[i] = t;
 8048656:	0f b6 5c 24 07       	movzbl 0x7(%esp),%ebx
 804865b:	88 1c 10             	mov    %bl,(%eax,%edx,1)
 804865e:	83 c1 01             	add    $0x1,%ecx
{
  uint8_t *a = a_;
  uint8_t *b = b_;
  size_t i;

  for (i = 0; i < size; i++) 
 8048661:	39 f9                	cmp    %edi,%ecx
 8048663:	75 e0                	jne    8048645 <shuffle+0x50>
shuffle (void *buf_, size_t cnt, size_t size) 
{
  char *buf = buf_;
  size_t i;

  for (i = 0; i < cnt; i++)
 8048665:	83 44 24 08 01       	addl   $0x1,0x8(%esp)
 804866a:	03 74 24 38          	add    0x38(%esp),%esi
 804866e:	83 6c 24 0c 01       	subl   $0x1,0xc(%esp)
 8048673:	75 a0                	jne    8048615 <shuffle+0x20>
    {
      size_t j = i + random_ulong () % (cnt - i);
      swap (buf + i * size, buf + j * size, size);
    }
}
 8048675:	83 c4 1c             	add    $0x1c,%esp
 8048678:	5b                   	pop    %ebx
 8048679:	5e                   	pop    %esi
 804867a:	5f                   	pop    %edi
 804867b:	5d                   	pop    %ebp
 804867c:	c3                   	ret    

0804867d <exec_children>:

void
exec_children (const char *child_name, pid_t pids[], size_t child_cnt) 
{
 804867d:	55                   	push   %ebp
 804867e:	57                   	push   %edi
 804867f:	56                   	push   %esi
 8048680:	53                   	push   %ebx
 8048681:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
 8048687:	8b ac 24 a4 00 00 00 	mov    0xa4(%esp),%ebp
 804868e:	8b bc 24 a8 00 00 00 	mov    0xa8(%esp),%edi
  size_t i;

  for (i = 0; i < child_cnt; i++) 
 8048695:	85 ff                	test   %edi,%edi
 8048697:	74 5a                	je     80486f3 <exec_children+0x76>
 8048699:	bb 00 00 00 00       	mov    $0x0,%ebx
    {
      char cmd_line[128];
      snprintf (cmd_line, sizeof cmd_line, "%s %zu", child_name, i);
 804869e:	89 e6                	mov    %esp,%esi
 80486a0:	83 ec 0c             	sub    $0xc,%esp
 80486a3:	53                   	push   %ebx
 80486a4:	ff b4 24 b0 00 00 00 	pushl  0xb0(%esp)
 80486ab:	68 cf b4 04 08       	push   $0x804b4cf
 80486b0:	68 80 00 00 00       	push   $0x80
 80486b5:	56                   	push   %esi
 80486b6:	e8 58 11 00 00       	call   8049813 <snprintf>
      CHECK ((pids[i] = exec (cmd_line)) != PID_ERROR,
 80486bb:	83 c3 01             	add    $0x1,%ebx
 80486be:	83 c4 20             	add    $0x20,%esp
 80486c1:	56                   	push   %esi
 80486c2:	57                   	push   %edi
 80486c3:	53                   	push   %ebx
 80486c4:	68 d6 b4 04 08       	push   $0x804b4d6
 80486c9:	e8 e5 fe ff ff       	call   80485b3 <msg>
 80486ce:	89 34 24             	mov    %esi,(%esp)
 80486d1:	e8 b7 22 00 00       	call   804a98d <exec>
 80486d6:	89 44 9d fc          	mov    %eax,-0x4(%ebp,%ebx,4)
 80486da:	83 c4 10             	add    $0x10,%esp
 80486dd:	83 f8 ff             	cmp    $0xffffffff,%eax
 80486e0:	75 0d                	jne    80486ef <exec_children+0x72>
 80486e2:	54                   	push   %esp
 80486e3:	57                   	push   %edi
 80486e4:	53                   	push   %ebx
 80486e5:	68 d6 b4 04 08       	push   $0x804b4d6
 80486ea:	e8 e7 fe ff ff       	call   80485d6 <fail>
void
exec_children (const char *child_name, pid_t pids[], size_t child_cnt) 
{
  size_t i;

  for (i = 0; i < child_cnt; i++) 
 80486ef:	39 df                	cmp    %ebx,%edi
 80486f1:	75 ad                	jne    80486a0 <exec_children+0x23>
      char cmd_line[128];
      snprintf (cmd_line, sizeof cmd_line, "%s %zu", child_name, i);
      CHECK ((pids[i] = exec (cmd_line)) != PID_ERROR,
             "exec child %zu of %zu: \"%s\"", i + 1, child_cnt, cmd_line);
    }
}
 80486f3:	81 c4 8c 00 00 00    	add    $0x8c,%esp
 80486f9:	5b                   	pop    %ebx
 80486fa:	5e                   	pop    %esi
 80486fb:	5f                   	pop    %edi
 80486fc:	5d                   	pop    %ebp
 80486fd:	c3                   	ret    

080486fe <wait_children>:

void
wait_children (pid_t pids[], size_t child_cnt) 
{
 80486fe:	55                   	push   %ebp
 80486ff:	57                   	push   %edi
 8048700:	56                   	push   %esi
 8048701:	53                   	push   %ebx
 8048702:	83 ec 0c             	sub    $0xc,%esp
 8048705:	8b 6c 24 24          	mov    0x24(%esp),%ebp
  size_t i;
  
  for (i = 0; i < child_cnt; i++) 
 8048709:	85 ed                	test   %ebp,%ebp
 804870b:	74 47                	je     8048754 <wait_children+0x56>
 804870d:	bb 00 00 00 00       	mov    $0x0,%ebx
    {
      int status = wait (pids[i]);
 8048712:	83 ec 0c             	sub    $0xc,%esp
 8048715:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 8048719:	ff 34 98             	pushl  (%eax,%ebx,4)
 804871c:	e8 79 22 00 00       	call   804a99a <wait>
 8048721:	89 c7                	mov    %eax,%edi
      CHECK (status == (int) i,
 8048723:	8d 73 01             	lea    0x1(%ebx),%esi
 8048726:	89 1c 24             	mov    %ebx,(%esp)
 8048729:	50                   	push   %eax
 804872a:	55                   	push   %ebp
 804872b:	56                   	push   %esi
 804872c:	68 34 b9 04 08       	push   $0x804b934
 8048731:	e8 7d fe ff ff       	call   80485b3 <msg>
 8048736:	83 c4 20             	add    $0x20,%esp
 8048739:	39 df                	cmp    %ebx,%edi
 804873b:	74 11                	je     804874e <wait_children+0x50>
 804873d:	83 ec 0c             	sub    $0xc,%esp
 8048740:	53                   	push   %ebx
 8048741:	57                   	push   %edi
 8048742:	55                   	push   %ebp
 8048743:	56                   	push   %esi
 8048744:	68 34 b9 04 08       	push   $0x804b934
 8048749:	e8 88 fe ff ff       	call   80485d6 <fail>
 804874e:	89 f3                	mov    %esi,%ebx
void
wait_children (pid_t pids[], size_t child_cnt) 
{
  size_t i;
  
  for (i = 0; i < child_cnt; i++) 
 8048750:	39 f5                	cmp    %esi,%ebp
 8048752:	75 be                	jne    8048712 <wait_children+0x14>
      int status = wait (pids[i]);
      CHECK (status == (int) i,
             "wait for child %zu of %zu returned %d (expected %zu)",
             i + 1, child_cnt, status, i);
    }
}
 8048754:	83 c4 0c             	add    $0xc,%esp
 8048757:	5b                   	pop    %ebx
 8048758:	5e                   	pop    %esi
 8048759:	5f                   	pop    %edi
 804875a:	5d                   	pop    %ebp
 804875b:	c3                   	ret    

0804875c <compare_bytes>:
}

void
compare_bytes (const void *read_data_, const void *expected_data_, size_t size,
               size_t ofs, const char *file_name) 
{
 804875c:	55                   	push   %ebp
 804875d:	57                   	push   %edi
 804875e:	56                   	push   %esi
 804875f:	53                   	push   %ebx
 8048760:	83 ec 20             	sub    $0x20,%esp
 8048763:	8b 5c 24 34          	mov    0x34(%esp),%ebx
 8048767:	8b 74 24 38          	mov    0x38(%esp),%esi
 804876b:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
  const uint8_t *read_data = read_data_;
  const uint8_t *expected_data = expected_data_;
  size_t i, j;
  size_t show_cnt;

  if (!memcmp (read_data, expected_data, size))
 804876f:	57                   	push   %edi
 8048770:	56                   	push   %esi
 8048771:	53                   	push   %ebx
 8048772:	e8 51 14 00 00       	call   8049bc8 <memcmp>
 8048777:	83 c4 10             	add    $0x10,%esp
 804877a:	85 c0                	test   %eax,%eax
 804877c:	0f 84 bf 01 00 00    	je     8048941 <compare_bytes+0x1e5>
    return;
  
  for (i = 0; i < size; i++)
 8048782:	85 ff                	test   %edi,%edi
 8048784:	0f 84 7e 01 00 00    	je     8048908 <compare_bytes+0x1ac>
    if (read_data[i] != expected_data[i])
 804878a:	0f b6 06             	movzbl (%esi),%eax
 804878d:	38 03                	cmp    %al,(%ebx)
 804878f:	0f 85 18 01 00 00    	jne    80488ad <compare_bytes+0x151>
 8048795:	ba 00 00 00 00       	mov    $0x0,%edx
 804879a:	eb 0d                	jmp    80487a9 <compare_bytes+0x4d>
 804879c:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
 80487a1:	38 44 13 01          	cmp    %al,0x1(%ebx,%edx,1)
 80487a5:	75 0b                	jne    80487b2 <compare_bytes+0x56>
  size_t show_cnt;

  if (!memcmp (read_data, expected_data, size))
    return;
  
  for (i = 0; i < size; i++)
 80487a7:	89 ea                	mov    %ebp,%edx
 80487a9:	8d 6a 01             	lea    0x1(%edx),%ebp
 80487ac:	39 ef                	cmp    %ebp,%edi
 80487ae:	75 ec                	jne    804879c <compare_bytes+0x40>
 80487b0:	89 fd                	mov    %edi,%ebp
    if (read_data[i] != expected_data[i])
      break;
  for (j = i + 1; j < size; j++)
 80487b2:	8d 42 02             	lea    0x2(%edx),%eax
 80487b5:	39 c7                	cmp    %eax,%edi
 80487b7:	76 1d                	jbe    80487d6 <compare_bytes+0x7a>
    if (read_data[j] == expected_data[j])
 80487b9:	0f b6 4c 16 02       	movzbl 0x2(%esi,%edx,1),%ecx
 80487be:	38 4c 13 02          	cmp    %cl,0x2(%ebx,%edx,1)
 80487c2:	75 0b                	jne    80487cf <compare_bytes+0x73>
 80487c4:	eb 10                	jmp    80487d6 <compare_bytes+0x7a>
 80487c6:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
 80487ca:	38 0c 03             	cmp    %cl,(%ebx,%eax,1)
 80487cd:	74 07                	je     80487d6 <compare_bytes+0x7a>
    return;
  
  for (i = 0; i < size; i++)
    if (read_data[i] != expected_data[i])
      break;
  for (j = i + 1; j < size; j++)
 80487cf:	83 c0 01             	add    $0x1,%eax
 80487d2:	39 c7                	cmp    %eax,%edi
 80487d4:	77 f0                	ja     80487c6 <compare_bytes+0x6a>
    if (read_data[j] == expected_data[j])
      break;

  quiet = false;
 80487d6:	c6 05 00 d2 04 08 00 	movb   $0x0,0x804d200
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
 80487dd:	89 ef                	mov    %ebp,%edi
 80487df:	03 7c 24 3c          	add    0x3c(%esp),%edi
 80487e3:	29 e8                	sub    %ebp,%eax
 80487e5:	ff 74 24 40          	pushl  0x40(%esp)
 80487e9:	57                   	push   %edi
 80487ea:	89 44 24 14          	mov    %eax,0x14(%esp)
 80487ee:	50                   	push   %eax
 80487ef:	68 6c b9 04 08       	push   $0x804b96c
 80487f4:	e8 ba fd ff ff       	call   80485b3 <msg>
       "from expected.", j - i, ofs + i, file_name);
  show_cnt = j - i;
  if (j - i > 64) 
 80487f9:	83 c4 10             	add    $0x10,%esp
  for (j = i + 1; j < size; j++)
    if (read_data[j] == expected_data[j])
      break;

  quiet = false;
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
 80487fc:	8b 44 24 0c          	mov    0xc(%esp),%eax
 8048800:	89 44 24 08          	mov    %eax,0x8(%esp)
       "from expected.", j - i, ofs + i, file_name);
  show_cnt = j - i;
  if (j - i > 64) 
 8048804:	83 f8 40             	cmp    $0x40,%eax
 8048807:	76 1a                	jbe    8048823 <compare_bytes+0xc7>
    {
      show_cnt = 64;
      msg ("Showing first differing %zu bytes.", show_cnt);
 8048809:	83 ec 08             	sub    $0x8,%esp
 804880c:	6a 40                	push   $0x40
 804880e:	68 b0 b9 04 08       	push   $0x804b9b0
 8048813:	e8 9b fd ff ff       	call   80485b3 <msg>
 8048818:	83 c4 10             	add    $0x10,%esp
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
       "from expected.", j - i, ofs + i, file_name);
  show_cnt = j - i;
  if (j - i > 64) 
    {
      show_cnt = 64;
 804881b:	c7 44 24 08 40 00 00 	movl   $0x40,0x8(%esp)
 8048822:	00 
      msg ("Showing first differing %zu bytes.", show_cnt);
    }
  msg ("Data actually read:");
 8048823:	83 ec 0c             	sub    $0xc,%esp
 8048826:	68 f2 b4 04 08       	push   $0x804b4f2
 804882b:	e8 83 fd ff ff       	call   80485b3 <msg>
  hex_dump (ofs + i, read_data + i, show_cnt, true);
 8048830:	6a 01                	push   $0x1
 8048832:	ff 74 24 1c          	pushl  0x1c(%esp)
 8048836:	01 eb                	add    %ebp,%ebx
 8048838:	53                   	push   %ebx
 8048839:	57                   	push   %edi
 804883a:	e8 f1 0f 00 00       	call   8049830 <hex_dump>
  msg ("Expected data:");
 804883f:	83 c4 14             	add    $0x14,%esp
 8048842:	68 06 b5 04 08       	push   $0x804b506
 8048847:	e8 67 fd ff ff       	call   80485b3 <msg>
  hex_dump (ofs + i, expected_data + i, show_cnt, true);
 804884c:	6a 01                	push   $0x1
 804884e:	ff 74 24 1c          	pushl  0x1c(%esp)
 8048852:	01 ee                	add    %ebp,%esi
 8048854:	56                   	push   %esi
 8048855:	57                   	push   %edi
 8048856:	e8 d5 0f 00 00       	call   8049830 <hex_dump>
  fail ("%zu bytes read starting at offset %zu in \"%s\" differ "
 804885b:	83 c4 20             	add    $0x20,%esp
 804885e:	ff 74 24 40          	pushl  0x40(%esp)
 8048862:	57                   	push   %edi
 8048863:	ff 74 24 14          	pushl  0x14(%esp)
 8048867:	68 d4 b9 04 08       	push   $0x804b9d4
 804886c:	e8 65 fd ff ff       	call   80485d6 <fail>
      break;
  for (j = i + 1; j < size; j++)
    if (read_data[j] == expected_data[j])
      break;

  quiet = false;
 8048871:	c6 05 00 d2 04 08 00 	movb   $0x0,0x804d200
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
 8048878:	ff 74 24 40          	pushl  0x40(%esp)
 804887c:	ff 74 24 40          	pushl  0x40(%esp)
 8048880:	6a 01                	push   $0x1
 8048882:	68 6c b9 04 08       	push   $0x804b96c
 8048887:	e8 27 fd ff ff       	call   80485b3 <msg>
 804888c:	83 c4 10             	add    $0x10,%esp
 804888f:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
 8048893:	bd 00 00 00 00       	mov    $0x0,%ebp
 8048898:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 804889f:	00 
 80488a0:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 80488a7:	00 
 80488a8:	e9 76 ff ff ff       	jmp    8048823 <compare_bytes+0xc7>
    return;
  
  for (i = 0; i < size; i++)
    if (read_data[i] != expected_data[i])
      break;
  for (j = i + 1; j < size; j++)
 80488ad:	83 ff 01             	cmp    $0x1,%edi
 80488b0:	77 3e                	ja     80488f0 <compare_bytes+0x194>
 80488b2:	eb bd                	jmp    8048871 <compare_bytes+0x115>
    if (read_data[j] == expected_data[j])
      break;

  quiet = false;
 80488b4:	c6 05 00 d2 04 08 00 	movb   $0x0,0x804d200
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
 80488bb:	ff 74 24 40          	pushl  0x40(%esp)
 80488bf:	ff 74 24 40          	pushl  0x40(%esp)
 80488c3:	6a 01                	push   $0x1
 80488c5:	68 6c b9 04 08       	push   $0x804b96c
 80488ca:	e8 e4 fc ff ff       	call   80485b3 <msg>
 80488cf:	83 c4 10             	add    $0x10,%esp
 80488d2:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
 80488d6:	bd 00 00 00 00       	mov    $0x0,%ebp
 80488db:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 80488e2:	00 
 80488e3:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 80488ea:	00 
 80488eb:	e9 33 ff ff ff       	jmp    8048823 <compare_bytes+0xc7>
  
  for (i = 0; i < size; i++)
    if (read_data[i] != expected_data[i])
      break;
  for (j = i + 1; j < size; j++)
    if (read_data[j] == expected_data[j])
 80488f0:	0f b6 46 01          	movzbl 0x1(%esi),%eax
 80488f4:	38 43 01             	cmp    %al,0x1(%ebx)
 80488f7:	74 bb                	je     80488b4 <compare_bytes+0x158>
 80488f9:	bd 00 00 00 00       	mov    $0x0,%ebp
    return;
  
  for (i = 0; i < size; i++)
    if (read_data[i] != expected_data[i])
      break;
  for (j = i + 1; j < size; j++)
 80488fe:	b8 01 00 00 00       	mov    $0x1,%eax
 8048903:	e9 c7 fe ff ff       	jmp    80487cf <compare_bytes+0x73>
    if (read_data[j] == expected_data[j])
      break;

  quiet = false;
 8048908:	c6 05 00 d2 04 08 00 	movb   $0x0,0x804d200
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
 804890f:	ff 74 24 40          	pushl  0x40(%esp)
 8048913:	ff 74 24 40          	pushl  0x40(%esp)
 8048917:	6a 01                	push   $0x1
 8048919:	68 6c b9 04 08       	push   $0x804b96c
 804891e:	e8 90 fc ff ff       	call   80485b3 <msg>
 8048923:	83 c4 10             	add    $0x10,%esp
 8048926:	89 fd                	mov    %edi,%ebp
 8048928:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
 804892c:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 8048933:	00 
 8048934:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 804893b:	00 
 804893c:	e9 e2 fe ff ff       	jmp    8048823 <compare_bytes+0xc7>
  hex_dump (ofs + i, read_data + i, show_cnt, true);
  msg ("Expected data:");
  hex_dump (ofs + i, expected_data + i, show_cnt, true);
  fail ("%zu bytes read starting at offset %zu in \"%s\" differ "
        "from expected", j - i, ofs + i, file_name);
}
 8048941:	83 c4 1c             	add    $0x1c,%esp
 8048944:	5b                   	pop    %ebx
 8048945:	5e                   	pop    %esi
 8048946:	5f                   	pop    %edi
 8048947:	5d                   	pop    %ebp
 8048948:	c3                   	ret    

08048949 <check_file_handle>:
}

void
check_file_handle (int fd,
                   const char *file_name, const void *buf_, size_t size) 
{
 8048949:	55                   	push   %ebp
 804894a:	57                   	push   %edi
 804894b:	56                   	push   %esi
 804894c:	53                   	push   %ebx
 804894d:	81 ec 28 02 00 00    	sub    $0x228,%esp
 8048953:	8b bc 24 48 02 00 00 	mov    0x248(%esp),%edi
  size_t file_size;

  /* Warn about file of wrong size.  Don't fail yet because we
     may still be able to get more information by reading the
     file. */
  file_size = filesize (fd);
 804895a:	ff b4 24 3c 02 00 00 	pushl  0x23c(%esp)
 8048961:	e8 77 20 00 00       	call   804a9dd <filesize>
 8048966:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  if (file_size != size)
 804896a:	83 c4 10             	add    $0x10,%esp
 804896d:	39 f8                	cmp    %edi,%eax
 804896f:	0f 84 be 00 00 00    	je     8048a33 <check_file_handle+0xea>
    msg ("size of %s (%zu) differs from expected (%zu)",
 8048975:	57                   	push   %edi
 8048976:	50                   	push   %eax
 8048977:	ff b4 24 3c 02 00 00 	pushl  0x23c(%esp)
 804897e:	68 18 ba 04 08       	push   $0x804ba18
 8048983:	e8 2b fc ff ff       	call   80485b3 <msg>
          file_name, file_size, size);

  /* Read the file block-by-block, comparing data as we go. */
  while (ofs < size)
 8048988:	83 c4 10             	add    $0x10,%esp
 804898b:	85 ff                	test   %edi,%edi
 804898d:	74 75                	je     8048a04 <check_file_handle+0xbb>
}

void
check_file_handle (int fd,
                   const char *file_name, const void *buf_, size_t size) 
{
 804898f:	be 00 00 00 00       	mov    $0x0,%esi

      block_size = size - ofs;
      if (block_size > sizeof block)
        block_size = sizeof block;

      ret_val = read (fd, block, block_size);
 8048994:	8d 6c 24 10          	lea    0x10(%esp),%ebp
  while (ofs < size)
    {
      char block[512];
      size_t block_size, ret_val;

      block_size = size - ofs;
 8048998:	89 fb                	mov    %edi,%ebx
 804899a:	29 f3                	sub    %esi,%ebx
 804899c:	81 fb 00 02 00 00    	cmp    $0x200,%ebx
 80489a2:	b8 00 02 00 00       	mov    $0x200,%eax
 80489a7:	0f 47 d8             	cmova  %eax,%ebx
      if (block_size > sizeof block)
        block_size = sizeof block;

      ret_val = read (fd, block, block_size);
 80489aa:	83 ec 04             	sub    $0x4,%esp
 80489ad:	53                   	push   %ebx
 80489ae:	55                   	push   %ebp
 80489af:	ff b4 24 3c 02 00 00 	pushl  0x23c(%esp)
 80489b6:	e8 2f 20 00 00       	call   804a9ea <read>
      if (ret_val != block_size)
 80489bb:	83 c4 10             	add    $0x10,%esp
 80489be:	39 c3                	cmp    %eax,%ebx
 80489c0:	74 17                	je     80489d9 <check_file_handle+0x90>
        fail ("read of %zu bytes at offset %zu in \"%s\" returned %zu",
 80489c2:	83 ec 0c             	sub    $0xc,%esp
 80489c5:	50                   	push   %eax
 80489c6:	ff b4 24 44 02 00 00 	pushl  0x244(%esp)
 80489cd:	56                   	push   %esi
 80489ce:	53                   	push   %ebx
 80489cf:	68 48 ba 04 08       	push   $0x804ba48
 80489d4:	e8 fd fb ff ff       	call   80485d6 <fail>
              block_size, ofs, file_name, ret_val);

      compare_bytes (block, buf + ofs, block_size, ofs, file_name);
 80489d9:	83 ec 0c             	sub    $0xc,%esp
 80489dc:	ff b4 24 40 02 00 00 	pushl  0x240(%esp)
 80489e3:	56                   	push   %esi
 80489e4:	53                   	push   %ebx
 80489e5:	89 f0                	mov    %esi,%eax
 80489e7:	03 84 24 50 02 00 00 	add    0x250(%esp),%eax
 80489ee:	50                   	push   %eax
 80489ef:	55                   	push   %ebp
 80489f0:	e8 67 fd ff ff       	call   804875c <compare_bytes>
      ofs += block_size;
 80489f5:	01 de                	add    %ebx,%esi
  if (file_size != size)
    msg ("size of %s (%zu) differs from expected (%zu)",
          file_name, file_size, size);

  /* Read the file block-by-block, comparing data as we go. */
  while (ofs < size)
 80489f7:	83 c4 20             	add    $0x20,%esp
 80489fa:	39 f7                	cmp    %esi,%edi
 80489fc:	77 9a                	ja     8048998 <check_file_handle+0x4f>
      compare_bytes (block, buf + ofs, block_size, ofs, file_name);
      ofs += block_size;
    }

  /* Now fail due to wrong file size. */
  if (file_size != size)
 80489fe:	39 7c 24 0c          	cmp    %edi,0xc(%esp)
 8048a02:	74 16                	je     8048a1a <check_file_handle+0xd1>
    fail ("size of %s (%zu) differs from expected (%zu)",
 8048a04:	57                   	push   %edi
 8048a05:	ff 74 24 10          	pushl  0x10(%esp)
 8048a09:	ff b4 24 3c 02 00 00 	pushl  0x23c(%esp)
 8048a10:	68 18 ba 04 08       	push   $0x804ba18
 8048a15:	e8 bc fb ff ff       	call   80485d6 <fail>
          file_name, file_size, size);

  msg ("verified contents of \"%s\"", file_name);
 8048a1a:	83 ec 08             	sub    $0x8,%esp
 8048a1d:	ff b4 24 3c 02 00 00 	pushl  0x23c(%esp)
 8048a24:	68 15 b5 04 08       	push   $0x804b515
 8048a29:	e8 85 fb ff ff       	call   80485b3 <msg>
}
 8048a2e:	83 c4 10             	add    $0x10,%esp
 8048a31:	eb 0d                	jmp    8048a40 <check_file_handle+0xf7>
  if (file_size != size)
    msg ("size of %s (%zu) differs from expected (%zu)",
          file_name, file_size, size);

  /* Read the file block-by-block, comparing data as we go. */
  while (ofs < size)
 8048a33:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
 8048a38:	0f 85 51 ff ff ff    	jne    804898f <check_file_handle+0x46>
 8048a3e:	eb da                	jmp    8048a1a <check_file_handle+0xd1>
  if (file_size != size)
    fail ("size of %s (%zu) differs from expected (%zu)",
          file_name, file_size, size);

  msg ("verified contents of \"%s\"", file_name);
}
 8048a40:	81 c4 1c 02 00 00    	add    $0x21c,%esp
 8048a46:	5b                   	pop    %ebx
 8048a47:	5e                   	pop    %esi
 8048a48:	5f                   	pop    %edi
 8048a49:	5d                   	pop    %ebp
 8048a4a:	c3                   	ret    

08048a4b <check_file>:

void
check_file (const char *file_name, const void *buf, size_t size) 
{
 8048a4b:	56                   	push   %esi
 8048a4c:	53                   	push   %ebx
 8048a4d:	83 ec 0c             	sub    $0xc,%esp
 8048a50:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  int fd;

  CHECK ((fd = open (file_name)) > 1, "open \"%s\" for verification",
 8048a54:	53                   	push   %ebx
 8048a55:	68 2f b5 04 08       	push   $0x804b52f
 8048a5a:	e8 54 fb ff ff       	call   80485b3 <msg>
 8048a5f:	89 1c 24             	mov    %ebx,(%esp)
 8048a62:	e8 69 1f 00 00       	call   804a9d0 <open>
 8048a67:	83 c4 10             	add    $0x10,%esp
 8048a6a:	83 f8 01             	cmp    $0x1,%eax
 8048a6d:	7f 0e                	jg     8048a7d <check_file+0x32>
 8048a6f:	83 ec 08             	sub    $0x8,%esp
 8048a72:	53                   	push   %ebx
 8048a73:	68 2f b5 04 08       	push   $0x804b52f
 8048a78:	e8 59 fb ff ff       	call   80485d6 <fail>
 8048a7d:	89 c6                	mov    %eax,%esi
         file_name);
  check_file_handle (fd, file_name, buf, size);
 8048a7f:	ff 74 24 18          	pushl  0x18(%esp)
 8048a83:	ff 74 24 18          	pushl  0x18(%esp)
 8048a87:	53                   	push   %ebx
 8048a88:	50                   	push   %eax
 8048a89:	e8 bb fe ff ff       	call   8048949 <check_file_handle>
  msg ("close \"%s\"", file_name);
 8048a8e:	83 c4 08             	add    $0x8,%esp
 8048a91:	53                   	push   %ebx
 8048a92:	68 4a b5 04 08       	push   $0x804b54a
 8048a97:	e8 17 fb ff ff       	call   80485b3 <msg>
  close (fd);
 8048a9c:	89 34 24             	mov    %esi,(%esp)
 8048a9f:	e8 93 1f 00 00       	call   804aa37 <close>
}
 8048aa4:	83 c4 14             	add    $0x14,%esp
 8048aa7:	5b                   	pop    %ebx
 8048aa8:	5e                   	pop    %esi
 8048aa9:	c3                   	ret    

08048aaa <seq_test>:

void 
seq_test (const char *file_name, void *buf, size_t size, size_t initial_size,
          size_t (*block_size_func) (void),
          void (*check_func) (int fd, long ofs)) 
{
 8048aaa:	55                   	push   %ebp
 8048aab:	57                   	push   %edi
 8048aac:	56                   	push   %esi
 8048aad:	53                   	push   %ebx
 8048aae:	83 ec 14             	sub    $0x14,%esp
 8048ab1:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
  size_t ofs;
  int fd;
  
  random_bytes (buf, size);
 8048ab5:	ff 74 24 30          	pushl  0x30(%esp)
 8048ab9:	ff 74 24 30          	pushl  0x30(%esp)
 8048abd:	e8 9e 01 00 00       	call   8048c60 <random_bytes>
  CHECK (create (file_name, initial_size), "create \"%s\"", file_name);
 8048ac2:	83 c4 08             	add    $0x8,%esp
 8048ac5:	ff 74 24 28          	pushl  0x28(%esp)
 8048ac9:	68 55 b5 04 08       	push   $0x804b555
 8048ace:	e8 e0 fa ff ff       	call   80485b3 <msg>
 8048ad3:	83 c4 08             	add    $0x8,%esp
 8048ad6:	ff 74 24 34          	pushl  0x34(%esp)
 8048ada:	ff 74 24 2c          	pushl  0x2c(%esp)
 8048ade:	e8 c4 1e 00 00       	call   804a9a7 <create>
 8048ae3:	83 c4 10             	add    $0x10,%esp
 8048ae6:	84 c0                	test   %al,%al
 8048ae8:	75 11                	jne    8048afb <seq_test+0x51>
 8048aea:	83 ec 08             	sub    $0x8,%esp
 8048aed:	ff 74 24 28          	pushl  0x28(%esp)
 8048af1:	68 55 b5 04 08       	push   $0x804b555
 8048af6:	e8 db fa ff ff       	call   80485d6 <fail>
  CHECK ((fd = open (file_name)) > 1, "open \"%s\"", file_name);
 8048afb:	83 ec 08             	sub    $0x8,%esp
 8048afe:	ff 74 24 28          	pushl  0x28(%esp)
 8048b02:	68 61 b5 04 08       	push   $0x804b561
 8048b07:	e8 a7 fa ff ff       	call   80485b3 <msg>
 8048b0c:	83 c4 04             	add    $0x4,%esp
 8048b0f:	ff 74 24 2c          	pushl  0x2c(%esp)
 8048b13:	e8 b8 1e 00 00       	call   804a9d0 <open>
 8048b18:	89 c7                	mov    %eax,%edi
 8048b1a:	83 c4 10             	add    $0x10,%esp
 8048b1d:	83 f8 01             	cmp    $0x1,%eax
 8048b20:	7f 11                	jg     8048b33 <seq_test+0x89>
 8048b22:	83 ec 08             	sub    $0x8,%esp
 8048b25:	ff 74 24 28          	pushl  0x28(%esp)
 8048b29:	68 61 b5 04 08       	push   $0x804b561
 8048b2e:	e8 a3 fa ff ff       	call   80485d6 <fail>

  ofs = 0;
  msg ("writing \"%s\"", file_name);
 8048b33:	83 ec 08             	sub    $0x8,%esp
 8048b36:	ff 74 24 28          	pushl  0x28(%esp)
 8048b3a:	68 6b b5 04 08       	push   $0x804b56b
 8048b3f:	e8 6f fa ff ff       	call   80485b3 <msg>
  while (ofs < size) 
 8048b44:	83 c4 10             	add    $0x10,%esp
 8048b47:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
 8048b4c:	74 54                	je     8048ba2 <seq_test+0xf8>
 8048b4e:	be 00 00 00 00       	mov    $0x0,%esi
    {
      size_t block_size = block_size_func ();
 8048b53:	ff 54 24 30          	call   *0x30(%esp)
      if (block_size > size - ofs)
 8048b57:	8b 54 24 28          	mov    0x28(%esp),%edx
 8048b5b:	29 f2                	sub    %esi,%edx
 8048b5d:	39 d0                	cmp    %edx,%eax
 8048b5f:	89 d3                	mov    %edx,%ebx
 8048b61:	0f 46 d8             	cmovbe %eax,%ebx
        block_size = size - ofs;

      if (write (fd, buf + ofs, block_size) != (int) block_size)
 8048b64:	83 ec 04             	sub    $0x4,%esp
 8048b67:	53                   	push   %ebx
 8048b68:	89 f0                	mov    %esi,%eax
 8048b6a:	03 44 24 2c          	add    0x2c(%esp),%eax
 8048b6e:	50                   	push   %eax
 8048b6f:	57                   	push   %edi
 8048b70:	e8 8c 1e 00 00       	call   804aa01 <write>
 8048b75:	83 c4 10             	add    $0x10,%esp
 8048b78:	39 d8                	cmp    %ebx,%eax
 8048b7a:	74 10                	je     8048b8c <seq_test+0xe2>
        fail ("write %zu bytes at offset %zu in \"%s\" failed",
 8048b7c:	ff 74 24 20          	pushl  0x20(%esp)
 8048b80:	56                   	push   %esi
 8048b81:	53                   	push   %ebx
 8048b82:	68 80 ba 04 08       	push   $0x804ba80
 8048b87:	e8 4a fa ff ff       	call   80485d6 <fail>
              block_size, ofs, file_name);

      ofs += block_size;
 8048b8c:	01 de                	add    %ebx,%esi
      if (check_func != NULL)
 8048b8e:	85 ed                	test   %ebp,%ebp
 8048b90:	74 0a                	je     8048b9c <seq_test+0xf2>
        check_func (fd, ofs);
 8048b92:	83 ec 08             	sub    $0x8,%esp
 8048b95:	56                   	push   %esi
 8048b96:	57                   	push   %edi
 8048b97:	ff d5                	call   *%ebp
 8048b99:	83 c4 10             	add    $0x10,%esp
  CHECK (create (file_name, initial_size), "create \"%s\"", file_name);
  CHECK ((fd = open (file_name)) > 1, "open \"%s\"", file_name);

  ofs = 0;
  msg ("writing \"%s\"", file_name);
  while (ofs < size) 
 8048b9c:	39 74 24 28          	cmp    %esi,0x28(%esp)
 8048ba0:	77 b1                	ja     8048b53 <seq_test+0xa9>

      ofs += block_size;
      if (check_func != NULL)
        check_func (fd, ofs);
    }
  msg ("close \"%s\"", file_name);
 8048ba2:	83 ec 08             	sub    $0x8,%esp
 8048ba5:	ff 74 24 28          	pushl  0x28(%esp)
 8048ba9:	68 4a b5 04 08       	push   $0x804b54a
 8048bae:	e8 00 fa ff ff       	call   80485b3 <msg>
  close (fd);
 8048bb3:	89 3c 24             	mov    %edi,(%esp)
 8048bb6:	e8 7c 1e 00 00       	call   804aa37 <close>
  check_file (file_name, buf, size);
 8048bbb:	83 c4 0c             	add    $0xc,%esp
 8048bbe:	ff 74 24 2c          	pushl  0x2c(%esp)
 8048bc2:	ff 74 24 2c          	pushl  0x2c(%esp)
 8048bc6:	ff 74 24 2c          	pushl  0x2c(%esp)
 8048bca:	e8 7c fe ff ff       	call   8048a4b <check_file>
}
 8048bcf:	83 c4 1c             	add    $0x1c,%esp
 8048bd2:	5b                   	pop    %ebx
 8048bd3:	5e                   	pop    %esi
 8048bd4:	5f                   	pop    %edi
 8048bd5:	5d                   	pop    %ebp
 8048bd6:	c3                   	ret    

08048bd7 <_start>:
int main (int, char *[]);
void _start (int argc, char *argv[]);

void
_start (int argc, char *argv[]) 
{
 8048bd7:	83 ec 14             	sub    $0x14,%esp
  exit (main (argc, argv));
 8048bda:	ff 74 24 1c          	pushl  0x1c(%esp)
 8048bde:	ff 74 24 1c          	pushl  0x1c(%esp)
 8048be2:	e8 85 f7 ff ff       	call   804836c <main>
 8048be7:	89 04 24             	mov    %eax,(%esp)
 8048bea:	e8 79 1d 00 00       	call   804a968 <exit>

08048bef <random_init>:
{
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
 8048bef:	b8 00 00 00 00       	mov    $0x0,%eax
    s[i] = i;
 8048bf4:	88 80 40 d6 04 08    	mov    %al,0x804d640(%eax)
{
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
 8048bfa:	83 c0 01             	add    $0x1,%eax
 8048bfd:	3d 00 01 00 00       	cmp    $0x100,%eax
 8048c02:	75 f0                	jne    8048bf4 <random_init+0x5>
}

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
 8048c04:	56                   	push   %esi
 8048c05:	53                   	push   %ebx
 8048c06:	be 00 00 00 00       	mov    $0x0,%esi
 8048c0b:	b8 00 00 00 00       	mov    $0x0,%eax

  for (i = 0; i < 256; i++) 
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
    {
      j += s[i] + seedp[i % sizeof seed];
 8048c10:	89 c1                	mov    %eax,%ecx
 8048c12:	83 e1 03             	and    $0x3,%ecx
 8048c15:	0f b6 98 40 d6 04 08 	movzbl 0x804d640(%eax),%ebx
 8048c1c:	89 da                	mov    %ebx,%edx
 8048c1e:	02 54 0c 0c          	add    0xc(%esp,%ecx,1),%dl
 8048c22:	89 d1                	mov    %edx,%ecx
 8048c24:	01 ce                	add    %ecx,%esi
      swap_byte (s + i, s + j);
 8048c26:	89 f2                	mov    %esi,%edx
 8048c28:	0f b6 ca             	movzbl %dl,%ecx
/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
  uint8_t t = *a;
  *a = *b;
 8048c2b:	0f b6 91 40 d6 04 08 	movzbl 0x804d640(%ecx),%edx
 8048c32:	88 90 40 d6 04 08    	mov    %dl,0x804d640(%eax)
  *b = t;
 8048c38:	88 99 40 d6 04 08    	mov    %bl,0x804d640(%ecx)
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
 8048c3e:	83 c0 01             	add    $0x1,%eax
 8048c41:	3d 00 01 00 00       	cmp    $0x100,%eax
 8048c46:	75 c8                	jne    8048c10 <random_init+0x21>
    {
      j += s[i] + seedp[i % sizeof seed];
      swap_byte (s + i, s + j);
    }

  s_i = s_j = 0;
 8048c48:	c6 05 21 d6 04 08 00 	movb   $0x0,0x804d621
 8048c4f:	c6 05 22 d6 04 08 00 	movb   $0x0,0x804d622
  inited = true;
 8048c56:	c6 05 20 d6 04 08 01 	movb   $0x1,0x804d620
}
 8048c5d:	5b                   	pop    %ebx
 8048c5e:	5e                   	pop    %esi
 8048c5f:	c3                   	ret    

08048c60 <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
 8048c60:	55                   	push   %ebp
 8048c61:	57                   	push   %edi
 8048c62:	56                   	push   %esi
 8048c63:	53                   	push   %ebx
 8048c64:	83 ec 08             	sub    $0x8,%esp
 8048c67:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
 8048c6b:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  uint8_t *buf;

  if (!inited)
 8048c6f:	80 3d 20 d6 04 08 00 	cmpb   $0x0,0x804d620
 8048c76:	75 0a                	jne    8048c82 <random_bytes+0x22>
    random_init (0);
 8048c78:	6a 00                	push   $0x0
 8048c7a:	e8 70 ff ff ff       	call   8048bef <random_init>
 8048c7f:	83 c4 04             	add    $0x4,%esp

  for (buf = buf_; size-- > 0; buf++)
 8048c82:	8d 45 ff             	lea    -0x1(%ebp),%eax
 8048c85:	89 04 24             	mov    %eax,(%esp)
 8048c88:	85 ed                	test   %ebp,%ebp
 8048c8a:	0f 84 82 00 00 00    	je     8048d12 <random_bytes+0xb2>
 8048c90:	0f b6 05 22 d6 04 08 	movzbl 0x804d622,%eax
 8048c97:	88 44 24 07          	mov    %al,0x7(%esp)
 8048c9b:	0f b6 35 21 d6 04 08 	movzbl 0x804d621,%esi
 8048ca2:	01 dd                	add    %ebx,%ebp
 8048ca4:	88 44 24 06          	mov    %al,0x6(%esp)
    {
      uint8_t s_k;
      
      s_i++;
 8048ca8:	80 44 24 06 01       	addb   $0x1,0x6(%esp)
 8048cad:	0f b6 44 24 06       	movzbl 0x6(%esp),%eax
      s_j += s[s_i];
 8048cb2:	0f b6 d0             	movzbl %al,%edx
 8048cb5:	89 f0                	mov    %esi,%eax
 8048cb7:	02 82 40 d6 04 08    	add    0x804d640(%edx),%al
 8048cbd:	89 c6                	mov    %eax,%esi
      swap_byte (s + s_i, s + s_j);
 8048cbf:	0f b6 c0             	movzbl %al,%eax

/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
  uint8_t t = *a;
 8048cc2:	0f b6 ba 40 d6 04 08 	movzbl 0x804d640(%edx),%edi
  *a = *b;
 8048cc9:	0f b6 88 40 d6 04 08 	movzbl 0x804d640(%eax),%ecx
 8048cd0:	88 8a 40 d6 04 08    	mov    %cl,0x804d640(%edx)
  *b = t;
 8048cd6:	89 f9                	mov    %edi,%ecx
 8048cd8:	88 88 40 d6 04 08    	mov    %cl,0x804d640(%eax)
      s_i++;
      s_j += s[s_i];
      swap_byte (s + s_i, s + s_j);

      s_k = s[s_i] + s[s_j];
      *buf = s[s_k];
 8048cde:	89 f8                	mov    %edi,%eax
 8048ce0:	02 82 40 d6 04 08    	add    0x804d640(%edx),%al
 8048ce6:	0f b6 c0             	movzbl %al,%eax
 8048ce9:	0f b6 80 40 d6 04 08 	movzbl 0x804d640(%eax),%eax
 8048cf0:	88 03                	mov    %al,(%ebx)
  uint8_t *buf;

  if (!inited)
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
 8048cf2:	83 c3 01             	add    $0x1,%ebx
 8048cf5:	39 dd                	cmp    %ebx,%ebp
 8048cf7:	75 af                	jne    8048ca8 <random_bytes+0x48>
 8048cf9:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
 8048cfe:	0f b6 3c 24          	movzbl (%esp),%edi
 8048d02:	8d 44 38 01          	lea    0x1(%eax,%edi,1),%eax
 8048d06:	a2 22 d6 04 08       	mov    %al,0x804d622
 8048d0b:	89 f0                	mov    %esi,%eax
 8048d0d:	a2 21 d6 04 08       	mov    %al,0x804d621
      swap_byte (s + s_i, s + s_j);

      s_k = s[s_i] + s[s_j];
      *buf = s[s_k];
    }
}
 8048d12:	83 c4 08             	add    $0x8,%esp
 8048d15:	5b                   	pop    %ebx
 8048d16:	5e                   	pop    %esi
 8048d17:	5f                   	pop    %edi
 8048d18:	5d                   	pop    %ebp
 8048d19:	c3                   	ret    

08048d1a <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
 8048d1a:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
 8048d1d:	6a 04                	push   $0x4
 8048d1f:	8d 44 24 10          	lea    0x10(%esp),%eax
 8048d23:	50                   	push   %eax
 8048d24:	e8 37 ff ff ff       	call   8048c60 <random_bytes>
  return ul;
}
 8048d29:	8b 44 24 14          	mov    0x14(%esp),%eax
 8048d2d:	83 c4 18             	add    $0x18,%esp
 8048d30:	c3                   	ret    

08048d31 <vsnprintf_helper>:
}

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
 8048d31:	53                   	push   %ebx
 8048d32:	8b 5c 24 08          	mov    0x8(%esp),%ebx
 8048d36:	8b 44 24 0c          	mov    0xc(%esp),%eax
  struct vsnprintf_aux *aux = aux_;

  if (aux->length++ < aux->max_length)
 8048d3a:	8b 50 04             	mov    0x4(%eax),%edx
 8048d3d:	8d 4a 01             	lea    0x1(%edx),%ecx
 8048d40:	89 48 04             	mov    %ecx,0x4(%eax)
 8048d43:	3b 50 08             	cmp    0x8(%eax),%edx
 8048d46:	7d 09                	jge    8048d51 <vsnprintf_helper+0x20>
    *aux->p++ = ch;
 8048d48:	8b 10                	mov    (%eax),%edx
 8048d4a:	8d 4a 01             	lea    0x1(%edx),%ecx
 8048d4d:	89 08                	mov    %ecx,(%eax)
 8048d4f:	88 1a                	mov    %bl,(%edx)
}
 8048d51:	5b                   	pop    %ebx
 8048d52:	c3                   	ret    

08048d53 <output_dup>:
}

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
 8048d53:	55                   	push   %ebp
 8048d54:	57                   	push   %edi
 8048d55:	56                   	push   %esi
 8048d56:	53                   	push   %ebx
 8048d57:	83 ec 0c             	sub    $0xc,%esp
 8048d5a:	8b 7c 24 20          	mov    0x20(%esp),%edi
  while (cnt-- > 0)
 8048d5e:	85 d2                	test   %edx,%edx
 8048d60:	74 16                	je     8048d78 <output_dup+0x25>
 8048d62:	89 cd                	mov    %ecx,%ebp
 8048d64:	89 d3                	mov    %edx,%ebx
    output (ch, aux);
 8048d66:	0f be f0             	movsbl %al,%esi
 8048d69:	83 ec 08             	sub    $0x8,%esp
 8048d6c:	57                   	push   %edi
 8048d6d:	56                   	push   %esi
 8048d6e:	ff d5                	call   *%ebp

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
  while (cnt-- > 0)
 8048d70:	83 c4 10             	add    $0x10,%esp
 8048d73:	83 eb 01             	sub    $0x1,%ebx
 8048d76:	75 f1                	jne    8048d69 <output_dup+0x16>
    output (ch, aux);
}
 8048d78:	83 c4 0c             	add    $0xc,%esp
 8048d7b:	5b                   	pop    %ebx
 8048d7c:	5e                   	pop    %esi
 8048d7d:	5f                   	pop    %edi
 8048d7e:	5d                   	pop    %ebp
 8048d7f:	c3                   	ret    

08048d80 <format_integer>:
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
                const struct integer_base *b,
                const struct printf_conversion *c,
                void (*output) (char, void *), void *aux)
{
 8048d80:	55                   	push   %ebp
 8048d81:	57                   	push   %edi
 8048d82:	56                   	push   %esi
 8048d83:	53                   	push   %ebx
 8048d84:	83 ec 7c             	sub    $0x7c,%esp
 8048d87:	89 c6                	mov    %eax,%esi
 8048d89:	89 d7                	mov    %edx,%edi
 8048d8b:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
 8048d92:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
 8048d99:	00 
  if (is_signed) 
 8048d9a:	84 c9                	test   %cl,%cl
 8048d9c:	74 40                	je     8048dde <format_integer+0x5e>
    {
      if (c->flags & PLUS)
 8048d9e:	8b 94 24 98 00 00 00 	mov    0x98(%esp),%edx
 8048da5:	8b 12                	mov    (%edx),%edx
 8048da7:	f6 c2 02             	test   $0x2,%dl
 8048daa:	74 10                	je     8048dbc <format_integer+0x3c>
        sign = negative ? '-' : '+';
 8048dac:	3c 01                	cmp    $0x1,%al
 8048dae:	19 c0                	sbb    %eax,%eax
 8048db0:	83 e0 fe             	and    $0xfffffffe,%eax
 8048db3:	83 c0 2d             	add    $0x2d,%eax
 8048db6:	89 44 24 20          	mov    %eax,0x20(%esp)
 8048dba:	eb 22                	jmp    8048dde <format_integer+0x5e>
      else if (c->flags & SPACE)
 8048dbc:	f6 c2 04             	test   $0x4,%dl
 8048dbf:	74 10                	je     8048dd1 <format_integer+0x51>
        sign = negative ? '-' : ' ';
 8048dc1:	3c 01                	cmp    $0x1,%al
 8048dc3:	19 c0                	sbb    %eax,%eax
 8048dc5:	83 e0 f3             	and    $0xfffffff3,%eax
 8048dc8:	83 c0 2d             	add    $0x2d,%eax
 8048dcb:	89 44 24 20          	mov    %eax,0x20(%esp)
 8048dcf:	eb 0d                	jmp    8048dde <format_integer+0x5e>
      else if (negative)
        sign = '-';
 8048dd1:	3c 01                	cmp    $0x1,%al
 8048dd3:	19 c0                	sbb    %eax,%eax
 8048dd5:	f7 d0                	not    %eax
 8048dd7:	83 e0 2d             	and    $0x2d,%eax
 8048dda:	89 44 24 20          	mov    %eax,0x20(%esp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
 8048dde:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
 8048de5:	8b 00                	mov    (%eax),%eax
 8048de7:	89 44 24 28          	mov    %eax,0x28(%esp)
 8048deb:	83 e0 08             	and    $0x8,%eax
 8048dee:	89 44 24 2c          	mov    %eax,0x2c(%esp)
 8048df2:	89 f2                	mov    %esi,%edx
 8048df4:	09 fa                	or     %edi,%edx
 8048df6:	74 14                	je     8048e0c <format_integer+0x8c>
 8048df8:	85 c0                	test   %eax,%eax
 8048dfa:	74 10                	je     8048e0c <format_integer+0x8c>
 8048dfc:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
 8048e03:	8b 40 08             	mov    0x8(%eax),%eax
 8048e06:	89 44 24 24          	mov    %eax,0x24(%esp)
 8048e0a:	eb 08                	jmp    8048e14 <format_integer+0x94>
 8048e0c:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
 8048e13:	00 
  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
 8048e14:	89 f8                	mov    %edi,%eax
 8048e16:	09 f0                	or     %esi,%eax
 8048e18:	0f 84 ad 00 00 00    	je     8048ecb <format_integer+0x14b>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
        *cp++ = ',';
      *cp++ = b->digits[value % b->base];
 8048e1e:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
 8048e25:	8b 40 04             	mov    0x4(%eax),%eax
 8048e28:	89 44 24 18          	mov    %eax,0x18(%esp)
 8048e2c:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
 8048e33:	8b 00                	mov    (%eax),%eax
 8048e35:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048e39:	99                   	cltd   
 8048e3a:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8048e3e:	bb 00 00 00 00       	mov    $0x0,%ebx
 8048e43:	8d 6c 24 30          	lea    0x30(%esp),%ebp
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
 8048e47:	8b 44 24 28          	mov    0x28(%esp),%eax
 8048e4b:	c1 e8 05             	shr    $0x5,%eax
 8048e4e:	83 e0 01             	and    $0x1,%eax
 8048e51:	88 44 24 1f          	mov    %al,0x1f(%esp)
 8048e55:	eb 2b                	jmp    8048e82 <format_integer+0x102>
 8048e57:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
 8048e5c:	74 20                	je     8048e7e <format_integer+0xfe>
 8048e5e:	85 db                	test   %ebx,%ebx
 8048e60:	7e 1c                	jle    8048e7e <format_integer+0xfe>
 8048e62:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
 8048e69:	89 d8                	mov    %ebx,%eax
 8048e6b:	99                   	cltd   
 8048e6c:	f7 79 0c             	idivl  0xc(%ecx)
 8048e6f:	85 d2                	test   %edx,%edx
 8048e71:	75 0b                	jne    8048e7e <format_integer+0xfe>
        *cp++ = ',';
 8048e73:	8d 45 02             	lea    0x2(%ebp),%eax
 8048e76:	89 44 24 14          	mov    %eax,0x14(%esp)
 8048e7a:	c6 45 01 2c          	movb   $0x2c,0x1(%ebp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
 8048e7e:	8b 6c 24 14          	mov    0x14(%esp),%ebp
  digit_cnt = 0;
  while (value > 0) 
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
        *cp++ = ',';
      *cp++ = b->digits[value % b->base];
 8048e82:	8d 45 01             	lea    0x1(%ebp),%eax
 8048e85:	89 44 24 14          	mov    %eax,0x14(%esp)
 8048e89:	ff 74 24 0c          	pushl  0xc(%esp)
 8048e8d:	ff 74 24 0c          	pushl  0xc(%esp)
 8048e91:	57                   	push   %edi
 8048e92:	56                   	push   %esi
 8048e93:	e8 d8 15 00 00       	call   804a470 <__umoddi3>
 8048e98:	83 c4 10             	add    $0x10,%esp
 8048e9b:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 8048e9f:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
 8048ea3:	88 45 00             	mov    %al,0x0(%ebp)
      value /= b->base;
 8048ea6:	ff 74 24 0c          	pushl  0xc(%esp)
 8048eaa:	ff 74 24 0c          	pushl  0xc(%esp)
 8048eae:	57                   	push   %edi
 8048eaf:	56                   	push   %esi
 8048eb0:	e8 9f 15 00 00       	call   804a454 <__udivdi3>
 8048eb5:	83 c4 10             	add    $0x10,%esp
 8048eb8:	89 c6                	mov    %eax,%esi
 8048eba:	89 d7                	mov    %edx,%edi
      digit_cnt++;
 8048ebc:	83 c3 01             	add    $0x1,%ebx
  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
 8048ebf:	89 d0                	mov    %edx,%eax
 8048ec1:	09 f0                	or     %esi,%eax
 8048ec3:	75 92                	jne    8048e57 <format_integer+0xd7>
 8048ec5:	8b 5c 24 14          	mov    0x14(%esp),%ebx
 8048ec9:	eb 04                	jmp    8048ecf <format_integer+0x14f>
  x = (c->flags & POUND) && value ? b->x : 0;

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
 8048ecb:	8d 5c 24 30          	lea    0x30(%esp),%ebx
  /* Append enough zeros to match precision.
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
 8048ecf:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
 8048ed6:	8b 50 08             	mov    0x8(%eax),%edx
 8048ed9:	85 d2                	test   %edx,%edx
 8048edb:	b8 01 00 00 00       	mov    $0x1,%eax
 8048ee0:	0f 48 d0             	cmovs  %eax,%edx
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
 8048ee3:	8d 7c 24 30          	lea    0x30(%esp),%edi
 8048ee7:	89 d8                	mov    %ebx,%eax
 8048ee9:	29 f8                	sub    %edi,%eax
 8048eeb:	39 c2                	cmp    %eax,%edx
 8048eed:	7e 1f                	jle    8048f0e <format_integer+0x18e>
 8048eef:	8d 44 24 6f          	lea    0x6f(%esp),%eax
 8048ef3:	39 c3                	cmp    %eax,%ebx
 8048ef5:	73 17                	jae    8048f0e <format_integer+0x18e>
 8048ef7:	89 f9                	mov    %edi,%ecx
 8048ef9:	89 c6                	mov    %eax,%esi
    *cp++ = '0';
 8048efb:	83 c3 01             	add    $0x1,%ebx
 8048efe:	c6 43 ff 30          	movb   $0x30,-0x1(%ebx)
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
 8048f02:	89 d8                	mov    %ebx,%eax
 8048f04:	29 c8                	sub    %ecx,%eax
 8048f06:	39 c2                	cmp    %eax,%edx
 8048f08:	7e 04                	jle    8048f0e <format_integer+0x18e>
 8048f0a:	39 f3                	cmp    %esi,%ebx
 8048f0c:	72 ed                	jb     8048efb <format_integer+0x17b>
    *cp++ = '0';
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
 8048f0e:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
 8048f13:	74 20                	je     8048f35 <format_integer+0x1b5>
 8048f15:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
 8048f1c:	83 38 08             	cmpl   $0x8,(%eax)
 8048f1f:	75 14                	jne    8048f35 <format_integer+0x1b5>
 8048f21:	8d 44 24 30          	lea    0x30(%esp),%eax
 8048f25:	39 c3                	cmp    %eax,%ebx
 8048f27:	74 06                	je     8048f2f <format_integer+0x1af>
 8048f29:	80 7b ff 30          	cmpb   $0x30,-0x1(%ebx)
 8048f2d:	74 06                	je     8048f35 <format_integer+0x1b5>
    *cp++ = '0';
 8048f2f:	c6 03 30             	movb   $0x30,(%ebx)
 8048f32:	8d 5b 01             	lea    0x1(%ebx),%ebx

  /* Calculate number of pad characters to fill field width. */
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
 8048f35:	29 df                	sub    %ebx,%edi
 8048f37:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
 8048f3e:	03 78 04             	add    0x4(%eax),%edi
 8048f41:	89 fe                	mov    %edi,%esi
 8048f43:	83 7c 24 24 01       	cmpl   $0x1,0x24(%esp)
 8048f48:	19 c0                	sbb    %eax,%eax
 8048f4a:	f7 d0                	not    %eax
 8048f4c:	83 e0 02             	and    $0x2,%eax
 8048f4f:	29 c6                	sub    %eax,%esi
 8048f51:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
 8048f56:	0f 95 c0             	setne  %al
 8048f59:	0f b6 c0             	movzbl %al,%eax
 8048f5c:	29 c6                	sub    %eax,%esi
 8048f5e:	b8 00 00 00 00       	mov    $0x0,%eax
 8048f63:	0f 48 f0             	cmovs  %eax,%esi
  if (pad_cnt < 0)
    pad_cnt = 0;

  /* Do output. */
  if ((c->flags & (MINUS | ZERO)) == 0)
 8048f66:	f6 44 24 28 11       	testb  $0x11,0x28(%esp)
 8048f6b:	75 20                	jne    8048f8d <format_integer+0x20d>
    output_dup (' ', pad_cnt, output, aux);
 8048f6d:	83 ec 0c             	sub    $0xc,%esp
 8048f70:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
 8048f77:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
 8048f7e:	89 f2                	mov    %esi,%edx
 8048f80:	b8 20 00 00 00       	mov    $0x20,%eax
 8048f85:	e8 c9 fd ff ff       	call   8048d53 <output_dup>
 8048f8a:	83 c4 10             	add    $0x10,%esp
  if (sign)
 8048f8d:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
 8048f92:	74 18                	je     8048fac <format_integer+0x22c>
    output (sign, aux);
 8048f94:	83 ec 08             	sub    $0x8,%esp
 8048f97:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
 8048f9e:	ff 74 24 2c          	pushl  0x2c(%esp)
 8048fa2:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
 8048fa9:	83 c4 10             	add    $0x10,%esp
  if (x) 
 8048fac:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
 8048fb1:	74 2d                	je     8048fe0 <format_integer+0x260>
    {
      output ('0', aux);
 8048fb3:	83 ec 08             	sub    $0x8,%esp
 8048fb6:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
 8048fbd:	6a 30                	push   $0x30
 8048fbf:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
      output (x, aux); 
 8048fc6:	83 c4 08             	add    $0x8,%esp
 8048fc9:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
 8048fd0:	0f be 44 24 30       	movsbl 0x30(%esp),%eax
 8048fd5:	50                   	push   %eax
 8048fd6:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
 8048fdd:	83 c4 10             	add    $0x10,%esp
    }
  if (c->flags & ZERO)
 8048fe0:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
 8048fe7:	f6 00 10             	testb  $0x10,(%eax)
 8048fea:	74 20                	je     804900c <format_integer+0x28c>
    output_dup ('0', pad_cnt, output, aux);
 8048fec:	83 ec 0c             	sub    $0xc,%esp
 8048fef:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
 8048ff6:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
 8048ffd:	89 f2                	mov    %esi,%edx
 8048fff:	b8 30 00 00 00       	mov    $0x30,%eax
 8049004:	e8 4a fd ff ff       	call   8048d53 <output_dup>
 8049009:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
 804900c:	8d 44 24 30          	lea    0x30(%esp),%eax
 8049010:	39 c3                	cmp    %eax,%ebx
 8049012:	76 2c                	jbe    8049040 <format_integer+0x2c0>
 8049014:	89 c7                	mov    %eax,%edi
 8049016:	89 74 24 08          	mov    %esi,0x8(%esp)
 804901a:	8b b4 24 9c 00 00 00 	mov    0x9c(%esp),%esi
 8049021:	8b ac 24 a0 00 00 00 	mov    0xa0(%esp),%ebp
    output (*--cp, aux);
 8049028:	83 eb 01             	sub    $0x1,%ebx
 804902b:	83 ec 08             	sub    $0x8,%esp
 804902e:	55                   	push   %ebp
 804902f:	0f be 03             	movsbl (%ebx),%eax
 8049032:	50                   	push   %eax
 8049033:	ff d6                	call   *%esi
      output ('0', aux);
      output (x, aux); 
    }
  if (c->flags & ZERO)
    output_dup ('0', pad_cnt, output, aux);
  while (cp > buf)
 8049035:	83 c4 10             	add    $0x10,%esp
 8049038:	39 fb                	cmp    %edi,%ebx
 804903a:	75 ec                	jne    8049028 <format_integer+0x2a8>
 804903c:	8b 74 24 08          	mov    0x8(%esp),%esi
    output (*--cp, aux);
  if (c->flags & MINUS)
 8049040:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
 8049047:	f6 00 01             	testb  $0x1,(%eax)
 804904a:	74 20                	je     804906c <format_integer+0x2ec>
    output_dup (' ', pad_cnt, output, aux);
 804904c:	83 ec 0c             	sub    $0xc,%esp
 804904f:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
 8049056:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
 804905d:	89 f2                	mov    %esi,%edx
 804905f:	b8 20 00 00 00       	mov    $0x20,%eax
 8049064:	e8 ea fc ff ff       	call   8048d53 <output_dup>
 8049069:	83 c4 10             	add    $0x10,%esp
}
 804906c:	83 c4 7c             	add    $0x7c,%esp
 804906f:	5b                   	pop    %ebx
 8049070:	5e                   	pop    %esi
 8049071:	5f                   	pop    %edi
 8049072:	5d                   	pop    %ebp
 8049073:	c3                   	ret    

08049074 <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
 8049074:	55                   	push   %ebp
 8049075:	57                   	push   %edi
 8049076:	56                   	push   %esi
 8049077:	53                   	push   %ebx
 8049078:	83 ec 1c             	sub    $0x1c,%esp
 804907b:	89 c5                	mov    %eax,%ebp
 804907d:	89 d6                	mov    %edx,%esi
 804907f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
 8049083:	8b 7c 24 34          	mov    0x34(%esp),%edi
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
 8049087:	8b 51 04             	mov    0x4(%ecx),%edx
 804908a:	39 f2                	cmp    %esi,%edx
 804908c:	7e 6c                	jle    80490fa <format_string+0x86>
 804908e:	f6 01 01             	testb  $0x1,(%ecx)
 8049091:	75 61                	jne    80490f4 <format_string+0x80>
    output_dup (' ', c->width - length, output, aux);
 8049093:	29 f2                	sub    %esi,%edx
 8049095:	83 ec 0c             	sub    $0xc,%esp
 8049098:	57                   	push   %edi
 8049099:	8b 4c 24 40          	mov    0x40(%esp),%ecx
 804909d:	b8 20 00 00 00       	mov    $0x20,%eax
 80490a2:	e8 ac fc ff ff       	call   8048d53 <output_dup>
  for (i = 0; i < length; i++)
 80490a7:	83 c4 10             	add    $0x10,%esp
 80490aa:	85 f6                	test   %esi,%esi
 80490ac:	7e 1d                	jle    80490cb <format_string+0x57>
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
 80490ae:	bb 00 00 00 00       	mov    $0x0,%ebx
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
    output (string[i], aux);
 80490b3:	83 ec 08             	sub    $0x8,%esp
 80490b6:	57                   	push   %edi
 80490b7:	0f be 44 1d 00       	movsbl 0x0(%ebp,%ebx,1),%eax
 80490bc:	50                   	push   %eax
 80490bd:	ff 54 24 40          	call   *0x40(%esp)
               void (*output) (char, void *), void *aux) 
{
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
 80490c1:	83 c3 01             	add    $0x1,%ebx
 80490c4:	83 c4 10             	add    $0x10,%esp
 80490c7:	39 de                	cmp    %ebx,%esi
 80490c9:	7f e8                	jg     80490b3 <format_string+0x3f>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
 80490cb:	8b 44 24 0c          	mov    0xc(%esp),%eax
 80490cf:	8b 50 04             	mov    0x4(%eax),%edx
 80490d2:	39 d6                	cmp    %edx,%esi
 80490d4:	7d 28                	jge    80490fe <format_string+0x8a>
 80490d6:	f6 00 01             	testb  $0x1,(%eax)
 80490d9:	74 23                	je     80490fe <format_string+0x8a>
    output_dup (' ', c->width - length, output, aux);
 80490db:	29 f2                	sub    %esi,%edx
 80490dd:	83 ec 0c             	sub    $0xc,%esp
 80490e0:	57                   	push   %edi
 80490e1:	8b 4c 24 40          	mov    0x40(%esp),%ecx
 80490e5:	b8 20 00 00 00       	mov    $0x20,%eax
 80490ea:	e8 64 fc ff ff       	call   8048d53 <output_dup>
 80490ef:	83 c4 10             	add    $0x10,%esp
}
 80490f2:	eb 0a                	jmp    80490fe <format_string+0x8a>
               void (*output) (char, void *), void *aux) 
{
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
 80490f4:	85 f6                	test   %esi,%esi
 80490f6:	7f b6                	jg     80490ae <format_string+0x3a>
 80490f8:	eb e1                	jmp    80490db <format_string+0x67>
 80490fa:	85 f6                	test   %esi,%esi
 80490fc:	7f b0                	jg     80490ae <format_string+0x3a>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
    output_dup (' ', c->width - length, output, aux);
}
 80490fe:	83 c4 1c             	add    $0x1c,%esp
 8049101:	5b                   	pop    %ebx
 8049102:	5e                   	pop    %esi
 8049103:	5f                   	pop    %edi
 8049104:	5d                   	pop    %ebp
 8049105:	c3                   	ret    

08049106 <printf>:
   In the kernel, the console is both the video display and first
   serial port.
   In userspace, the console is file descriptor 1. */
int
printf (const char *format, ...) 
{
 8049106:	83 ec 0c             	sub    $0xc,%esp
  va_list args;
  int retval;

  va_start (args, format);
 8049109:	8d 44 24 14          	lea    0x14(%esp),%eax
  retval = vprintf (format, args);
 804910d:	83 ec 08             	sub    $0x8,%esp
 8049110:	50                   	push   %eax
 8049111:	ff 74 24 1c          	pushl  0x1c(%esp)
 8049115:	e8 93 1a 00 00       	call   804abad <vprintf>
  va_end (args);

  return retval;
}
 804911a:	83 c4 1c             	add    $0x1c,%esp
 804911d:	c3                   	ret    

0804911e <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
 804911e:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  va_start (args, aux);
 8049121:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  __vprintf (format, args, output, aux);
 8049125:	ff 74 24 18          	pushl  0x18(%esp)
 8049129:	ff 74 24 18          	pushl  0x18(%esp)
 804912d:	50                   	push   %eax
 804912e:	ff 74 24 1c          	pushl  0x1c(%esp)
 8049132:	e8 04 00 00 00       	call   804913b <__vprintf>
  va_end (args);
}
 8049137:	83 c4 1c             	add    $0x1c,%esp
 804913a:	c3                   	ret    

0804913b <__vprintf>:
                           void (*output) (char, void *), void *aux);

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
 804913b:	55                   	push   %ebp
 804913c:	57                   	push   %edi
 804913d:	56                   	push   %esi
 804913e:	53                   	push   %ebx
 804913f:	83 ec 4c             	sub    $0x4c,%esp
 8049142:	8b 74 24 60          	mov    0x60(%esp),%esi
 8049146:	8b 6c 24 64          	mov    0x64(%esp),%ebp
  for (; *format != '\0'; format++)
 804914a:	0f b6 06             	movzbl (%esi),%eax
 804914d:	84 c0                	test   %al,%al
 804914f:	0f 84 49 06 00 00    	je     804979e <__vprintf+0x663>
    {
      struct printf_conversion c;

      /* Literally copy non-conversions to output. */
      if (*format != '%') 
 8049155:	3c 25                	cmp    $0x25,%al
 8049157:	74 19                	je     8049172 <__vprintf+0x37>
        {
          output (*format, aux);
 8049159:	83 ec 08             	sub    $0x8,%esp
 804915c:	ff 74 24 74          	pushl  0x74(%esp)
 8049160:	0f be c0             	movsbl %al,%eax
 8049163:	50                   	push   %eax
 8049164:	ff 54 24 78          	call   *0x78(%esp)
          continue;
 8049168:	83 c4 10             	add    $0x10,%esp
 804916b:	89 f3                	mov    %esi,%ebx
 804916d:	e9 12 06 00 00       	jmp    8049784 <__vprintf+0x649>
        }
      format++;
 8049172:	8d 5e 01             	lea    0x1(%esi),%ebx

      /* %% => %. */
      if (*format == '%') 
 8049175:	80 7e 01 25          	cmpb   $0x25,0x1(%esi)
 8049179:	75 15                	jne    8049190 <__vprintf+0x55>
        {
          output ('%', aux);
 804917b:	83 ec 08             	sub    $0x8,%esp
 804917e:	ff 74 24 74          	pushl  0x74(%esp)
 8049182:	6a 25                	push   $0x25
 8049184:	ff 54 24 78          	call   *0x78(%esp)
          continue;
 8049188:	83 c4 10             	add    $0x10,%esp
 804918b:	e9 f4 05 00 00       	jmp    8049784 <__vprintf+0x649>
static const char *
parse_conversion (const char *format, struct printf_conversion *c,
                  va_list *args) 
{
  /* Parse flag characters. */
  c->flags = 0;
 8049190:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
 8049197:	00 
 8049198:	bf 00 00 00 00       	mov    $0x0,%edi
 804919d:	be 00 00 00 00       	mov    $0x0,%esi
 80491a2:	eb 07                	jmp    80491ab <__vprintf+0x70>
  for (;;) 
    {
      switch (*format++) 
 80491a4:	89 cb                	mov    %ecx,%ebx
 80491a6:	bf 01 00 00 00       	mov    $0x1,%edi
 80491ab:	8d 4b 01             	lea    0x1(%ebx),%ecx
 80491ae:	0f b6 41 ff          	movzbl -0x1(%ecx),%eax
 80491b2:	8d 50 e0             	lea    -0x20(%eax),%edx
 80491b5:	80 fa 10             	cmp    $0x10,%dl
 80491b8:	77 28                	ja     80491e2 <__vprintf+0xa7>
 80491ba:	0f b6 d2             	movzbl %dl,%edx
 80491bd:	ff 24 95 60 ac 04 08 	jmp    *0x804ac60(,%edx,4)
        {
        case '-':
          c->flags |= MINUS;
 80491c4:	83 ce 01             	or     $0x1,%esi
 80491c7:	eb db                	jmp    80491a4 <__vprintf+0x69>
          break;
        case '+':
          c->flags |= PLUS;
 80491c9:	83 ce 02             	or     $0x2,%esi
 80491cc:	eb d6                	jmp    80491a4 <__vprintf+0x69>
          break;
        case ' ':
          c->flags |= SPACE;
 80491ce:	83 ce 04             	or     $0x4,%esi
 80491d1:	eb d1                	jmp    80491a4 <__vprintf+0x69>
          break;
        case '#':
          c->flags |= POUND;
 80491d3:	83 ce 08             	or     $0x8,%esi
 80491d6:	eb cc                	jmp    80491a4 <__vprintf+0x69>
          break;
        case '0':
          c->flags |= ZERO;
 80491d8:	83 ce 10             	or     $0x10,%esi
 80491db:	eb c7                	jmp    80491a4 <__vprintf+0x69>
          break;
        case '\'':
          c->flags |= GROUP;
 80491dd:	83 ce 20             	or     $0x20,%esi
 80491e0:	eb c2                	jmp    80491a4 <__vprintf+0x69>
 80491e2:	89 fa                	mov    %edi,%edx
 80491e4:	84 d2                	test   %dl,%dl
 80491e6:	74 13                	je     80491fb <__vprintf+0xc0>
 80491e8:	89 74 24 30          	mov    %esi,0x30(%esp)
          format--;
          goto not_a_flag;
        }
    }
 not_a_flag:
  if (c->flags & MINUS)
 80491ec:	f7 c6 01 00 00 00    	test   $0x1,%esi
 80491f2:	74 07                	je     80491fb <__vprintf+0xc0>
    c->flags &= ~ZERO;
 80491f4:	83 e6 ef             	and    $0xffffffef,%esi
 80491f7:	89 74 24 30          	mov    %esi,0x30(%esp)
  if (c->flags & PLUS)
 80491fb:	8b 54 24 30          	mov    0x30(%esp),%edx
 80491ff:	f6 c2 02             	test   $0x2,%dl
 8049202:	74 07                	je     804920b <__vprintf+0xd0>
    c->flags &= ~SPACE;
 8049204:	83 e2 fb             	and    $0xfffffffb,%edx
 8049207:	89 54 24 30          	mov    %edx,0x30(%esp)

  /* Parse field width. */
  c->width = 0;
 804920b:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
 8049212:	00 
  if (*format == '*')
 8049213:	3c 2a                	cmp    $0x2a,%al
 8049215:	74 12                	je     8049229 <__vprintf+0xee>
      format++;
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
 8049217:	0f be d0             	movsbl %al,%edx
 804921a:	83 ea 30             	sub    $0x30,%edx
 804921d:	b9 00 00 00 00       	mov    $0x0,%ecx
 8049222:	83 fa 09             	cmp    $0x9,%edx
 8049225:	76 10                	jbe    8049237 <__vprintf+0xfc>
 8049227:	eb 40                	jmp    8049269 <__vprintf+0x12e>
  /* Parse field width. */
  c->width = 0;
  if (*format == '*')
    {
      format++;
      c->width = va_arg (*args, int);
 8049229:	8b 45 00             	mov    0x0(%ebp),%eax
 804922c:	89 44 24 34          	mov    %eax,0x34(%esp)
 8049230:	8d 6d 04             	lea    0x4(%ebp),%ebp
{
  /* Parse flag characters. */
  c->flags = 0;
  for (;;) 
    {
      switch (*format++) 
 8049233:	89 cb                	mov    %ecx,%ebx
 8049235:	eb 1f                	jmp    8049256 <__vprintf+0x11b>
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
        c->width = c->width * 10 + *format - '0';
 8049237:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
 804923a:	0f be c0             	movsbl %al,%eax
 804923d:	8d 4c 50 d0          	lea    -0x30(%eax,%edx,2),%ecx
      format++;
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
 8049241:	83 c3 01             	add    $0x1,%ebx
 8049244:	0f b6 03             	movzbl (%ebx),%eax
 8049247:	0f be d0             	movsbl %al,%edx
 804924a:	83 ea 30             	sub    $0x30,%edx
 804924d:	83 fa 09             	cmp    $0x9,%edx
 8049250:	76 e5                	jbe    8049237 <__vprintf+0xfc>
 8049252:	89 4c 24 34          	mov    %ecx,0x34(%esp)
        c->width = c->width * 10 + *format - '0';
    }
  if (c->width < 0) 
 8049256:	8b 44 24 34          	mov    0x34(%esp),%eax
 804925a:	85 c0                	test   %eax,%eax
 804925c:	79 0b                	jns    8049269 <__vprintf+0x12e>
    {
      c->width = -c->width;
 804925e:	f7 d8                	neg    %eax
 8049260:	89 44 24 34          	mov    %eax,0x34(%esp)
      c->flags |= MINUS;
 8049264:	83 4c 24 30 01       	orl    $0x1,0x30(%esp)
    }
      
  /* Parse precision. */
  c->precision = -1;
 8049269:	c7 44 24 38 ff ff ff 	movl   $0xffffffff,0x38(%esp)
 8049270:	ff 
  if (*format == '.') 
 8049271:	80 3b 2e             	cmpb   $0x2e,(%ebx)
 8049274:	0f 85 1b 05 00 00    	jne    8049795 <__vprintf+0x65a>
    {
      format++;
      if (*format == '*') 
 804927a:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 804927e:	3c 2a                	cmp    $0x2a,%al
 8049280:	75 0f                	jne    8049291 <__vprintf+0x156>
        {
          format++;
 8049282:	83 c3 02             	add    $0x2,%ebx
          c->precision = va_arg (*args, int);
 8049285:	8b 45 00             	mov    0x0(%ebp),%eax
 8049288:	89 44 24 38          	mov    %eax,0x38(%esp)
 804928c:	8d 6d 04             	lea    0x4(%ebp),%ebp
 804928f:	eb 3a                	jmp    80492cb <__vprintf+0x190>
      
  /* Parse precision. */
  c->precision = -1;
  if (*format == '.') 
    {
      format++;
 8049291:	83 c3 01             	add    $0x1,%ebx
          format++;
          c->precision = va_arg (*args, int);
        }
      else 
        {
          c->precision = 0;
 8049294:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
 804929b:	00 
          for (; isdigit (*format); format++)
 804929c:	0f be d0             	movsbl %al,%edx
 804929f:	83 ea 30             	sub    $0x30,%edx
 80492a2:	83 fa 09             	cmp    $0x9,%edx
 80492a5:	77 39                	ja     80492e0 <__vprintf+0x1a5>
 80492a7:	b9 00 00 00 00       	mov    $0x0,%ecx
            c->precision = c->precision * 10 + *format - '0';
 80492ac:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
 80492af:	0f be c0             	movsbl %al,%eax
 80492b2:	8d 4c 50 d0          	lea    -0x30(%eax,%edx,2),%ecx
          c->precision = va_arg (*args, int);
        }
      else 
        {
          c->precision = 0;
          for (; isdigit (*format); format++)
 80492b6:	83 c3 01             	add    $0x1,%ebx
 80492b9:	0f b6 03             	movzbl (%ebx),%eax
 80492bc:	0f be d0             	movsbl %al,%edx
 80492bf:	83 ea 30             	sub    $0x30,%edx
 80492c2:	83 fa 09             	cmp    $0x9,%edx
 80492c5:	76 e5                	jbe    80492ac <__vprintf+0x171>
 80492c7:	89 4c 24 38          	mov    %ecx,0x38(%esp)
            c->precision = c->precision * 10 + *format - '0';
        }
      if (c->precision < 0) 
 80492cb:	8b 4c 24 38          	mov    0x38(%esp),%ecx
 80492cf:	85 c9                	test   %ecx,%ecx
 80492d1:	79 12                	jns    80492e5 <__vprintf+0x1aa>
        c->precision = -1;
 80492d3:	c7 44 24 38 ff ff ff 	movl   $0xffffffff,0x38(%esp)
 80492da:	ff 
 80492db:	e9 b5 04 00 00       	jmp    8049795 <__vprintf+0x65a>
    }
  if (c->precision >= 0)
 80492e0:	b9 00 00 00 00       	mov    $0x0,%ecx
    c->flags &= ~ZERO;
 80492e5:	83 64 24 30 ef       	andl   $0xffffffef,0x30(%esp)

  /* Parse type. */
  c->type = INT;
 80492ea:	c7 44 24 3c 03 00 00 	movl   $0x3,0x3c(%esp)
 80492f1:	00 
  switch (*format++) 
 80492f2:	8d 73 01             	lea    0x1(%ebx),%esi
 80492f5:	0f b6 03             	movzbl (%ebx),%eax
 80492f8:	8d 50 98             	lea    -0x68(%eax),%edx
 80492fb:	80 fa 12             	cmp    $0x12,%dl
 80492fe:	0f 87 06 01 00 00    	ja     804940a <__vprintf+0x2cf>
 8049304:	0f b6 d2             	movzbl %dl,%edx
 8049307:	ff 24 95 a4 ac 04 08 	jmp    *0x804aca4(,%edx,4)
    {
    case 'h':
      if (*format == 'h') 
 804930e:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 8049312:	3c 68                	cmp    $0x68,%al
 8049314:	75 25                	jne    804933b <__vprintf+0x200>
        {
          format++;
 8049316:	8d 73 02             	lea    0x2(%ebx),%esi
          c->type = CHAR;
 8049319:	c7 44 24 3c 01 00 00 	movl   $0x1,0x3c(%esp)
 8049320:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8049321:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
 8049325:	8d 50 bb             	lea    -0x45(%eax),%edx
 8049328:	80 fa 33             	cmp    $0x33,%dl
 804932b:	0f 87 38 04 00 00    	ja     8049769 <__vprintf+0x62e>
 8049331:	0f b6 d2             	movzbl %dl,%edx
 8049334:	ff 24 95 f0 ac 04 08 	jmp    *0x804acf0(,%edx,4)
        {
          format++;
          c->type = CHAR;
        }
      else
        c->type = SHORT;
 804933b:	c7 44 24 3c 02 00 00 	movl   $0x2,0x3c(%esp)
 8049342:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8049343:	8d 50 bb             	lea    -0x45(%eax),%edx
 8049346:	80 fa 33             	cmp    $0x33,%dl
 8049349:	0f 87 1a 04 00 00    	ja     8049769 <__vprintf+0x62e>
 804934f:	0f b6 d2             	movzbl %dl,%edx
 8049352:	ff 24 95 c0 ad 04 08 	jmp    *0x804adc0(,%edx,4)
      else
        c->type = SHORT;
      break;
      
    case 'j':
      c->type = INTMAX;
 8049359:	c7 44 24 3c 04 00 00 	movl   $0x4,0x3c(%esp)
 8049360:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8049361:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 8049365:	8d 50 bb             	lea    -0x45(%eax),%edx
 8049368:	80 fa 33             	cmp    $0x33,%dl
 804936b:	0f 87 f8 03 00 00    	ja     8049769 <__vprintf+0x62e>
 8049371:	0f b6 d2             	movzbl %dl,%edx
 8049374:	ff 24 95 90 ae 04 08 	jmp    *0x804ae90(,%edx,4)
    case 'j':
      c->type = INTMAX;
      break;

    case 'l':
      if (*format == 'l')
 804937b:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 804937f:	3c 6c                	cmp    $0x6c,%al
 8049381:	75 25                	jne    80493a8 <__vprintf+0x26d>
        {
          format++;
 8049383:	8d 73 02             	lea    0x2(%ebx),%esi
          c->type = LONGLONG;
 8049386:	c7 44 24 3c 06 00 00 	movl   $0x6,0x3c(%esp)
 804938d:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 804938e:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
 8049392:	8d 50 bb             	lea    -0x45(%eax),%edx
 8049395:	80 fa 33             	cmp    $0x33,%dl
 8049398:	0f 87 cb 03 00 00    	ja     8049769 <__vprintf+0x62e>
 804939e:	0f b6 d2             	movzbl %dl,%edx
 80493a1:	ff 24 95 60 af 04 08 	jmp    *0x804af60(,%edx,4)
        {
          format++;
          c->type = LONGLONG;
        }
      else
        c->type = LONG;
 80493a8:	c7 44 24 3c 05 00 00 	movl   $0x5,0x3c(%esp)
 80493af:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 80493b0:	8d 50 bb             	lea    -0x45(%eax),%edx
 80493b3:	80 fa 33             	cmp    $0x33,%dl
 80493b6:	0f 87 ad 03 00 00    	ja     8049769 <__vprintf+0x62e>
 80493bc:	0f b6 d2             	movzbl %dl,%edx
 80493bf:	ff 24 95 30 b0 04 08 	jmp    *0x804b030(,%edx,4)
      else
        c->type = LONG;
      break;

    case 't':
      c->type = PTRDIFFT;
 80493c6:	c7 44 24 3c 07 00 00 	movl   $0x7,0x3c(%esp)
 80493cd:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 80493ce:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 80493d2:	8d 50 bb             	lea    -0x45(%eax),%edx
 80493d5:	80 fa 33             	cmp    $0x33,%dl
 80493d8:	0f 87 8b 03 00 00    	ja     8049769 <__vprintf+0x62e>
 80493de:	0f b6 d2             	movzbl %dl,%edx
 80493e1:	ff 24 95 00 b1 04 08 	jmp    *0x804b100(,%edx,4)
    case 't':
      c->type = PTRDIFFT;
      break;

    case 'z':
      c->type = SIZET;
 80493e8:	c7 44 24 3c 08 00 00 	movl   $0x8,0x3c(%esp)
 80493ef:	00 

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 80493f0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 80493f4:	8d 50 bb             	lea    -0x45(%eax),%edx
 80493f7:	80 fa 33             	cmp    $0x33,%dl
 80493fa:	0f 87 69 03 00 00    	ja     8049769 <__vprintf+0x62e>
 8049400:	0f b6 d2             	movzbl %dl,%edx
 8049403:	ff 24 95 d0 b1 04 08 	jmp    *0x804b1d0(,%edx,4)
 804940a:	8d 50 bb             	lea    -0x45(%eax),%edx
 804940d:	80 fa 33             	cmp    $0x33,%dl
 8049410:	0f 87 51 03 00 00    	ja     8049767 <__vprintf+0x62c>
 8049416:	0f b6 d2             	movzbl %dl,%edx
 8049419:	ff 24 95 a0 b2 04 08 	jmp    *0x804b2a0(,%edx,4)
 8049420:	89 de                	mov    %ebx,%esi
        case 'i': 
          {
            /* Signed integer conversions. */
            intmax_t value;
            
            switch (c.type) 
 8049422:	83 7c 24 3c 08       	cmpl   $0x8,0x3c(%esp)
 8049427:	0f 87 c4 00 00 00    	ja     80494f1 <__vprintf+0x3b6>
 804942d:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 8049431:	ff 24 85 70 b3 04 08 	jmp    *0x804b370(,%eax,4)
              {
              case CHAR: 
                value = (signed char) va_arg (args, int);
 8049438:	0f be 4d 00          	movsbl 0x0(%ebp),%ecx
 804943c:	89 c8                	mov    %ecx,%eax
 804943e:	99                   	cltd   
 804943f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 8049443:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8049447:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 804944a:	e9 bb 00 00 00       	jmp    804950a <__vprintf+0x3cf>
              case SHORT:
                value = (short) va_arg (args, int);
 804944f:	0f bf 4d 00          	movswl 0x0(%ebp),%ecx
 8049453:	89 c8                	mov    %ecx,%eax
 8049455:	99                   	cltd   
 8049456:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804945a:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804945e:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 8049461:	e9 a4 00 00 00       	jmp    804950a <__vprintf+0x3cf>
              case INT:
                value = va_arg (args, int);
 8049466:	8b 4d 00             	mov    0x0(%ebp),%ecx
 8049469:	89 c8                	mov    %ecx,%eax
 804946b:	99                   	cltd   
 804946c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 8049470:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8049474:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 8049477:	e9 8e 00 00 00       	jmp    804950a <__vprintf+0x3cf>
              case INTMAX:
                value = va_arg (args, intmax_t);
 804947c:	8b 45 00             	mov    0x0(%ebp),%eax
 804947f:	8b 55 04             	mov    0x4(%ebp),%edx
 8049482:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049486:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804948a:	8d 6d 08             	lea    0x8(%ebp),%ebp
                break;
 804948d:	eb 7b                	jmp    804950a <__vprintf+0x3cf>
              case LONG:
                value = va_arg (args, long);
 804948f:	8b 4d 00             	mov    0x0(%ebp),%ecx
 8049492:	89 c8                	mov    %ecx,%eax
 8049494:	99                   	cltd   
 8049495:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 8049499:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804949d:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 80494a0:	eb 68                	jmp    804950a <__vprintf+0x3cf>
              case LONGLONG:
                value = va_arg (args, long long);
 80494a2:	8b 45 00             	mov    0x0(%ebp),%eax
 80494a5:	8b 55 04             	mov    0x4(%ebp),%edx
 80494a8:	89 44 24 08          	mov    %eax,0x8(%esp)
 80494ac:	89 54 24 0c          	mov    %edx,0xc(%esp)
 80494b0:	8d 6d 08             	lea    0x8(%ebp),%ebp
                break;
 80494b3:	eb 55                	jmp    804950a <__vprintf+0x3cf>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
 80494b5:	8b 4d 00             	mov    0x0(%ebp),%ecx
 80494b8:	89 c8                	mov    %ecx,%eax
 80494ba:	99                   	cltd   
 80494bb:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 80494bf:	89 54 24 0c          	mov    %edx,0xc(%esp)
 80494c3:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 80494c6:	eb 42                	jmp    804950a <__vprintf+0x3cf>
              case SIZET:
                value = va_arg (args, size_t);
 80494c8:	8d 45 04             	lea    0x4(%ebp),%eax
 80494cb:	8b 7d 00             	mov    0x0(%ebp),%edi
 80494ce:	bd 00 00 00 00       	mov    $0x0,%ebp
 80494d3:	89 7c 24 08          	mov    %edi,0x8(%esp)
 80494d7:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
 80494db:	89 c5                	mov    %eax,%ebp
                if (value > SIZE_MAX / 2)
 80494dd:	81 ff ff ff ff 7f    	cmp    $0x7fffffff,%edi
 80494e3:	76 25                	jbe    804950a <__vprintf+0x3cf>
                  value = value - SIZE_MAX - 1;
 80494e5:	83 44 24 08 00       	addl   $0x0,0x8(%esp)
 80494ea:	83 54 24 0c ff       	adcl   $0xffffffff,0xc(%esp)
 80494ef:	eb 19                	jmp    804950a <__vprintf+0x3cf>
                break;
              default:
                NOT_REACHED ();
 80494f1:	68 b0 ba 04 08       	push   $0x804bab0
 80494f6:	68 94 b3 04 08       	push   $0x804b394
 80494fb:	68 dc 00 00 00       	push   $0xdc
 8049500:	68 7f b5 04 08       	push   $0x804b57f
 8049505:	e8 f7 13 00 00       	call   804a901 <debug_panic>
              }

            format_integer (value < 0 ? -value : value,
 804950a:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 804950e:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
 8049512:	89 da                	mov    %ebx,%edx
 8049514:	c1 fa 1f             	sar    $0x1f,%edx
 8049517:	89 d7                	mov    %edx,%edi
 8049519:	31 cf                	xor    %ecx,%edi
 804951b:	89 7c 24 10          	mov    %edi,0x10(%esp)
 804951f:	89 d7                	mov    %edx,%edi
 8049521:	33 7c 24 0c          	xor    0xc(%esp),%edi
 8049525:	89 7c 24 14          	mov    %edi,0x14(%esp)
 8049529:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 804952d:	8b 5c 24 14          	mov    0x14(%esp),%ebx
 8049531:	29 d1                	sub    %edx,%ecx
 8049533:	19 d3                	sbb    %edx,%ebx
 8049535:	89 c8                	mov    %ecx,%eax
 8049537:	89 da                	mov    %ebx,%edx
 8049539:	83 ec 0c             	sub    $0xc,%esp
 804953c:	ff 74 24 78          	pushl  0x78(%esp)
 8049540:	ff 74 24 78          	pushl  0x78(%esp)
 8049544:	8d 7c 24 44          	lea    0x44(%esp),%edi
 8049548:	57                   	push   %edi
 8049549:	68 d0 b3 04 08       	push   $0x804b3d0
 804954e:	8b 4c 24 28          	mov    0x28(%esp),%ecx
 8049552:	c1 e9 1f             	shr    $0x1f,%ecx
 8049555:	51                   	push   %ecx
 8049556:	b9 01 00 00 00       	mov    $0x1,%ecx
 804955b:	e8 20 f8 ff ff       	call   8048d80 <format_integer>
                            true, value < 0, &base_d, &c, output, aux);
          }
          break;
 8049560:	83 c4 20             	add    $0x20,%esp
 8049563:	89 f3                	mov    %esi,%ebx
 8049565:	e9 1a 02 00 00       	jmp    8049784 <__vprintf+0x649>
                break;
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
                break;
              case INT:
                value = va_arg (args, unsigned);
 804956a:	8b 75 00             	mov    0x0(%ebp),%esi
 804956d:	bf 00 00 00 00       	mov    $0x0,%edi
 8049572:	89 74 24 18          	mov    %esi,0x18(%esp)
 8049576:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
 804957a:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 804957d:	e9 9d 00 00 00       	jmp    804961f <__vprintf+0x4e4>
            const struct integer_base *b;

            switch (c.type) 
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
 8049582:	0f b6 55 00          	movzbl 0x0(%ebp),%edx
 8049586:	89 54 24 18          	mov    %edx,0x18(%esp)
 804958a:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 8049591:	00 
                break;
 8049592:	89 f3                	mov    %esi,%ebx
            const struct integer_base *b;

            switch (c.type) 
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
 8049594:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 8049597:	e9 83 00 00 00       	jmp    804961f <__vprintf+0x4e4>
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
 804959c:	0f b7 55 00          	movzwl 0x0(%ebp),%edx
 80495a0:	89 54 24 18          	mov    %edx,0x18(%esp)
 80495a4:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 80495ab:	00 
                break;
 80495ac:	89 f3                	mov    %esi,%ebx
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
                break;
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
 80495ae:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 80495b1:	eb 6c                	jmp    804961f <__vprintf+0x4e4>
              case INT:
                value = va_arg (args, unsigned);
                break;
              case INTMAX:
                value = va_arg (args, uintmax_t);
 80495b3:	8b 4d 00             	mov    0x0(%ebp),%ecx
 80495b6:	8b 5d 04             	mov    0x4(%ebp),%ebx
 80495b9:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 80495bd:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
                break;
 80495c1:	89 f3                	mov    %esi,%ebx
                break;
              case INT:
                value = va_arg (args, unsigned);
                break;
              case INTMAX:
                value = va_arg (args, uintmax_t);
 80495c3:	8d 6d 08             	lea    0x8(%ebp),%ebp
                break;
 80495c6:	eb 57                	jmp    804961f <__vprintf+0x4e4>
              case LONG:
                value = va_arg (args, unsigned long);
 80495c8:	8b 4d 00             	mov    0x0(%ebp),%ecx
 80495cb:	bb 00 00 00 00       	mov    $0x0,%ebx
 80495d0:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 80495d4:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
                break;
 80495d8:	89 f3                	mov    %esi,%ebx
                break;
              case INTMAX:
                value = va_arg (args, uintmax_t);
                break;
              case LONG:
                value = va_arg (args, unsigned long);
 80495da:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
 80495dd:	eb 40                	jmp    804961f <__vprintf+0x4e4>
              case LONGLONG:
                value = va_arg (args, unsigned long long);
 80495df:	8b 4d 00             	mov    0x0(%ebp),%ecx
 80495e2:	8b 5d 04             	mov    0x4(%ebp),%ebx
 80495e5:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 80495e9:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
                break;
 80495ed:	89 f3                	mov    %esi,%ebx
                break;
              case LONG:
                value = va_arg (args, unsigned long);
                break;
              case LONGLONG:
                value = va_arg (args, unsigned long long);
 80495ef:	8d 6d 08             	lea    0x8(%ebp),%ebp
                break;
 80495f2:	eb 2b                	jmp    804961f <__vprintf+0x4e4>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
 80495f4:	8b 7d 00             	mov    0x0(%ebp),%edi
 80495f7:	89 7c 24 18          	mov    %edi,0x18(%esp)
 80495fb:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 8049602:	00 
#endif
                break;
 8049603:	89 f3                	mov    %esi,%ebx
                break;
              case LONGLONG:
                value = va_arg (args, unsigned long long);
                break;
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
 8049605:	8d 6d 04             	lea    0x4(%ebp),%ebp
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
#endif
                break;
 8049608:	eb 15                	jmp    804961f <__vprintf+0x4e4>
              case SIZET:
                value = va_arg (args, size_t);
 804960a:	8b 4d 00             	mov    0x0(%ebp),%ecx
 804960d:	bb 00 00 00 00       	mov    $0x0,%ebx
 8049612:	89 4c 24 18          	mov    %ecx,0x18(%esp)
 8049616:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
                break;
 804961a:	89 f3                	mov    %esi,%ebx
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
#endif
                break;
              case SIZET:
                value = va_arg (args, size_t);
 804961c:	8d 6d 04             	lea    0x4(%ebp),%ebp
                break;
              default:
                NOT_REACHED ();
              }

            switch (*format) 
 804961f:	3c 6f                	cmp    $0x6f,%al
 8049621:	74 3b                	je     804965e <__vprintf+0x523>
 8049623:	3c 6f                	cmp    $0x6f,%al
 8049625:	7f 06                	jg     804962d <__vprintf+0x4f2>
 8049627:	3c 58                	cmp    $0x58,%al
 8049629:	74 13                	je     804963e <__vprintf+0x503>
 804962b:	eb 18                	jmp    8049645 <__vprintf+0x50a>
 804962d:	3c 75                	cmp    $0x75,%al
 804962f:	74 06                	je     8049637 <__vprintf+0x4fc>
 8049631:	3c 78                	cmp    $0x78,%al
 8049633:	74 30                	je     8049665 <__vprintf+0x52a>
 8049635:	eb 0e                	jmp    8049645 <__vprintf+0x50a>
              {
              case 'o': b = &base_o; break;
              case 'u': b = &base_d; break;
 8049637:	b8 d0 b3 04 08       	mov    $0x804b3d0,%eax
 804963c:	eb 2c                	jmp    804966a <__vprintf+0x52f>
              case 'x': b = &base_x; break;
              case 'X': b = &base_X; break;
 804963e:	b8 a0 b3 04 08       	mov    $0x804b3a0,%eax
 8049643:	eb 25                	jmp    804966a <__vprintf+0x52f>
              default: NOT_REACHED ();
 8049645:	68 b0 ba 04 08       	push   $0x804bab0
 804964a:	68 94 b3 04 08       	push   $0x804b394
 804964f:	68 14 01 00 00       	push   $0x114
 8049654:	68 7f b5 04 08       	push   $0x804b57f
 8049659:	e8 a3 12 00 00       	call   804a901 <debug_panic>
                NOT_REACHED ();
              }

            switch (*format) 
              {
              case 'o': b = &base_o; break;
 804965e:	b8 c0 b3 04 08       	mov    $0x804b3c0,%eax
 8049663:	eb 05                	jmp    804966a <__vprintf+0x52f>
              case 'u': b = &base_d; break;
              case 'x': b = &base_x; break;
 8049665:	b8 b0 b3 04 08       	mov    $0x804b3b0,%eax
              case 'X': b = &base_X; break;
              default: NOT_REACHED ();
              }

            format_integer (value, false, false, b, &c, output, aux);
 804966a:	83 ec 0c             	sub    $0xc,%esp
 804966d:	ff 74 24 78          	pushl  0x78(%esp)
 8049671:	ff 74 24 78          	pushl  0x78(%esp)
 8049675:	8d 7c 24 44          	lea    0x44(%esp),%edi
 8049679:	57                   	push   %edi
 804967a:	50                   	push   %eax
 804967b:	6a 00                	push   $0x0
 804967d:	b9 00 00 00 00       	mov    $0x0,%ecx
 8049682:	8b 44 24 38          	mov    0x38(%esp),%eax
 8049686:	8b 54 24 3c          	mov    0x3c(%esp),%edx
 804968a:	e8 f1 f6 ff ff       	call   8048d80 <format_integer>
          }
          break;
 804968f:	83 c4 20             	add    $0x20,%esp
 8049692:	e9 ed 00 00 00       	jmp    8049784 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8049697:	89 de                	mov    %ebx,%esi
          break;

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
 8049699:	8d 7d 04             	lea    0x4(%ebp),%edi
 804969c:	8b 45 00             	mov    0x0(%ebp),%eax
 804969f:	88 44 24 2f          	mov    %al,0x2f(%esp)
            format_string (&ch, 1, &c, output, aux);
 80496a3:	83 ec 08             	sub    $0x8,%esp
 80496a6:	ff 74 24 74          	pushl  0x74(%esp)
 80496aa:	ff 74 24 74          	pushl  0x74(%esp)
 80496ae:	8d 4c 24 40          	lea    0x40(%esp),%ecx
 80496b2:	ba 01 00 00 00       	mov    $0x1,%edx
 80496b7:	8d 44 24 3f          	lea    0x3f(%esp),%eax
 80496bb:	e8 b4 f9 ff ff       	call   8049074 <format_string>
          }
          break;
 80496c0:	83 c4 10             	add    $0x10,%esp
 80496c3:	89 f3                	mov    %esi,%ebx
          break;

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
 80496c5:	89 fd                	mov    %edi,%ebp
            format_string (&ch, 1, &c, output, aux);
          }
          break;
 80496c7:	e9 b8 00 00 00       	jmp    8049784 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 80496cc:	89 de                	mov    %ebx,%esi
          break;

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
 80496ce:	8d 7d 04             	lea    0x4(%ebp),%edi
 80496d1:	8b 5d 00             	mov    0x0(%ebp),%ebx
            if (s == NULL)
              s = "(null)";
 80496d4:	85 db                	test   %ebx,%ebx
 80496d6:	b8 78 b5 04 08       	mov    $0x804b578,%eax
 80496db:	0f 44 d8             	cmove  %eax,%ebx

            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
 80496de:	83 ec 08             	sub    $0x8,%esp
 80496e1:	51                   	push   %ecx
 80496e2:	53                   	push   %ebx
 80496e3:	e8 d9 09 00 00       	call   804a0c1 <strnlen>
 80496e8:	83 c4 08             	add    $0x8,%esp
 80496eb:	ff 74 24 74          	pushl  0x74(%esp)
 80496ef:	ff 74 24 74          	pushl  0x74(%esp)
 80496f3:	8d 4c 24 40          	lea    0x40(%esp),%ecx
 80496f7:	89 c2                	mov    %eax,%edx
 80496f9:	89 d8                	mov    %ebx,%eax
 80496fb:	e8 74 f9 ff ff       	call   8049074 <format_string>
          }
          break;
 8049700:	83 c4 10             	add    $0x10,%esp
 8049703:	89 f3                	mov    %esi,%ebx
          break;

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
 8049705:	89 fd                	mov    %edi,%ebp
            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
          }
          break;
 8049707:	eb 7b                	jmp    8049784 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8049709:	89 de                	mov    %ebx,%esi
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
 804970b:	8d 7d 04             	lea    0x4(%ebp),%edi
 804970e:	8b 45 00             	mov    0x0(%ebp),%eax

            c.flags = POUND;
 8049711:	c7 44 24 30 08 00 00 	movl   $0x8,0x30(%esp)
 8049718:	00 
            format_integer ((uintptr_t) p, false, false,
 8049719:	ba 00 00 00 00       	mov    $0x0,%edx
 804971e:	83 ec 0c             	sub    $0xc,%esp
 8049721:	ff 74 24 78          	pushl  0x78(%esp)
 8049725:	ff 74 24 78          	pushl  0x78(%esp)
 8049729:	8d 4c 24 44          	lea    0x44(%esp),%ecx
 804972d:	51                   	push   %ecx
 804972e:	68 b0 b3 04 08       	push   $0x804b3b0
 8049733:	6a 00                	push   $0x0
 8049735:	b9 00 00 00 00       	mov    $0x0,%ecx
 804973a:	e8 41 f6 ff ff       	call   8048d80 <format_integer>
                            &base_x, &c, output, aux);
          }
          break;
 804973f:	83 c4 20             	add    $0x20,%esp
 8049742:	89 f3                	mov    %esi,%ebx
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
 8049744:	89 fd                	mov    %edi,%ebp

            c.flags = POUND;
            format_integer ((uintptr_t) p, false, false,
                            &base_x, &c, output, aux);
          }
          break;
 8049746:	eb 3c                	jmp    8049784 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8049748:	89 de                	mov    %ebx,%esi
        case 'g':
        case 'G':
        case 'n':
          /* We don't support floating-point arithmetic,
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
 804974a:	0f be c0             	movsbl %al,%eax
 804974d:	50                   	push   %eax
 804974e:	ff 74 24 70          	pushl  0x70(%esp)
 8049752:	ff 74 24 70          	pushl  0x70(%esp)
 8049756:	68 91 b5 04 08       	push   $0x804b591
 804975b:	e8 be f9 ff ff       	call   804911e <__printf>
          break;
 8049760:	83 c4 10             	add    $0x10,%esp
 8049763:	89 f3                	mov    %esi,%ebx
 8049765:	eb 1d                	jmp    8049784 <__vprintf+0x649>

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8049767:	89 de                	mov    %ebx,%esi
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
          break;

        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
 8049769:	0f be c0             	movsbl %al,%eax
 804976c:	50                   	push   %eax
 804976d:	ff 74 24 70          	pushl  0x70(%esp)
 8049771:	ff 74 24 70          	pushl  0x70(%esp)
 8049775:	68 a7 b5 04 08       	push   $0x804b5a7
 804977a:	e8 9f f9 ff ff       	call   804911e <__printf>
          break;
 804977f:	83 c4 10             	add    $0x10,%esp
 8049782:	89 f3                	mov    %esi,%ebx

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
  for (; *format != '\0'; format++)
 8049784:	8d 73 01             	lea    0x1(%ebx),%esi
 8049787:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 804978b:	84 c0                	test   %al,%al
 804978d:	0f 85 c2 f9 ff ff    	jne    8049155 <__vprintf+0x1a>
 8049793:	eb 09                	jmp    804979e <__vprintf+0x663>
            c->precision = c->precision * 10 + *format - '0';
        }
      if (c->precision < 0) 
        c->precision = -1;
    }
  if (c->precision >= 0)
 8049795:	8b 4c 24 38          	mov    0x38(%esp),%ecx
 8049799:	e9 4c fb ff ff       	jmp    80492ea <__vprintf+0x1af>
        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
          break;
        }
    }
}
 804979e:	83 c4 4c             	add    $0x4c,%esp
 80497a1:	5b                   	pop    %ebx
 80497a2:	5e                   	pop    %esi
 80497a3:	5f                   	pop    %edi
 80497a4:	5d                   	pop    %ebp
 80497a5:	c3                   	ret    

080497a6 <vsnprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) 
{
 80497a6:	53                   	push   %ebx
 80497a7:	83 ec 18             	sub    $0x18,%esp
 80497aa:	8b 44 24 24          	mov    0x24(%esp),%eax
 80497ae:	8b 54 24 28          	mov    0x28(%esp),%edx
 80497b2:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
 80497b6:	8b 5c 24 20          	mov    0x20(%esp),%ebx
 80497ba:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  aux.length = 0;
 80497be:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 80497c5:	00 
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
 80497c6:	85 c0                	test   %eax,%eax
 80497c8:	74 24                	je     80497ee <vsnprintf+0x48>
 80497ca:	83 e8 01             	sub    $0x1,%eax
 80497cd:	89 44 24 0c          	mov    %eax,0xc(%esp)

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
 80497d1:	8d 44 24 04          	lea    0x4(%esp),%eax
 80497d5:	50                   	push   %eax
 80497d6:	68 31 8d 04 08       	push   $0x8048d31
 80497db:	51                   	push   %ecx
 80497dc:	52                   	push   %edx
 80497dd:	e8 59 f9 ff ff       	call   804913b <__vprintf>

  /* Add null terminator. */
  if (buf_size > 0)
    *aux.p = '\0';
 80497e2:	8b 44 24 14          	mov    0x14(%esp),%eax
 80497e6:	c6 00 00             	movb   $0x0,(%eax)
 80497e9:	83 c4 10             	add    $0x10,%esp
 80497ec:	eb 1c                	jmp    804980a <vsnprintf+0x64>
{
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
  aux.length = 0;
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
 80497ee:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 80497f5:	00 

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
 80497f6:	8d 44 24 04          	lea    0x4(%esp),%eax
 80497fa:	50                   	push   %eax
 80497fb:	68 31 8d 04 08       	push   $0x8048d31
 8049800:	51                   	push   %ecx
 8049801:	52                   	push   %edx
 8049802:	e8 34 f9 ff ff       	call   804913b <__vprintf>
 8049807:	83 c4 10             	add    $0x10,%esp

  /* Add null terminator. */
  if (buf_size > 0)
    *aux.p = '\0';

  return aux.length;
 804980a:	8b 44 24 08          	mov    0x8(%esp),%eax
}
 804980e:	83 c4 18             	add    $0x18,%esp
 8049811:	5b                   	pop    %ebx
 8049812:	c3                   	ret    

08049813 <snprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
snprintf (char *buffer, size_t buf_size, const char *format, ...) 
{
 8049813:	83 ec 0c             	sub    $0xc,%esp
  va_list args;
  int retval;

  va_start (args, format);
 8049816:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  retval = vsnprintf (buffer, buf_size, format, args);
 804981a:	50                   	push   %eax
 804981b:	ff 74 24 1c          	pushl  0x1c(%esp)
 804981f:	ff 74 24 1c          	pushl  0x1c(%esp)
 8049823:	ff 74 24 1c          	pushl  0x1c(%esp)
 8049827:	e8 7a ff ff ff       	call   80497a6 <vsnprintf>
  va_end (args);

  return retval;
}
 804982c:	83 c4 1c             	add    $0x1c,%esp
 804982f:	c3                   	ret    

08049830 <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
 8049830:	55                   	push   %ebp
 8049831:	57                   	push   %edi
 8049832:	56                   	push   %esi
 8049833:	53                   	push   %ebx
 8049834:	83 ec 1c             	sub    $0x1c,%esp
 8049837:	0f b6 44 24 3c       	movzbl 0x3c(%esp),%eax
 804983c:	88 44 24 0f          	mov    %al,0xf(%esp)
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
 8049840:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
 8049845:	0f 84 cb 01 00 00    	je     8049a16 <hex_dump+0x1e6>
    {
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
 804984b:	8b 74 24 30          	mov    0x30(%esp),%esi
 804984f:	83 e6 0f             	and    $0xf,%esi
      end = per_line;
      if (end - start > size)
 8049852:	b8 10 00 00 00       	mov    $0x10,%eax
 8049857:	29 f0                	sub    %esi,%eax
 8049859:	89 44 24 08          	mov    %eax,0x8(%esp)
 804985d:	3b 44 24 38          	cmp    0x38(%esp),%eax
 8049861:	0f 86 6e 01 00 00    	jbe    80499d5 <hex_dump+0x1a5>
        end = start + size;
 8049867:	89 f7                	mov    %esi,%edi
 8049869:	03 7c 24 38          	add    0x38(%esp),%edi
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
 804986d:	83 ec 04             	sub    $0x4,%esp
 8049870:	8b 44 24 34          	mov    0x34(%esp),%eax
 8049874:	83 e0 f0             	and    $0xfffffff0,%eax
 8049877:	ba 00 00 00 00       	mov    $0x0,%edx
 804987c:	52                   	push   %edx
 804987d:	50                   	push   %eax
 804987e:	68 be b5 04 08       	push   $0x804b5be
 8049883:	e8 7e f8 ff ff       	call   8049106 <printf>
      for (i = 0; i < start; i++)
 8049888:	83 c4 10             	add    $0x10,%esp
 804988b:	85 f6                	test   %esi,%esi
 804988d:	74 26                	je     80498b5 <hex_dump+0x85>
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
      if (end - start > size)
        end = start + size;
      n = end - start;
 804988f:	8b 44 24 38          	mov    0x38(%esp),%eax
 8049893:	89 44 24 08          	mov    %eax,0x8(%esp)
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
 8049897:	bb 00 00 00 00       	mov    $0x0,%ebx
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
 804989c:	83 ec 0c             	sub    $0xc,%esp
 804989f:	68 c6 b5 04 08       	push   $0x804b5c6
 80498a4:	e8 5d f8 ff ff       	call   8049106 <printf>
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
 80498a9:	83 c3 01             	add    $0x1,%ebx
 80498ac:	83 c4 10             	add    $0x10,%esp
 80498af:	39 de                	cmp    %ebx,%esi
 80498b1:	77 e9                	ja     804989c <hex_dump+0x6c>
 80498b3:	eb 0a                	jmp    80498bf <hex_dump+0x8f>
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
      if (end - start > size)
        end = start + size;
      n = end - start;
 80498b5:	8b 44 24 38          	mov    0x38(%esp),%eax
 80498b9:	89 44 24 08          	mov    %eax,0x8(%esp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
 80498bd:	89 f3                	mov    %esi,%ebx
        printf ("   ");
      for (; i < end; i++) 
 80498bf:	39 df                	cmp    %ebx,%edi
 80498c1:	76 34                	jbe    80498f7 <hex_dump+0xc7>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
 80498c3:	8b 6c 24 34          	mov    0x34(%esp),%ebp
 80498c7:	29 f5                	sub    %esi,%ebp
      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
 80498c9:	83 fb 07             	cmp    $0x7,%ebx
 80498cc:	b8 20 00 00 00       	mov    $0x20,%eax
 80498d1:	b9 2d 00 00 00       	mov    $0x2d,%ecx
 80498d6:	0f 44 c1             	cmove  %ecx,%eax
 80498d9:	83 ec 04             	sub    $0x4,%esp
 80498dc:	50                   	push   %eax
 80498dd:	0f b6 44 1d 00       	movzbl 0x0(%ebp,%ebx,1),%eax
 80498e2:	50                   	push   %eax
 80498e3:	68 ca b5 04 08       	push   $0x804b5ca
 80498e8:	e8 19 f8 ff ff       	call   8049106 <printf>

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
 80498ed:	83 c3 01             	add    $0x1,%ebx
 80498f0:	83 c4 10             	add    $0x10,%esp
 80498f3:	39 fb                	cmp    %edi,%ebx
 80498f5:	72 d2                	jb     80498c9 <hex_dump+0x99>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
 80498f7:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
 80498fc:	0f 84 ae 00 00 00    	je     80499b0 <hex_dump+0x180>
        {
          for (; i < per_line; i++)
 8049902:	83 fb 0f             	cmp    $0xf,%ebx
 8049905:	77 18                	ja     804991f <hex_dump+0xef>
            printf ("   ");
 8049907:	83 ec 0c             	sub    $0xc,%esp
 804990a:	68 c6 b5 04 08       	push   $0x804b5c6
 804990f:	e8 f2 f7 ff ff       	call   8049106 <printf>
      for (; i < end; i++) 
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
        {
          for (; i < per_line; i++)
 8049914:	83 c3 01             	add    $0x1,%ebx
 8049917:	83 c4 10             	add    $0x10,%esp
 804991a:	83 fb 10             	cmp    $0x10,%ebx
 804991d:	75 e8                	jne    8049907 <hex_dump+0xd7>
            printf ("   ");
          printf ("|");
 804991f:	83 ec 0c             	sub    $0xc,%esp
 8049922:	6a 7c                	push   $0x7c
 8049924:	e8 ea 11 00 00       	call   804ab13 <putchar>
          for (i = 0; i < start; i++)
 8049929:	83 c4 10             	add    $0x10,%esp
 804992c:	85 f6                	test   %esi,%esi
 804992e:	0f 84 d3 00 00 00    	je     8049a07 <hex_dump+0x1d7>
 8049934:	bb 00 00 00 00       	mov    $0x0,%ebx
            printf (" ");
 8049939:	83 ec 0c             	sub    $0xc,%esp
 804993c:	6a 20                	push   $0x20
 804993e:	e8 d0 11 00 00       	call   804ab13 <putchar>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
 8049943:	83 c3 01             	add    $0x1,%ebx
 8049946:	83 c4 10             	add    $0x10,%esp
 8049949:	39 de                	cmp    %ebx,%esi
 804994b:	75 ec                	jne    8049939 <hex_dump+0x109>
            printf (" ");
          for (; i < end; i++)
 804994d:	39 fe                	cmp    %edi,%esi
 804994f:	73 36                	jae    8049987 <hex_dump+0x157>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
 8049951:	89 f3                	mov    %esi,%ebx
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
 8049953:	8b 6c 24 34          	mov    0x34(%esp),%ebp
 8049957:	29 f5                	sub    %esi,%ebp
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
 8049959:	be 2e 00 00 00       	mov    $0x2e,%esi
                    isprint (buf[i - start]) ? buf[i - start] : '.');
 804995e:	0f b6 44 1d 00       	movzbl 0x0(%ebp,%ebx,1),%eax
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
 8049963:	0f b6 d0             	movzbl %al,%edx
 8049966:	83 ea 20             	sub    $0x20,%edx
 8049969:	0f b6 c0             	movzbl %al,%eax
 804996c:	83 fa 5e             	cmp    $0x5e,%edx
 804996f:	0f 47 c6             	cmova  %esi,%eax
 8049972:	83 ec 0c             	sub    $0xc,%esp
 8049975:	50                   	push   %eax
 8049976:	e8 98 11 00 00       	call   804ab13 <putchar>
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
 804997b:	83 c3 01             	add    $0x1,%ebx
 804997e:	83 c4 10             	add    $0x10,%esp
 8049981:	39 fb                	cmp    %edi,%ebx
 8049983:	72 d9                	jb     804995e <hex_dump+0x12e>
 8049985:	eb 02                	jmp    8049989 <hex_dump+0x159>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
 8049987:	89 f3                	mov    %esi,%ebx
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
 8049989:	83 fb 0f             	cmp    $0xf,%ebx
 804998c:	77 15                	ja     80499a3 <hex_dump+0x173>
            printf (" ");
 804998e:	83 ec 0c             	sub    $0xc,%esp
 8049991:	6a 20                	push   $0x20
 8049993:	e8 7b 11 00 00       	call   804ab13 <putchar>
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
 8049998:	83 c3 01             	add    $0x1,%ebx
 804999b:	83 c4 10             	add    $0x10,%esp
 804999e:	83 fb 0f             	cmp    $0xf,%ebx
 80499a1:	76 eb                	jbe    804998e <hex_dump+0x15e>
            printf (" ");
          printf ("|");
 80499a3:	83 ec 0c             	sub    $0xc,%esp
 80499a6:	6a 7c                	push   $0x7c
 80499a8:	e8 66 11 00 00       	call   804ab13 <putchar>
 80499ad:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
 80499b0:	83 ec 0c             	sub    $0xc,%esp
 80499b3:	6a 0a                	push   $0xa
 80499b5:	e8 59 11 00 00       	call   804ab13 <putchar>

      ofs += n;
 80499ba:	8b 44 24 18          	mov    0x18(%esp),%eax
 80499be:	01 44 24 40          	add    %eax,0x40(%esp)
      buf += n;
 80499c2:	01 44 24 44          	add    %eax,0x44(%esp)
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
 80499c6:	83 c4 10             	add    $0x10,%esp
 80499c9:	29 44 24 38          	sub    %eax,0x38(%esp)
 80499cd:	0f 85 78 fe ff ff    	jne    804984b <hex_dump+0x1b>
 80499d3:	eb 41                	jmp    8049a16 <hex_dump+0x1e6>
      if (end - start > size)
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
 80499d5:	83 ec 04             	sub    $0x4,%esp
 80499d8:	8b 44 24 34          	mov    0x34(%esp),%eax
 80499dc:	83 e0 f0             	and    $0xfffffff0,%eax
 80499df:	ba 00 00 00 00       	mov    $0x0,%edx
 80499e4:	52                   	push   %edx
 80499e5:	50                   	push   %eax
 80499e6:	68 be b5 04 08       	push   $0x804b5be
 80499eb:	e8 16 f7 ff ff       	call   8049106 <printf>
      for (i = 0; i < start; i++)
 80499f0:	83 c4 10             	add    $0x10,%esp
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
      end = per_line;
 80499f3:	bf 10 00 00 00       	mov    $0x10,%edi
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
 80499f8:	89 f3                	mov    %esi,%ebx
 80499fa:	85 f6                	test   %esi,%esi
 80499fc:	0f 84 c1 fe ff ff    	je     80498c3 <hex_dump+0x93>
 8049a02:	e9 90 fe ff ff       	jmp    8049897 <hex_dump+0x67>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
 8049a07:	89 f3                	mov    %esi,%ebx
            printf (" ");
          for (; i < end; i++)
 8049a09:	85 ff                	test   %edi,%edi
 8049a0b:	0f 85 42 ff ff ff    	jne    8049953 <hex_dump+0x123>
 8049a11:	e9 78 ff ff ff       	jmp    804998e <hex_dump+0x15e>

      ofs += n;
      buf += n;
      size -= n;
    }
}
 8049a16:	83 c4 1c             	add    $0x1c,%esp
 8049a19:	5b                   	pop    %ebx
 8049a1a:	5e                   	pop    %esi
 8049a1b:	5f                   	pop    %edi
 8049a1c:	5d                   	pop    %ebp
 8049a1d:	c3                   	ret    

08049a1e <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
 8049a1e:	57                   	push   %edi
 8049a1f:	56                   	push   %esi
 8049a20:	83 ec 04             	sub    $0x4,%esp
 8049a23:	8b 74 24 10          	mov    0x10(%esp),%esi
 8049a27:	8b 7c 24 14          	mov    0x14(%esp),%edi
  if (size == 1)
 8049a2b:	89 f0                	mov    %esi,%eax
 8049a2d:	83 f0 01             	xor    $0x1,%eax
 8049a30:	09 f8                	or     %edi,%eax
 8049a32:	74 22                	je     8049a56 <print_human_readable_size+0x38>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
 8049a34:	83 ff 00             	cmp    $0x0,%edi
 8049a37:	77 0d                	ja     8049a46 <print_human_readable_size+0x28>
 8049a39:	b9 cc cb 04 08       	mov    $0x804cbcc,%ecx
 8049a3e:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
 8049a44:	76 46                	jbe    8049a8c <print_human_readable_size+0x6e>
 8049a46:	b9 cc cb 04 08       	mov    $0x804cbcc,%ecx
 8049a4b:	83 3d d0 cb 04 08 00 	cmpl   $0x0,0x804cbd0
 8049a52:	75 14                	jne    8049a68 <print_human_readable_size+0x4a>
 8049a54:	eb 36                	jmp    8049a8c <print_human_readable_size+0x6e>
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
  if (size == 1)
    printf ("1 byte");
 8049a56:	83 ec 0c             	sub    $0xc,%esp
 8049a59:	68 d3 b5 04 08       	push   $0x804b5d3
 8049a5e:	e8 a3 f6 ff ff       	call   8049106 <printf>
 8049a63:	83 c4 10             	add    $0x10,%esp
 8049a66:	eb 35                	jmp    8049a9d <print_human_readable_size+0x7f>
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
        size /= 1024;
 8049a68:	89 f0                	mov    %esi,%eax
 8049a6a:	89 fa                	mov    %edi,%edx
 8049a6c:	0f ac f8 0a          	shrd   $0xa,%edi,%eax
 8049a70:	c1 ea 0a             	shr    $0xa,%edx
 8049a73:	89 c6                	mov    %eax,%esi
 8049a75:	89 d7                	mov    %edx,%edi
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
 8049a77:	83 c1 04             	add    $0x4,%ecx
 8049a7a:	83 fa 00             	cmp    $0x0,%edx
 8049a7d:	77 07                	ja     8049a86 <print_human_readable_size+0x68>
 8049a7f:	3d ff 03 00 00       	cmp    $0x3ff,%eax
 8049a84:	76 06                	jbe    8049a8c <print_human_readable_size+0x6e>
 8049a86:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
 8049a8a:	75 dc                	jne    8049a68 <print_human_readable_size+0x4a>
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
 8049a8c:	ff 31                	pushl  (%ecx)
 8049a8e:	57                   	push   %edi
 8049a8f:	56                   	push   %esi
 8049a90:	68 da b5 04 08       	push   $0x804b5da
 8049a95:	e8 6c f6 ff ff       	call   8049106 <printf>
 8049a9a:	83 c4 10             	add    $0x10,%esp
    }
}
 8049a9d:	83 c4 04             	add    $0x4,%esp
 8049aa0:	5e                   	pop    %esi
 8049aa1:	5f                   	pop    %edi
 8049aa2:	c3                   	ret    

08049aa3 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
 8049aa3:	56                   	push   %esi
 8049aa4:	53                   	push   %ebx
 8049aa5:	83 ec 04             	sub    $0x4,%esp
 8049aa8:	8b 44 24 10          	mov    0x10(%esp),%eax
 8049aac:	8b 74 24 14          	mov    0x14(%esp),%esi
 8049ab0:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
 8049ab4:	85 db                	test   %ebx,%ebx
 8049ab6:	0f 94 c2             	sete   %dl
 8049ab9:	85 c0                	test   %eax,%eax
 8049abb:	75 22                	jne    8049adf <memcpy+0x3c>
 8049abd:	84 d2                	test   %dl,%dl
 8049abf:	75 1e                	jne    8049adf <memcpy+0x3c>
 8049ac1:	83 ec 0c             	sub    $0xc,%esp
 8049ac4:	68 2a b6 04 08       	push   $0x804b62a
 8049ac9:	68 43 b6 04 08       	push   $0x804b643
 8049ace:	68 34 b4 04 08       	push   $0x804b434
 8049ad3:	6a 0c                	push   $0xc
 8049ad5:	68 5a b6 04 08       	push   $0x804b65a
 8049ada:	e8 22 0e 00 00       	call   804a901 <debug_panic>
  ASSERT (src != NULL || size == 0);
 8049adf:	85 f6                	test   %esi,%esi
 8049ae1:	75 04                	jne    8049ae7 <memcpy+0x44>
 8049ae3:	84 d2                	test   %dl,%dl
 8049ae5:	74 0b                	je     8049af2 <memcpy+0x4f>

  while (size-- > 0)
 8049ae7:	ba 00 00 00 00       	mov    $0x0,%edx
 8049aec:	85 db                	test   %ebx,%ebx
 8049aee:	75 20                	jne    8049b10 <memcpy+0x6d>
 8049af0:	eb 2c                	jmp    8049b1e <memcpy+0x7b>
{
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);
 8049af2:	83 ec 0c             	sub    $0xc,%esp
 8049af5:	68 6d b6 04 08       	push   $0x804b66d
 8049afa:	68 43 b6 04 08       	push   $0x804b643
 8049aff:	68 34 b4 04 08       	push   $0x804b434
 8049b04:	6a 0d                	push   $0xd
 8049b06:	68 5a b6 04 08       	push   $0x804b65a
 8049b0b:	e8 f1 0d 00 00       	call   804a901 <debug_panic>

  while (size-- > 0)
    *dst++ = *src++;
 8049b10:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
 8049b14:	88 0c 10             	mov    %cl,(%eax,%edx,1)
 8049b17:	83 c2 01             	add    $0x1,%edx
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
 8049b1a:	39 da                	cmp    %ebx,%edx
 8049b1c:	75 f2                	jne    8049b10 <memcpy+0x6d>
    *dst++ = *src++;

  return dst_;
}
 8049b1e:	83 c4 04             	add    $0x4,%esp
 8049b21:	5b                   	pop    %ebx
 8049b22:	5e                   	pop    %esi
 8049b23:	c3                   	ret    

08049b24 <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
 8049b24:	57                   	push   %edi
 8049b25:	56                   	push   %esi
 8049b26:	53                   	push   %ebx
 8049b27:	8b 44 24 10          	mov    0x10(%esp),%eax
 8049b2b:	8b 5c 24 14          	mov    0x14(%esp),%ebx
 8049b2f:	8b 7c 24 18          	mov    0x18(%esp),%edi
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
 8049b33:	85 ff                	test   %edi,%edi
 8049b35:	0f 94 c2             	sete   %dl
 8049b38:	85 c0                	test   %eax,%eax
 8049b3a:	75 22                	jne    8049b5e <memmove+0x3a>
 8049b3c:	84 d2                	test   %dl,%dl
 8049b3e:	75 1e                	jne    8049b5e <memmove+0x3a>
 8049b40:	83 ec 0c             	sub    $0xc,%esp
 8049b43:	68 2a b6 04 08       	push   $0x804b62a
 8049b48:	68 43 b6 04 08       	push   $0x804b643
 8049b4d:	68 2c b4 04 08       	push   $0x804b42c
 8049b52:	6a 1d                	push   $0x1d
 8049b54:	68 5a b6 04 08       	push   $0x804b65a
 8049b59:	e8 a3 0d 00 00       	call   804a901 <debug_panic>
  ASSERT (src != NULL || size == 0);
 8049b5e:	85 db                	test   %ebx,%ebx
 8049b60:	75 22                	jne    8049b84 <memmove+0x60>
 8049b62:	84 d2                	test   %dl,%dl
 8049b64:	75 1e                	jne    8049b84 <memmove+0x60>
 8049b66:	83 ec 0c             	sub    $0xc,%esp
 8049b69:	68 6d b6 04 08       	push   $0x804b66d
 8049b6e:	68 43 b6 04 08       	push   $0x804b643
 8049b73:	68 2c b4 04 08       	push   $0x804b42c
 8049b78:	6a 1e                	push   $0x1e
 8049b7a:	68 5a b6 04 08       	push   $0x804b65a
 8049b7f:	e8 7d 0d 00 00       	call   804a901 <debug_panic>

  if (dst < src) 
 8049b84:	39 d8                	cmp    %ebx,%eax
 8049b86:	73 1b                	jae    8049ba3 <memmove+0x7f>
    {
      while (size-- > 0)
 8049b88:	85 ff                	test   %edi,%edi
 8049b8a:	74 38                	je     8049bc4 <memmove+0xa0>
 8049b8c:	ba 00 00 00 00       	mov    $0x0,%edx
        *dst++ = *src++;
 8049b91:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
 8049b95:	88 0c 10             	mov    %cl,(%eax,%edx,1)
 8049b98:	83 c2 01             	add    $0x1,%edx
  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
    {
      while (size-- > 0)
 8049b9b:	39 fa                	cmp    %edi,%edx
 8049b9d:	75 f2                	jne    8049b91 <memmove+0x6d>
 8049b9f:	01 f8                	add    %edi,%eax
 8049ba1:	eb 21                	jmp    8049bc4 <memmove+0xa0>
        *dst++ = *src++;
    }
  else 
    {
      dst += size;
 8049ba3:	8d 34 38             	lea    (%eax,%edi,1),%esi
      src += size;
      while (size-- > 0)
 8049ba6:	8d 57 ff             	lea    -0x1(%edi),%edx
 8049ba9:	85 ff                	test   %edi,%edi
 8049bab:	74 15                	je     8049bc2 <memmove+0x9e>
 8049bad:	89 f0                	mov    %esi,%eax
 8049baf:	29 f8                	sub    %edi,%eax
        *--dst = *--src;
 8049bb1:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
 8049bb5:	88 0c 10             	mov    %cl,(%eax,%edx,1)
    }
  else 
    {
      dst += size;
      src += size;
      while (size-- > 0)
 8049bb8:	83 ea 01             	sub    $0x1,%edx
 8049bbb:	83 fa ff             	cmp    $0xffffffff,%edx
 8049bbe:	75 ed                	jne    8049bad <memmove+0x89>
 8049bc0:	eb 02                	jmp    8049bc4 <memmove+0xa0>
      while (size-- > 0)
        *dst++ = *src++;
    }
  else 
    {
      dst += size;
 8049bc2:	89 f0                	mov    %esi,%eax
      while (size-- > 0)
        *--dst = *--src;
    }

  return dst;
}
 8049bc4:	5b                   	pop    %ebx
 8049bc5:	5e                   	pop    %esi
 8049bc6:	5f                   	pop    %edi
 8049bc7:	c3                   	ret    

08049bc8 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
 8049bc8:	57                   	push   %edi
 8049bc9:	56                   	push   %esi
 8049bca:	53                   	push   %ebx
 8049bcb:	8b 5c 24 10          	mov    0x10(%esp),%ebx
 8049bcf:	8b 74 24 14          	mov    0x14(%esp),%esi
 8049bd3:	8b 44 24 18          	mov    0x18(%esp),%eax
  const unsigned char *a = a_;
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
 8049bd7:	85 c0                	test   %eax,%eax
 8049bd9:	0f 94 c2             	sete   %dl
 8049bdc:	85 db                	test   %ebx,%ebx
 8049bde:	75 22                	jne    8049c02 <memcmp+0x3a>
 8049be0:	84 d2                	test   %dl,%dl
 8049be2:	75 1e                	jne    8049c02 <memcmp+0x3a>
 8049be4:	83 ec 0c             	sub    $0xc,%esp
 8049be7:	68 86 b6 04 08       	push   $0x804b686
 8049bec:	68 43 b6 04 08       	push   $0x804b643
 8049bf1:	68 24 b4 04 08       	push   $0x804b424
 8049bf6:	6a 3a                	push   $0x3a
 8049bf8:	68 5a b6 04 08       	push   $0x804b65a
 8049bfd:	e8 ff 0c 00 00       	call   804a901 <debug_panic>
  ASSERT (b != NULL || size == 0);
 8049c02:	85 f6                	test   %esi,%esi
 8049c04:	75 04                	jne    8049c0a <memcmp+0x42>
 8049c06:	84 d2                	test   %dl,%dl
 8049c08:	74 18                	je     8049c22 <memcmp+0x5a>

  for (; size-- > 0; a++, b++)
 8049c0a:	8d 78 ff             	lea    -0x1(%eax),%edi
 8049c0d:	85 c0                	test   %eax,%eax
 8049c0f:	74 56                	je     8049c67 <memcmp+0x9f>
    if (*a != *b)
 8049c11:	0f b6 13             	movzbl (%ebx),%edx
 8049c14:	0f b6 0e             	movzbl (%esi),%ecx
 8049c17:	38 ca                	cmp    %cl,%dl
 8049c19:	75 35                	jne    8049c50 <memcmp+0x88>
 8049c1b:	b8 00 00 00 00       	mov    $0x0,%eax
 8049c20:	eb 3a                	jmp    8049c5c <memcmp+0x94>
{
  const unsigned char *a = a_;
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);
 8049c22:	83 ec 0c             	sub    $0xc,%esp
 8049c25:	68 9d b6 04 08       	push   $0x804b69d
 8049c2a:	68 43 b6 04 08       	push   $0x804b643
 8049c2f:	68 24 b4 04 08       	push   $0x804b424
 8049c34:	6a 3b                	push   $0x3b
 8049c36:	68 5a b6 04 08       	push   $0x804b65a
 8049c3b:	e8 c1 0c 00 00       	call   804a901 <debug_panic>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
 8049c40:	0f b6 54 03 01       	movzbl 0x1(%ebx,%eax,1),%edx
 8049c45:	83 c0 01             	add    $0x1,%eax
 8049c48:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
 8049c4c:	38 ca                	cmp    %cl,%dl
 8049c4e:	74 0c                	je     8049c5c <memcmp+0x94>
      return *a > *b ? +1 : -1;
 8049c50:	38 d1                	cmp    %dl,%cl
 8049c52:	19 c0                	sbb    %eax,%eax
 8049c54:	83 e0 02             	and    $0x2,%eax
 8049c57:	83 e8 01             	sub    $0x1,%eax
 8049c5a:	eb 10                	jmp    8049c6c <memcmp+0xa4>
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
 8049c5c:	39 f8                	cmp    %edi,%eax
 8049c5e:	75 e0                	jne    8049c40 <memcmp+0x78>
    if (*a != *b)
      return *a > *b ? +1 : -1;
  return 0;
 8049c60:	b8 00 00 00 00       	mov    $0x0,%eax
 8049c65:	eb 05                	jmp    8049c6c <memcmp+0xa4>
 8049c67:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049c6c:	5b                   	pop    %ebx
 8049c6d:	5e                   	pop    %esi
 8049c6e:	5f                   	pop    %edi
 8049c6f:	c3                   	ret    

08049c70 <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
 8049c70:	83 ec 0c             	sub    $0xc,%esp
 8049c73:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 8049c77:	8b 54 24 14          	mov    0x14(%esp),%edx
  const unsigned char *a = (const unsigned char *) a_;
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
 8049c7b:	85 c9                	test   %ecx,%ecx
 8049c7d:	75 1e                	jne    8049c9d <strcmp+0x2d>
 8049c7f:	83 ec 0c             	sub    $0xc,%esp
 8049c82:	68 b4 b6 04 08       	push   $0x804b6b4
 8049c87:	68 43 b6 04 08       	push   $0x804b643
 8049c8c:	68 1c b4 04 08       	push   $0x804b41c
 8049c91:	6a 4e                	push   $0x4e
 8049c93:	68 5a b6 04 08       	push   $0x804b65a
 8049c98:	e8 64 0c 00 00       	call   804a901 <debug_panic>
  ASSERT (b != NULL);
 8049c9d:	85 d2                	test   %edx,%edx
 8049c9f:	74 0d                	je     8049cae <strcmp+0x3e>

  while (*a != '\0' && *a == *b) 
 8049ca1:	0f b6 01             	movzbl (%ecx),%eax
 8049ca4:	84 c0                	test   %al,%al
 8049ca6:	74 35                	je     8049cdd <strcmp+0x6d>
 8049ca8:	3a 02                	cmp    (%edx),%al
 8049caa:	74 20                	je     8049ccc <strcmp+0x5c>
 8049cac:	eb 2f                	jmp    8049cdd <strcmp+0x6d>
{
  const unsigned char *a = (const unsigned char *) a_;
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);
 8049cae:	83 ec 0c             	sub    $0xc,%esp
 8049cb1:	68 be b6 04 08       	push   $0x804b6be
 8049cb6:	68 43 b6 04 08       	push   $0x804b643
 8049cbb:	68 1c b4 04 08       	push   $0x804b41c
 8049cc0:	6a 4f                	push   $0x4f
 8049cc2:	68 5a b6 04 08       	push   $0x804b65a
 8049cc7:	e8 35 0c 00 00       	call   804a901 <debug_panic>

  while (*a != '\0' && *a == *b) 
    {
      a++;
 8049ccc:	83 c1 01             	add    $0x1,%ecx
      b++;
 8049ccf:	83 c2 01             	add    $0x1,%edx
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
 8049cd2:	0f b6 01             	movzbl (%ecx),%eax
 8049cd5:	84 c0                	test   %al,%al
 8049cd7:	74 04                	je     8049cdd <strcmp+0x6d>
 8049cd9:	3a 02                	cmp    (%edx),%al
 8049cdb:	74 ef                	je     8049ccc <strcmp+0x5c>
    {
      a++;
      b++;
    }

  return *a < *b ? -1 : *a > *b;
 8049cdd:	0f b6 12             	movzbl (%edx),%edx
 8049ce0:	38 c2                	cmp    %al,%dl
 8049ce2:	77 08                	ja     8049cec <strcmp+0x7c>
 8049ce4:	0f 92 c0             	setb   %al
 8049ce7:	0f b6 c0             	movzbl %al,%eax
 8049cea:	eb 05                	jmp    8049cf1 <strcmp+0x81>
 8049cec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
 8049cf1:	83 c4 0c             	add    $0xc,%esp
 8049cf4:	c3                   	ret    

08049cf5 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
 8049cf5:	53                   	push   %ebx
 8049cf6:	83 ec 08             	sub    $0x8,%esp
 8049cf9:	8b 44 24 10          	mov    0x10(%esp),%eax
 8049cfd:	8b 54 24 14          	mov    0x14(%esp),%edx
 8049d01:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  const unsigned char *block = block_;
  unsigned char ch = ch_;
 8049d05:	89 d3                	mov    %edx,%ebx

  ASSERT (block != NULL || size == 0);
 8049d07:	85 c0                	test   %eax,%eax
 8049d09:	75 04                	jne    8049d0f <memchr+0x1a>
 8049d0b:	85 c9                	test   %ecx,%ecx
 8049d0d:	75 0f                	jne    8049d1e <memchr+0x29>

  for (; size-- > 0; block++)
 8049d0f:	85 c9                	test   %ecx,%ecx
 8049d11:	74 3e                	je     8049d51 <memchr+0x5c>
    if (*block == ch)
 8049d13:	3a 10                	cmp    (%eax),%dl
 8049d15:	74 3f                	je     8049d56 <memchr+0x61>
 8049d17:	8d 50 01             	lea    0x1(%eax),%edx
 8049d1a:	01 c1                	add    %eax,%ecx
 8049d1c:	eb 26                	jmp    8049d44 <memchr+0x4f>
memchr (const void *block_, int ch_, size_t size) 
{
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);
 8049d1e:	83 ec 0c             	sub    $0xc,%esp
 8049d21:	68 c8 b6 04 08       	push   $0x804b6c8
 8049d26:	68 43 b6 04 08       	push   $0x804b643
 8049d2b:	68 14 b4 04 08       	push   $0x804b414
 8049d30:	6a 63                	push   $0x63
 8049d32:	68 5a b6 04 08       	push   $0x804b65a
 8049d37:	e8 c5 0b 00 00       	call   804a901 <debug_panic>
 8049d3c:	83 c2 01             	add    $0x1,%edx

  for (; size-- > 0; block++)
    if (*block == ch)
 8049d3f:	3a 5a ff             	cmp    -0x1(%edx),%bl
 8049d42:	74 12                	je     8049d56 <memchr+0x61>
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
 8049d44:	89 d0                	mov    %edx,%eax
 8049d46:	39 ca                	cmp    %ecx,%edx
 8049d48:	75 f2                	jne    8049d3c <memchr+0x47>
    if (*block == ch)
      return (void *) block;

  return NULL;
 8049d4a:	b8 00 00 00 00       	mov    $0x0,%eax
 8049d4f:	eb 05                	jmp    8049d56 <memchr+0x61>
 8049d51:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049d56:	83 c4 08             	add    $0x8,%esp
 8049d59:	5b                   	pop    %ebx
 8049d5a:	c3                   	ret    

08049d5b <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
 8049d5b:	53                   	push   %ebx
 8049d5c:	83 ec 08             	sub    $0x8,%esp
 8049d5f:	8b 44 24 10          	mov    0x10(%esp),%eax
 8049d63:	8b 54 24 14          	mov    0x14(%esp),%edx
  char c = c_;

  ASSERT (string != NULL);
 8049d67:	85 c0                	test   %eax,%eax
 8049d69:	74 0b                	je     8049d76 <strchr+0x1b>
 8049d6b:	89 d1                	mov    %edx,%ecx

  for (;;) 
    if (*string == c)
 8049d6d:	0f b6 18             	movzbl (%eax),%ebx
 8049d70:	38 da                	cmp    %bl,%dl
 8049d72:	75 20                	jne    8049d94 <strchr+0x39>
 8049d74:	eb 40                	jmp    8049db6 <strchr+0x5b>
char *
strchr (const char *string, int c_) 
{
  char c = c_;

  ASSERT (string != NULL);
 8049d76:	83 ec 0c             	sub    $0xc,%esp
 8049d79:	68 e3 b6 04 08       	push   $0x804b6e3
 8049d7e:	68 43 b6 04 08       	push   $0x804b643
 8049d83:	68 0c b4 04 08       	push   $0x804b40c
 8049d88:	6a 75                	push   $0x75
 8049d8a:	68 5a b6 04 08       	push   $0x804b65a
 8049d8f:	e8 6d 0b 00 00       	call   804a901 <debug_panic>

  for (;;) 
    if (*string == c)
      return (char *) string;
    else if (*string == '\0')
 8049d94:	84 db                	test   %bl,%bl
 8049d96:	75 06                	jne    8049d9e <strchr+0x43>
 8049d98:	eb 10                	jmp    8049daa <strchr+0x4f>
 8049d9a:	84 d2                	test   %dl,%dl
 8049d9c:	74 13                	je     8049db1 <strchr+0x56>
      return NULL;
    else
      string++;
 8049d9e:	83 c0 01             	add    $0x1,%eax
  char c = c_;

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
 8049da1:	0f b6 10             	movzbl (%eax),%edx
 8049da4:	38 d1                	cmp    %dl,%cl
 8049da6:	75 f2                	jne    8049d9a <strchr+0x3f>
 8049da8:	eb 0c                	jmp    8049db6 <strchr+0x5b>
      return (char *) string;
    else if (*string == '\0')
      return NULL;
 8049daa:	b8 00 00 00 00       	mov    $0x0,%eax
 8049daf:	eb 05                	jmp    8049db6 <strchr+0x5b>
 8049db1:	b8 00 00 00 00       	mov    $0x0,%eax
    else
      string++;
}
 8049db6:	83 c4 08             	add    $0x8,%esp
 8049db9:	5b                   	pop    %ebx
 8049dba:	c3                   	ret    

08049dbb <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
 8049dbb:	57                   	push   %edi
 8049dbc:	56                   	push   %esi
 8049dbd:	53                   	push   %ebx
 8049dbe:	8b 74 24 10          	mov    0x10(%esp),%esi
 8049dc2:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
 8049dc6:	0f b6 06             	movzbl (%esi),%eax
 8049dc9:	84 c0                	test   %al,%al
 8049dcb:	74 26                	je     8049df3 <strcspn+0x38>
 8049dcd:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (stop, string[length]) != NULL)
 8049dd2:	83 ec 08             	sub    $0x8,%esp
 8049dd5:	0f be c0             	movsbl %al,%eax
 8049dd8:	50                   	push   %eax
 8049dd9:	57                   	push   %edi
 8049dda:	e8 7c ff ff ff       	call   8049d5b <strchr>
 8049ddf:	83 c4 10             	add    $0x10,%esp
 8049de2:	85 c0                	test   %eax,%eax
 8049de4:	75 12                	jne    8049df8 <strcspn+0x3d>
size_t
strcspn (const char *string, const char *stop) 
{
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
 8049de6:	83 c3 01             	add    $0x1,%ebx
 8049de9:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
 8049ded:	84 c0                	test   %al,%al
 8049def:	75 e1                	jne    8049dd2 <strcspn+0x17>
 8049df1:	eb 05                	jmp    8049df8 <strcspn+0x3d>
 8049df3:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (stop, string[length]) != NULL)
      break;
  return length;
}
 8049df8:	89 d8                	mov    %ebx,%eax
 8049dfa:	5b                   	pop    %ebx
 8049dfb:	5e                   	pop    %esi
 8049dfc:	5f                   	pop    %edi
 8049dfd:	c3                   	ret    

08049dfe <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
 8049dfe:	56                   	push   %esi
 8049dff:	53                   	push   %ebx
 8049e00:	83 ec 04             	sub    $0x4,%esp
 8049e03:	8b 5c 24 10          	mov    0x10(%esp),%ebx
 8049e07:	8b 74 24 14          	mov    0x14(%esp),%esi
  for (; *string != '\0'; string++)
 8049e0b:	0f b6 13             	movzbl (%ebx),%edx
 8049e0e:	84 d2                	test   %dl,%dl
 8049e10:	74 20                	je     8049e32 <strpbrk+0x34>
    if (strchr (stop, *string) != NULL)
 8049e12:	83 ec 08             	sub    $0x8,%esp
 8049e15:	0f be d2             	movsbl %dl,%edx
 8049e18:	52                   	push   %edx
 8049e19:	56                   	push   %esi
 8049e1a:	e8 3c ff ff ff       	call   8049d5b <strchr>
 8049e1f:	83 c4 10             	add    $0x10,%esp
 8049e22:	85 c0                	test   %eax,%eax
 8049e24:	75 13                	jne    8049e39 <strpbrk+0x3b>
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
  for (; *string != '\0'; string++)
 8049e26:	83 c3 01             	add    $0x1,%ebx
 8049e29:	0f b6 13             	movzbl (%ebx),%edx
 8049e2c:	84 d2                	test   %dl,%dl
 8049e2e:	75 e2                	jne    8049e12 <strpbrk+0x14>
 8049e30:	eb 09                	jmp    8049e3b <strpbrk+0x3d>
    if (strchr (stop, *string) != NULL)
      return (char *) string;
  return NULL;
 8049e32:	b8 00 00 00 00       	mov    $0x0,%eax
 8049e37:	eb 02                	jmp    8049e3b <strpbrk+0x3d>
 8049e39:	89 d8                	mov    %ebx,%eax
}
 8049e3b:	83 c4 04             	add    $0x4,%esp
 8049e3e:	5b                   	pop    %ebx
 8049e3f:	5e                   	pop    %esi
 8049e40:	c3                   	ret    

08049e41 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
 8049e41:	53                   	push   %ebx
 8049e42:	8b 54 24 08          	mov    0x8(%esp),%edx
  char c = c_;
 8049e46:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
  const char *p = NULL;

  for (; *string != '\0'; string++)
 8049e4b:	0f b6 0a             	movzbl (%edx),%ecx
 8049e4e:	84 c9                	test   %cl,%cl
 8049e50:	74 16                	je     8049e68 <strrchr+0x27>
 8049e52:	b8 00 00 00 00       	mov    $0x0,%eax
    if (*string == c)
 8049e57:	38 cb                	cmp    %cl,%bl
 8049e59:	0f 44 c2             	cmove  %edx,%eax
strrchr (const char *string, int c_) 
{
  char c = c_;
  const char *p = NULL;

  for (; *string != '\0'; string++)
 8049e5c:	83 c2 01             	add    $0x1,%edx
 8049e5f:	0f b6 0a             	movzbl (%edx),%ecx
 8049e62:	84 c9                	test   %cl,%cl
 8049e64:	75 f1                	jne    8049e57 <strrchr+0x16>
 8049e66:	eb 05                	jmp    8049e6d <strrchr+0x2c>
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
  char c = c_;
  const char *p = NULL;
 8049e68:	b8 00 00 00 00       	mov    $0x0,%eax

  for (; *string != '\0'; string++)
    if (*string == c)
      p = string;
  return (char *) p;
}
 8049e6d:	5b                   	pop    %ebx
 8049e6e:	c3                   	ret    

08049e6f <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
 8049e6f:	57                   	push   %edi
 8049e70:	56                   	push   %esi
 8049e71:	53                   	push   %ebx
 8049e72:	8b 74 24 10          	mov    0x10(%esp),%esi
 8049e76:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
 8049e7a:	0f b6 06             	movzbl (%esi),%eax
 8049e7d:	84 c0                	test   %al,%al
 8049e7f:	74 26                	je     8049ea7 <strspn+0x38>
 8049e81:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (skip, string[length]) == NULL)
 8049e86:	83 ec 08             	sub    $0x8,%esp
 8049e89:	0f be c0             	movsbl %al,%eax
 8049e8c:	50                   	push   %eax
 8049e8d:	57                   	push   %edi
 8049e8e:	e8 c8 fe ff ff       	call   8049d5b <strchr>
 8049e93:	83 c4 10             	add    $0x10,%esp
 8049e96:	85 c0                	test   %eax,%eax
 8049e98:	74 12                	je     8049eac <strspn+0x3d>
size_t
strspn (const char *string, const char *skip) 
{
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
 8049e9a:	83 c3 01             	add    $0x1,%ebx
 8049e9d:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
 8049ea1:	84 c0                	test   %al,%al
 8049ea3:	75 e1                	jne    8049e86 <strspn+0x17>
 8049ea5:	eb 05                	jmp    8049eac <strspn+0x3d>
 8049ea7:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr (skip, string[length]) == NULL)
      break;
  return length;
}
 8049eac:	89 d8                	mov    %ebx,%eax
 8049eae:	5b                   	pop    %ebx
 8049eaf:	5e                   	pop    %esi
 8049eb0:	5f                   	pop    %edi
 8049eb1:	c3                   	ret    

08049eb2 <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
 8049eb2:	55                   	push   %ebp
 8049eb3:	57                   	push   %edi
 8049eb4:	56                   	push   %esi
 8049eb5:	53                   	push   %ebx
 8049eb6:	83 ec 0c             	sub    $0xc,%esp
 8049eb9:	8b 5c 24 20          	mov    0x20(%esp),%ebx
 8049ebd:	8b 74 24 24          	mov    0x24(%esp),%esi
  char *token;
  
  ASSERT (delimiters != NULL);
 8049ec1:	85 f6                	test   %esi,%esi
 8049ec3:	75 21                	jne    8049ee6 <strtok_r+0x34>
 8049ec5:	83 ec 0c             	sub    $0xc,%esp
 8049ec8:	68 f2 b6 04 08       	push   $0x804b6f2
 8049ecd:	68 43 b6 04 08       	push   $0x804b643
 8049ed2:	68 00 b4 04 08       	push   $0x804b400
 8049ed7:	68 ef 00 00 00       	push   $0xef
 8049edc:	68 5a b6 04 08       	push   $0x804b65a
 8049ee1:	e8 1b 0a 00 00       	call   804a901 <debug_panic>
  ASSERT (save_ptr != NULL);
 8049ee6:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
 8049eeb:	75 21                	jne    8049f0e <strtok_r+0x5c>
 8049eed:	83 ec 0c             	sub    $0xc,%esp
 8049ef0:	68 05 b7 04 08       	push   $0x804b705
 8049ef5:	68 43 b6 04 08       	push   $0x804b643
 8049efa:	68 00 b4 04 08       	push   $0x804b400
 8049eff:	68 f0 00 00 00       	push   $0xf0
 8049f04:	68 5a b6 04 08       	push   $0x804b65a
 8049f09:	e8 f3 09 00 00       	call   804a901 <debug_panic>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
 8049f0e:	85 db                	test   %ebx,%ebx
 8049f10:	75 41                	jne    8049f53 <strtok_r+0xa1>
    s = *save_ptr;
 8049f12:	8b 44 24 28          	mov    0x28(%esp),%eax
 8049f16:	8b 18                	mov    (%eax),%ebx
  ASSERT (s != NULL);
 8049f18:	85 db                	test   %ebx,%ebx
 8049f1a:	75 37                	jne    8049f53 <strtok_r+0xa1>
 8049f1c:	83 ec 0c             	sub    $0xc,%esp
 8049f1f:	68 fb b6 04 08       	push   $0x804b6fb
 8049f24:	68 43 b6 04 08       	push   $0x804b643
 8049f29:	68 00 b4 04 08       	push   $0x804b400
 8049f2e:	68 f6 00 00 00       	push   $0xf6
 8049f33:	68 5a b6 04 08       	push   $0x804b65a
 8049f38:	e8 c4 09 00 00       	call   804a901 <debug_panic>
  while (strchr (delimiters, *s) != NULL) 
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
 8049f3d:	89 f8                	mov    %edi,%eax
 8049f3f:	84 c0                	test   %al,%al
 8049f41:	75 0d                	jne    8049f50 <strtok_r+0x9e>
        {
          *save_ptr = s;
 8049f43:	8b 44 24 28          	mov    0x28(%esp),%eax
 8049f47:	89 18                	mov    %ebx,(%eax)
          return NULL;
 8049f49:	b8 00 00 00 00       	mov    $0x0,%eax
 8049f4e:	eb 58                	jmp    8049fa8 <strtok_r+0xf6>
        }

      s++;
 8049f50:	83 c3 01             	add    $0x1,%ebx
  if (s == NULL)
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
 8049f53:	0f b6 3b             	movzbl (%ebx),%edi
 8049f56:	83 ec 08             	sub    $0x8,%esp
 8049f59:	89 f8                	mov    %edi,%eax
 8049f5b:	0f be c0             	movsbl %al,%eax
 8049f5e:	50                   	push   %eax
 8049f5f:	56                   	push   %esi
 8049f60:	e8 f6 fd ff ff       	call   8049d5b <strchr>
 8049f65:	83 c4 10             	add    $0x10,%esp
 8049f68:	85 c0                	test   %eax,%eax
 8049f6a:	75 d1                	jne    8049f3d <strtok_r+0x8b>
 8049f6c:	89 df                	mov    %ebx,%edi
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
  while (strchr (delimiters, *s) == NULL)
    s++;
 8049f6e:	83 c7 01             	add    $0x1,%edi
      s++;
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
  while (strchr (delimiters, *s) == NULL)
 8049f71:	0f b6 2f             	movzbl (%edi),%ebp
 8049f74:	83 ec 08             	sub    $0x8,%esp
 8049f77:	89 e8                	mov    %ebp,%eax
 8049f79:	0f be c0             	movsbl %al,%eax
 8049f7c:	50                   	push   %eax
 8049f7d:	56                   	push   %esi
 8049f7e:	e8 d8 fd ff ff       	call   8049d5b <strchr>
 8049f83:	83 c4 10             	add    $0x10,%esp
 8049f86:	85 c0                	test   %eax,%eax
 8049f88:	74 e4                	je     8049f6e <strtok_r+0xbc>
    s++;
  if (*s != '\0') 
 8049f8a:	89 e8                	mov    %ebp,%eax
 8049f8c:	84 c0                	test   %al,%al
 8049f8e:	74 10                	je     8049fa0 <strtok_r+0xee>
    {
      *s = '\0';
 8049f90:	c6 07 00             	movb   $0x0,(%edi)
      *save_ptr = s + 1;
 8049f93:	83 c7 01             	add    $0x1,%edi
 8049f96:	8b 44 24 28          	mov    0x28(%esp),%eax
 8049f9a:	89 38                	mov    %edi,(%eax)
 8049f9c:	89 d8                	mov    %ebx,%eax
 8049f9e:	eb 08                	jmp    8049fa8 <strtok_r+0xf6>
    }
  else 
    *save_ptr = s;
 8049fa0:	8b 44 24 28          	mov    0x28(%esp),%eax
 8049fa4:	89 38                	mov    %edi,(%eax)
 8049fa6:	89 d8                	mov    %ebx,%eax
  return token;
}
 8049fa8:	83 c4 0c             	add    $0xc,%esp
 8049fab:	5b                   	pop    %ebx
 8049fac:	5e                   	pop    %esi
 8049fad:	5f                   	pop    %edi
 8049fae:	5d                   	pop    %ebp
 8049faf:	c3                   	ret    

08049fb0 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
 8049fb0:	56                   	push   %esi
 8049fb1:	53                   	push   %ebx
 8049fb2:	83 ec 04             	sub    $0x4,%esp
 8049fb5:	8b 44 24 10          	mov    0x10(%esp),%eax
 8049fb9:	8b 5c 24 14          	mov    0x14(%esp),%ebx
 8049fbd:	8b 74 24 18          	mov    0x18(%esp),%esi
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
 8049fc1:	85 c0                	test   %eax,%eax
 8049fc3:	75 04                	jne    8049fc9 <memset+0x19>
 8049fc5:	85 f6                	test   %esi,%esi
 8049fc7:	75 0b                	jne    8049fd4 <memset+0x24>
 8049fc9:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
  
  while (size-- > 0)
 8049fcc:	89 c2                	mov    %eax,%edx
 8049fce:	85 f6                	test   %esi,%esi
 8049fd0:	75 23                	jne    8049ff5 <memset+0x45>
 8049fd2:	eb 2b                	jmp    8049fff <memset+0x4f>
void *
memset (void *dst_, int value, size_t size) 
{
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
 8049fd4:	83 ec 0c             	sub    $0xc,%esp
 8049fd7:	68 2a b6 04 08       	push   $0x804b62a
 8049fdc:	68 43 b6 04 08       	push   $0x804b643
 8049fe1:	68 f8 b3 04 08       	push   $0x804b3f8
 8049fe6:	68 1b 01 00 00       	push   $0x11b
 8049feb:	68 5a b6 04 08       	push   $0x804b65a
 8049ff0:	e8 0c 09 00 00       	call   804a901 <debug_panic>
  
  while (size-- > 0)
    *dst++ = value;
 8049ff5:	83 c2 01             	add    $0x1,%edx
 8049ff8:	88 5a ff             	mov    %bl,-0x1(%edx)
{
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
 8049ffb:	39 d1                	cmp    %edx,%ecx
 8049ffd:	75 f6                	jne    8049ff5 <memset+0x45>
    *dst++ = value;

  return dst_;
}
 8049fff:	83 c4 04             	add    $0x4,%esp
 804a002:	5b                   	pop    %ebx
 804a003:	5e                   	pop    %esi
 804a004:	c3                   	ret    

0804a005 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
 804a005:	83 ec 0c             	sub    $0xc,%esp
 804a008:	8b 54 24 10          	mov    0x10(%esp),%edx
  const char *p;

  ASSERT (string != NULL);
 804a00c:	85 d2                	test   %edx,%edx
 804a00e:	74 09                	je     804a019 <strlen+0x14>

  for (p = string; *p != '\0'; p++)
 804a010:	89 d0                	mov    %edx,%eax
 804a012:	80 3a 00             	cmpb   $0x0,(%edx)
 804a015:	74 2d                	je     804a044 <strlen+0x3f>
 804a017:	eb 21                	jmp    804a03a <strlen+0x35>
size_t
strlen (const char *string) 
{
  const char *p;

  ASSERT (string != NULL);
 804a019:	83 ec 0c             	sub    $0xc,%esp
 804a01c:	68 e3 b6 04 08       	push   $0x804b6e3
 804a021:	68 43 b6 04 08       	push   $0x804b643
 804a026:	68 f0 b3 04 08       	push   $0x804b3f0
 804a02b:	68 29 01 00 00       	push   $0x129
 804a030:	68 5a b6 04 08       	push   $0x804b65a
 804a035:	e8 c7 08 00 00       	call   804a901 <debug_panic>

  for (p = string; *p != '\0'; p++)
 804a03a:	89 d0                	mov    %edx,%eax
 804a03c:	83 c0 01             	add    $0x1,%eax
 804a03f:	80 38 00             	cmpb   $0x0,(%eax)
 804a042:	75 f8                	jne    804a03c <strlen+0x37>
    continue;
  return p - string;
 804a044:	29 d0                	sub    %edx,%eax
}
 804a046:	83 c4 0c             	add    $0xc,%esp
 804a049:	c3                   	ret    

0804a04a <strstr>:
/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
{
 804a04a:	55                   	push   %ebp
 804a04b:	57                   	push   %edi
 804a04c:	56                   	push   %esi
 804a04d:	53                   	push   %ebx
 804a04e:	83 ec 1c             	sub    $0x1c,%esp
 804a051:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  size_t haystack_len = strlen (haystack);
 804a055:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
 804a05a:	b8 00 00 00 00       	mov    $0x0,%eax
 804a05f:	89 d9                	mov    %ebx,%ecx
 804a061:	8b 7c 24 30          	mov    0x30(%esp),%edi
 804a065:	f2 ae                	repnz scas %es:(%edi),%al
 804a067:	f7 d1                	not    %ecx
 804a069:	8d 51 ff             	lea    -0x1(%ecx),%edx
  size_t needle_len = strlen (needle);
 804a06c:	89 d9                	mov    %ebx,%ecx
 804a06e:	89 ef                	mov    %ebp,%edi
 804a070:	f2 ae                	repnz scas %es:(%edi),%al
 804a072:	89 c8                	mov    %ecx,%eax
 804a074:	f7 d0                	not    %eax
 804a076:	8d 78 ff             	lea    -0x1(%eax),%edi

  if (haystack_len >= needle_len) 
 804a079:	39 fa                	cmp    %edi,%edx
 804a07b:	72 33                	jb     804a0b0 <strstr+0x66>
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
 804a07d:	29 fa                	sub    %edi,%edx
 804a07f:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804a083:	bb 00 00 00 00       	mov    $0x0,%ebx
 804a088:	89 de                	mov    %ebx,%esi
 804a08a:	03 74 24 30          	add    0x30(%esp),%esi
        if (!memcmp (haystack + i, needle, needle_len))
 804a08e:	83 ec 04             	sub    $0x4,%esp
 804a091:	57                   	push   %edi
 804a092:	55                   	push   %ebp
 804a093:	56                   	push   %esi
 804a094:	e8 2f fb ff ff       	call   8049bc8 <memcmp>
 804a099:	83 c4 10             	add    $0x10,%esp
 804a09c:	85 c0                	test   %eax,%eax
 804a09e:	74 17                	je     804a0b7 <strstr+0x6d>

  if (haystack_len >= needle_len) 
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
 804a0a0:	83 c3 01             	add    $0x1,%ebx
 804a0a3:	3b 5c 24 0c          	cmp    0xc(%esp),%ebx
 804a0a7:	76 df                	jbe    804a088 <strstr+0x3e>
        if (!memcmp (haystack + i, needle, needle_len))
          return (char *) haystack + i;
    }

  return NULL;
 804a0a9:	b8 00 00 00 00       	mov    $0x0,%eax
 804a0ae:	eb 09                	jmp    804a0b9 <strstr+0x6f>
 804a0b0:	b8 00 00 00 00       	mov    $0x0,%eax
 804a0b5:	eb 02                	jmp    804a0b9 <strstr+0x6f>
  if (haystack_len >= needle_len) 
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
        if (!memcmp (haystack + i, needle, needle_len))
 804a0b7:	89 f0                	mov    %esi,%eax
          return (char *) haystack + i;
    }

  return NULL;
}
 804a0b9:	83 c4 1c             	add    $0x1c,%esp
 804a0bc:	5b                   	pop    %ebx
 804a0bd:	5e                   	pop    %esi
 804a0be:	5f                   	pop    %edi
 804a0bf:	5d                   	pop    %ebp
 804a0c0:	c3                   	ret    

0804a0c1 <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
 804a0c1:	8b 54 24 04          	mov    0x4(%esp),%edx
 804a0c5:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
 804a0c9:	80 3a 00             	cmpb   $0x0,(%edx)
 804a0cc:	74 18                	je     804a0e6 <strnlen+0x25>
 804a0ce:	85 c9                	test   %ecx,%ecx
 804a0d0:	74 14                	je     804a0e6 <strnlen+0x25>
 804a0d2:	b8 00 00 00 00       	mov    $0x0,%eax
 804a0d7:	83 c0 01             	add    $0x1,%eax
 804a0da:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
 804a0de:	74 0b                	je     804a0eb <strnlen+0x2a>
 804a0e0:	39 c1                	cmp    %eax,%ecx
 804a0e2:	77 f3                	ja     804a0d7 <strnlen+0x16>
 804a0e4:	f3 c3                	repz ret 
 804a0e6:	b8 00 00 00 00       	mov    $0x0,%eax
    continue;
  return length;
}
 804a0eb:	f3 c3                	repz ret 

0804a0ed <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
 804a0ed:	55                   	push   %ebp
 804a0ee:	57                   	push   %edi
 804a0ef:	56                   	push   %esi
 804a0f0:	53                   	push   %ebx
 804a0f1:	83 ec 0c             	sub    $0xc,%esp
 804a0f4:	8b 74 24 20          	mov    0x20(%esp),%esi
 804a0f8:	8b 6c 24 24          	mov    0x24(%esp),%ebp
 804a0fc:	8b 54 24 28          	mov    0x28(%esp),%edx
  size_t src_len;

  ASSERT (dst != NULL);
 804a100:	85 f6                	test   %esi,%esi
 804a102:	75 21                	jne    804a125 <strlcpy+0x38>
 804a104:	83 ec 0c             	sub    $0xc,%esp
 804a107:	68 16 b7 04 08       	push   $0x804b716
 804a10c:	68 43 b6 04 08       	push   $0x804b643
 804a111:	68 e8 b3 04 08       	push   $0x804b3e8
 804a116:	68 4a 01 00 00       	push   $0x14a
 804a11b:	68 5a b6 04 08       	push   $0x804b65a
 804a120:	e8 dc 07 00 00       	call   804a901 <debug_panic>
  ASSERT (src != NULL);
 804a125:	85 ed                	test   %ebp,%ebp
 804a127:	75 21                	jne    804a14a <strlcpy+0x5d>
 804a129:	83 ec 0c             	sub    $0xc,%esp
 804a12c:	68 22 b7 04 08       	push   $0x804b722
 804a131:	68 43 b6 04 08       	push   $0x804b643
 804a136:	68 e8 b3 04 08       	push   $0x804b3e8
 804a13b:	68 4b 01 00 00       	push   $0x14b
 804a140:	68 5a b6 04 08       	push   $0x804b65a
 804a145:	e8 b7 07 00 00       	call   804a901 <debug_panic>

  src_len = strlen (src);
 804a14a:	b8 00 00 00 00       	mov    $0x0,%eax
 804a14f:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 804a154:	89 ef                	mov    %ebp,%edi
 804a156:	f2 ae                	repnz scas %es:(%edi),%al
 804a158:	f7 d1                	not    %ecx
 804a15a:	8d 59 ff             	lea    -0x1(%ecx),%ebx
  if (size > 0) 
 804a15d:	85 d2                	test   %edx,%edx
 804a15f:	74 1c                	je     804a17d <strlcpy+0x90>
    {
      size_t dst_len = size - 1;
 804a161:	83 ea 01             	sub    $0x1,%edx
 804a164:	39 d3                	cmp    %edx,%ebx
 804a166:	89 d7                	mov    %edx,%edi
 804a168:	0f 46 fb             	cmovbe %ebx,%edi
      if (src_len < dst_len)
        dst_len = src_len;
      memcpy (dst, src, dst_len);
 804a16b:	83 ec 04             	sub    $0x4,%esp
 804a16e:	57                   	push   %edi
 804a16f:	55                   	push   %ebp
 804a170:	56                   	push   %esi
 804a171:	e8 2d f9 ff ff       	call   8049aa3 <memcpy>
      dst[dst_len] = '\0';
 804a176:	c6 04 3e 00          	movb   $0x0,(%esi,%edi,1)
 804a17a:	83 c4 10             	add    $0x10,%esp
    }
  return src_len;
}
 804a17d:	89 d8                	mov    %ebx,%eax
 804a17f:	83 c4 0c             	add    $0xc,%esp
 804a182:	5b                   	pop    %ebx
 804a183:	5e                   	pop    %esi
 804a184:	5f                   	pop    %edi
 804a185:	5d                   	pop    %ebp
 804a186:	c3                   	ret    

0804a187 <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
 804a187:	55                   	push   %ebp
 804a188:	57                   	push   %edi
 804a189:	56                   	push   %esi
 804a18a:	53                   	push   %ebx
 804a18b:	83 ec 0c             	sub    $0xc,%esp
 804a18e:	8b 54 24 24          	mov    0x24(%esp),%edx
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
 804a192:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
 804a197:	75 21                	jne    804a1ba <strlcat+0x33>
 804a199:	83 ec 0c             	sub    $0xc,%esp
 804a19c:	68 16 b7 04 08       	push   $0x804b716
 804a1a1:	68 43 b6 04 08       	push   $0x804b643
 804a1a6:	68 e0 b3 04 08       	push   $0x804b3e0
 804a1ab:	68 68 01 00 00       	push   $0x168
 804a1b0:	68 5a b6 04 08       	push   $0x804b65a
 804a1b5:	e8 47 07 00 00       	call   804a901 <debug_panic>
  ASSERT (src != NULL);
 804a1ba:	85 d2                	test   %edx,%edx
 804a1bc:	75 21                	jne    804a1df <strlcat+0x58>
 804a1be:	83 ec 0c             	sub    $0xc,%esp
 804a1c1:	68 22 b7 04 08       	push   $0x804b722
 804a1c6:	68 43 b6 04 08       	push   $0x804b643
 804a1cb:	68 e0 b3 04 08       	push   $0x804b3e0
 804a1d0:	68 69 01 00 00       	push   $0x169
 804a1d5:	68 5a b6 04 08       	push   $0x804b65a
 804a1da:	e8 22 07 00 00       	call   804a901 <debug_panic>

  src_len = strlen (src);
 804a1df:	be ff ff ff ff       	mov    $0xffffffff,%esi
 804a1e4:	b8 00 00 00 00       	mov    $0x0,%eax
 804a1e9:	89 f1                	mov    %esi,%ecx
 804a1eb:	89 d7                	mov    %edx,%edi
 804a1ed:	f2 ae                	repnz scas %es:(%edi),%al
 804a1ef:	f7 d1                	not    %ecx
 804a1f1:	8d 69 ff             	lea    -0x1(%ecx),%ebp
  dst_len = strlen (dst);
 804a1f4:	89 f1                	mov    %esi,%ecx
 804a1f6:	8b 7c 24 20          	mov    0x20(%esp),%edi
 804a1fa:	f2 ae                	repnz scas %es:(%edi),%al
 804a1fc:	89 c8                	mov    %ecx,%eax
 804a1fe:	f7 d0                	not    %eax
 804a200:	8d 58 ff             	lea    -0x1(%eax),%ebx
  if (size > 0 && dst_len < size) 
 804a203:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
 804a208:	74 2c                	je     804a236 <strlcat+0xaf>
 804a20a:	3b 5c 24 28          	cmp    0x28(%esp),%ebx
 804a20e:	73 26                	jae    804a236 <strlcat+0xaf>
    {
      size_t copy_cnt = size - dst_len - 1;
 804a210:	8b 44 24 28          	mov    0x28(%esp),%eax
 804a214:	8d 70 ff             	lea    -0x1(%eax),%esi
 804a217:	29 de                	sub    %ebx,%esi
 804a219:	39 f5                	cmp    %esi,%ebp
 804a21b:	0f 46 f5             	cmovbe %ebp,%esi
      if (src_len < copy_cnt)
        copy_cnt = src_len;
      memcpy (dst + dst_len, src, copy_cnt);
 804a21e:	89 df                	mov    %ebx,%edi
 804a220:	03 7c 24 20          	add    0x20(%esp),%edi
 804a224:	83 ec 04             	sub    $0x4,%esp
 804a227:	56                   	push   %esi
 804a228:	52                   	push   %edx
 804a229:	57                   	push   %edi
 804a22a:	e8 74 f8 ff ff       	call   8049aa3 <memcpy>
      dst[dst_len + copy_cnt] = '\0';
 804a22f:	c6 04 37 00          	movb   $0x0,(%edi,%esi,1)
 804a233:	83 c4 10             	add    $0x10,%esp
    }
  return src_len + dst_len;
 804a236:	8d 44 1d 00          	lea    0x0(%ebp,%ebx,1),%eax
}
 804a23a:	83 c4 0c             	add    $0xc,%esp
 804a23d:	5b                   	pop    %ebx
 804a23e:	5e                   	pop    %esi
 804a23f:	5f                   	pop    %edi
 804a240:	5d                   	pop    %ebp
 804a241:	c3                   	ret    

0804a242 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
 804a242:	55                   	push   %ebp
 804a243:	57                   	push   %edi
 804a244:	56                   	push   %esi
 804a245:	53                   	push   %ebx
 804a246:	83 ec 1c             	sub    $0x1c,%esp
 804a249:	89 04 24             	mov    %eax,(%esp)
 804a24c:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a250:	8b 74 24 30          	mov    0x30(%esp),%esi
 804a254:	8b 7c 24 34          	mov    0x34(%esp),%edi
  if ((d >> 32) == 0) 
 804a258:	85 ff                	test   %edi,%edi
 804a25a:	75 43                	jne    804a29f <udiv64+0x5d>
             <=> [b - 1/d] < b
         which is a tautology.

         Therefore, this code is correct and will not trap. */
      uint64_t b = 1ULL << 32;
      uint32_t n1 = n >> 32;
 804a25c:	8b 44 24 04          	mov    0x4(%esp),%eax
      uint32_t n0 = n; 
      uint32_t d0 = d;

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
 804a260:	ba 00 00 00 00       	mov    $0x0,%edx
 804a265:	f7 f6                	div    %esi
 804a267:	89 c7                	mov    %eax,%edi
 804a269:	89 d0                	mov    %edx,%eax
 804a26b:	89 c2                	mov    %eax,%edx
 804a26d:	b8 00 00 00 00       	mov    $0x0,%eax
 804a272:	8b 0c 24             	mov    (%esp),%ecx
 804a275:	bb 00 00 00 00       	mov    $0x0,%ebx
 804a27a:	01 c8                	add    %ecx,%eax
 804a27c:	11 da                	adc    %ebx,%edx
{
  uint32_t n1 = n >> 32;
  uint32_t n0 = n;
  uint32_t q, r;

  asm ("divl %4"
 804a27e:	f7 f6                	div    %esi
      uint64_t b = 1ULL << 32;
      uint32_t n1 = n >> 32;
      uint32_t n0 = n; 
      uint32_t d0 = d;

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
 804a280:	89 f9                	mov    %edi,%ecx
 804a282:	89 cf                	mov    %ecx,%edi
 804a284:	be 00 00 00 00       	mov    $0x0,%esi
 804a289:	ba 00 00 00 00       	mov    $0x0,%edx
 804a28e:	01 c6                	add    %eax,%esi
 804a290:	11 d7                	adc    %edx,%edi
 804a292:	89 74 24 08          	mov    %esi,0x8(%esp)
 804a296:	89 7c 24 0c          	mov    %edi,0xc(%esp)
 804a29a:	e9 05 01 00 00       	jmp    804a3a4 <udiv64+0x162>
 804a29f:	89 fa                	mov    %edi,%edx
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
 804a2a1:	8b 0c 24             	mov    (%esp),%ecx
 804a2a4:	8b 5c 24 04          	mov    0x4(%esp),%ebx
 804a2a8:	39 df                	cmp    %ebx,%edi
 804a2aa:	0f 87 e4 00 00 00    	ja     804a394 <udiv64+0x152>
 804a2b0:	72 08                	jb     804a2ba <udiv64+0x78>
 804a2b2:	39 ce                	cmp    %ecx,%esi
 804a2b4:	0f 87 da 00 00 00    	ja     804a394 <udiv64+0x152>
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
 804a2ba:	89 d0                	mov    %edx,%eax
  /* This technique is portable, but there are better ways to do
     it on particular systems.  With sufficiently new enough GCC,
     you can use __builtin_clz() to take advantage of GCC's
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
 804a2bc:	bd 00 00 00 00       	mov    $0x0,%ebp
  if (x <= 0x0000FFFF)
 804a2c1:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
 804a2c7:	77 08                	ja     804a2d1 <udiv64+0x8f>
    {
      n += 16;
      x <<= 16; 
 804a2c9:	c1 e0 10             	shl    $0x10,%eax
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
  if (x <= 0x0000FFFF)
    {
      n += 16;
 804a2cc:	bd 10 00 00 00       	mov    $0x10,%ebp
      x <<= 16; 
    }
  if (x <= 0x00FFFFFF)
 804a2d1:	3d ff ff ff 00       	cmp    $0xffffff,%eax
 804a2d6:	77 06                	ja     804a2de <udiv64+0x9c>
    {
      n += 8;
 804a2d8:	83 c5 08             	add    $0x8,%ebp
      x <<= 8; 
 804a2db:	c1 e0 08             	shl    $0x8,%eax
    }
  if (x <= 0x0FFFFFFF)
 804a2de:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
 804a2e3:	77 06                	ja     804a2eb <udiv64+0xa9>
    {
      n += 4;
 804a2e5:	83 c5 04             	add    $0x4,%ebp
      x <<= 4;
 804a2e8:	c1 e0 04             	shl    $0x4,%eax
    }
  if (x <= 0x3FFFFFFF)
 804a2eb:	3d ff ff ff 3f       	cmp    $0x3fffffff,%eax
 804a2f0:	77 06                	ja     804a2f8 <udiv64+0xb6>
    {
      n += 2;
 804a2f2:	83 c5 02             	add    $0x2,%ebp
      x <<= 2; 
 804a2f5:	c1 e0 02             	shl    $0x2,%eax
    }
  if (x <= 0x7FFFFFFF)
    n++;
 804a2f8:	3d 00 00 00 80       	cmp    $0x80000000,%eax
 804a2fd:	83 d5 00             	adc    $0x0,%ebp
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
 804a300:	8b 04 24             	mov    (%esp),%eax
 804a303:	8b 54 24 04          	mov    0x4(%esp),%edx
 804a307:	0f ac d0 01          	shrd   $0x1,%edx,%eax
 804a30b:	d1 ea                	shr    %edx
 804a30d:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a311:	89 54 24 0c          	mov    %edx,0xc(%esp)
{
  uint32_t n1 = n >> 32;
  uint32_t n0 = n;
  uint32_t q, r;

  asm ("divl %4"
 804a315:	89 f0                	mov    %esi,%eax
 804a317:	89 fa                	mov    %edi,%edx
 804a319:	89 e9                	mov    %ebp,%ecx
 804a31b:	0f a5 f2             	shld   %cl,%esi,%edx
 804a31e:	d3 e0                	shl    %cl,%eax
 804a320:	f6 c1 20             	test   $0x20,%cl
 804a323:	74 02                	je     804a327 <udiv64+0xe5>
 804a325:	89 c2                	mov    %eax,%edx
 804a327:	89 d3                	mov    %edx,%ebx
 804a329:	8b 54 24 0c          	mov    0xc(%esp),%edx
 804a32d:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a331:	f7 f3                	div    %ebx
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
 804a333:	b9 1f 00 00 00       	mov    $0x1f,%ecx
 804a338:	29 e9                	sub    %ebp,%ecx
 804a33a:	d3 e8                	shr    %cl,%eax
 804a33c:	89 c2                	mov    %eax,%edx
 804a33e:	b9 00 00 00 00       	mov    $0x0,%ecx
 804a343:	89 44 24 10          	mov    %eax,0x10(%esp)
 804a347:	89 4c 24 14          	mov    %ecx,0x14(%esp)
          return n - (q - 1) * d < d ? q - 1 : q; 
 804a34b:	83 c2 ff             	add    $0xffffffff,%edx
 804a34e:	83 d1 ff             	adc    $0xffffffff,%ecx
 804a351:	89 cb                	mov    %ecx,%ebx
 804a353:	89 54 24 08          	mov    %edx,0x8(%esp)
 804a357:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 804a35b:	89 fd                	mov    %edi,%ebp
 804a35d:	0f af ea             	imul   %edx,%ebp
 804a360:	89 d8                	mov    %ebx,%eax
 804a362:	0f af c6             	imul   %esi,%eax
 804a365:	01 c5                	add    %eax,%ebp
 804a367:	89 f0                	mov    %esi,%eax
 804a369:	f7 e2                	mul    %edx
 804a36b:	01 ea                	add    %ebp,%edx
 804a36d:	8b 0c 24             	mov    (%esp),%ecx
 804a370:	8b 5c 24 04          	mov    0x4(%esp),%ebx
 804a374:	29 c1                	sub    %eax,%ecx
 804a376:	19 d3                	sbb    %edx,%ebx
 804a378:	39 df                	cmp    %ebx,%edi
 804a37a:	77 28                	ja     804a3a4 <udiv64+0x162>
 804a37c:	72 04                	jb     804a382 <udiv64+0x140>
 804a37e:	39 ce                	cmp    %ecx,%esi
 804a380:	77 22                	ja     804a3a4 <udiv64+0x162>
 804a382:	8b 44 24 10          	mov    0x10(%esp),%eax
 804a386:	8b 54 24 14          	mov    0x14(%esp),%edx
 804a38a:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a38e:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804a392:	eb 10                	jmp    804a3a4 <udiv64+0x162>
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
        return 0;
 804a394:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804a39b:	00 
 804a39c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 804a3a3:	00 
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
          return n - (q - 1) * d < d ? q - 1 : q; 
        }
    }
}
 804a3a4:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a3a8:	8b 54 24 0c          	mov    0xc(%esp),%edx
 804a3ac:	83 c4 1c             	add    $0x1c,%esp
 804a3af:	5b                   	pop    %ebx
 804a3b0:	5e                   	pop    %esi
 804a3b1:	5f                   	pop    %edi
 804a3b2:	5d                   	pop    %ebp
 804a3b3:	c3                   	ret    

0804a3b4 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
 804a3b4:	57                   	push   %edi
 804a3b5:	56                   	push   %esi
 804a3b6:	53                   	push   %ebx
 804a3b7:	83 ec 08             	sub    $0x8,%esp
 804a3ba:	89 04 24             	mov    %eax,(%esp)
 804a3bd:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a3c1:	8b 74 24 18          	mov    0x18(%esp),%esi
 804a3c5:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
 804a3c9:	85 d2                	test   %edx,%edx
 804a3cb:	79 07                	jns    804a3d4 <sdiv64+0x20>
 804a3cd:	f7 d8                	neg    %eax
 804a3cf:	83 d2 00             	adc    $0x0,%edx
 804a3d2:	f7 da                	neg    %edx
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
 804a3d4:	89 f1                	mov    %esi,%ecx
 804a3d6:	89 fb                	mov    %edi,%ebx
 804a3d8:	85 ff                	test   %edi,%edi
 804a3da:	79 07                	jns    804a3e3 <sdiv64+0x2f>
 804a3dc:	f7 d9                	neg    %ecx
 804a3de:	83 d3 00             	adc    $0x0,%ebx
 804a3e1:	f7 db                	neg    %ebx
  uint64_t q_abs = udiv64 (n_abs, d_abs);
 804a3e3:	53                   	push   %ebx
 804a3e4:	51                   	push   %ecx
 804a3e5:	e8 58 fe ff ff       	call   804a242 <udiv64>
 804a3ea:	83 c4 08             	add    $0x8,%esp
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
 804a3ed:	8b 4c 24 04          	mov    0x4(%esp),%ecx
 804a3f1:	f7 d1                	not    %ecx
 804a3f3:	c1 e9 1f             	shr    $0x1f,%ecx
 804a3f6:	89 fb                	mov    %edi,%ebx
 804a3f8:	c1 eb 1f             	shr    $0x1f,%ebx
 804a3fb:	38 d9                	cmp    %bl,%cl
 804a3fd:	75 07                	jne    804a406 <sdiv64+0x52>
 804a3ff:	f7 d8                	neg    %eax
 804a401:	83 d2 00             	adc    $0x0,%edx
 804a404:	f7 da                	neg    %edx
}
 804a406:	83 c4 08             	add    $0x8,%esp
 804a409:	5b                   	pop    %ebx
 804a40a:	5e                   	pop    %esi
 804a40b:	5f                   	pop    %edi
 804a40c:	c3                   	ret    

0804a40d <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
 804a40d:	83 ec 04             	sub    $0x4,%esp
  return sdiv64 (n, d);
 804a410:	ff 74 24 14          	pushl  0x14(%esp)
 804a414:	ff 74 24 14          	pushl  0x14(%esp)
 804a418:	8b 44 24 10          	mov    0x10(%esp),%eax
 804a41c:	8b 54 24 14          	mov    0x14(%esp),%edx
 804a420:	e8 8f ff ff ff       	call   804a3b4 <sdiv64>
}
 804a425:	83 c4 0c             	add    $0xc,%esp
 804a428:	c3                   	ret    

0804a429 <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
 804a429:	57                   	push   %edi
 804a42a:	56                   	push   %esi
 804a42b:	53                   	push   %ebx
 804a42c:	8b 5c 24 10          	mov    0x10(%esp),%ebx
 804a430:	8b 74 24 18          	mov    0x18(%esp),%esi
 804a434:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
/* Divides signed 64-bit N by signed 64-bit D and returns the
   remainder. */
static int32_t
smod64 (int64_t n, int64_t d)
{
  return n - d * sdiv64 (n, d);
 804a438:	57                   	push   %edi
 804a439:	56                   	push   %esi
 804a43a:	89 d8                	mov    %ebx,%eax
 804a43c:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 804a440:	e8 6f ff ff ff       	call   804a3b4 <sdiv64>
 804a445:	83 c4 08             	add    $0x8,%esp

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
  return smod64 (n, d);
 804a448:	0f af f0             	imul   %eax,%esi
 804a44b:	89 d8                	mov    %ebx,%eax
 804a44d:	29 f0                	sub    %esi,%eax
 804a44f:	99                   	cltd   
}
 804a450:	5b                   	pop    %ebx
 804a451:	5e                   	pop    %esi
 804a452:	5f                   	pop    %edi
 804a453:	c3                   	ret    

0804a454 <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
 804a454:	83 ec 04             	sub    $0x4,%esp
  return udiv64 (n, d);
 804a457:	ff 74 24 14          	pushl  0x14(%esp)
 804a45b:	ff 74 24 14          	pushl  0x14(%esp)
 804a45f:	8b 44 24 10          	mov    0x10(%esp),%eax
 804a463:	8b 54 24 14          	mov    0x14(%esp),%edx
 804a467:	e8 d6 fd ff ff       	call   804a242 <udiv64>
}
 804a46c:	83 c4 0c             	add    $0xc,%esp
 804a46f:	c3                   	ret    

0804a470 <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
 804a470:	57                   	push   %edi
 804a471:	56                   	push   %esi
 804a472:	53                   	push   %ebx
 804a473:	8b 5c 24 10          	mov    0x10(%esp),%ebx
 804a477:	8b 74 24 18          	mov    0x18(%esp),%esi
 804a47b:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   remainder. */
static uint32_t
umod64 (uint64_t n, uint64_t d)
{
  return n - d * udiv64 (n, d);
 804a47f:	57                   	push   %edi
 804a480:	56                   	push   %esi
 804a481:	89 d8                	mov    %ebx,%eax
 804a483:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 804a487:	e8 b6 fd ff ff       	call   804a242 <udiv64>
 804a48c:	83 c4 08             	add    $0x8,%esp

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
  return umod64 (n, d);
 804a48f:	0f af f0             	imul   %eax,%esi
 804a492:	89 d8                	mov    %ebx,%eax
 804a494:	29 f0                	sub    %esi,%eax
 804a496:	ba 00 00 00 00       	mov    $0x0,%edx
}
 804a49b:	5b                   	pop    %ebx
 804a49c:	5e                   	pop    %esi
 804a49d:	5f                   	pop    %edi
 804a49e:	c3                   	ret    

0804a49f <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
 804a49f:	55                   	push   %ebp
 804a4a0:	57                   	push   %edi
 804a4a1:	56                   	push   %esi
 804a4a2:	53                   	push   %ebx
 804a4a3:	83 ec 04             	sub    $0x4,%esp
 804a4a6:	89 04 24             	mov    %eax,(%esp)
  size_t ofs;

  *value = 0;
 804a4a9:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
 804a4af:	b8 00 00 00 00       	mov    $0x0,%eax
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
  size_t ofs;

  *value = 0;
  for (ofs = 0; ofs < size; ofs++)
 804a4b4:	85 d2                	test   %edx,%edx
 804a4b6:	74 62                	je     804a51a <parse_octal_field+0x7b>
 804a4b8:	eb 40                	jmp    804a4fa <parse_octal_field+0x5b>
    {
      char c = s[ofs];
 804a4ba:	8b 04 24             	mov    (%esp),%eax
 804a4bd:	0f b6 1c 30          	movzbl (%eax,%esi,1),%ebx
      if (c >= '0' && c <= '7')
 804a4c1:	8d 6b d0             	lea    -0x30(%ebx),%ebp
 804a4c4:	89 e8                	mov    %ebp,%eax
 804a4c6:	3c 07                	cmp    $0x7,%al
 804a4c8:	77 1f                	ja     804a4e9 <parse_octal_field+0x4a>
        {
          if (*value > ULONG_MAX / 8)
 804a4ca:	81 ff ff ff ff 1f    	cmp    $0x1fffffff,%edi
 804a4d0:	77 43                	ja     804a515 <parse_octal_field+0x76>
            {
              /* Overflow. */
              return false;
            }
          *value = c - '0' + *value * 8;
 804a4d2:	0f be db             	movsbl %bl,%ebx
 804a4d5:	8d 7c fb d0          	lea    -0x30(%ebx,%edi,8),%edi
 804a4d9:	89 39                	mov    %edi,(%ecx)
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
  size_t ofs;

  *value = 0;
  for (ofs = 0; ofs < size; ofs++)
 804a4db:	83 c6 01             	add    $0x1,%esi
 804a4de:	39 f2                	cmp    %esi,%edx
 804a4e0:	75 d8                	jne    804a4ba <parse_octal_field+0x1b>
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
 804a4e2:	b8 00 00 00 00       	mov    $0x0,%eax
 804a4e7:	eb 31                	jmp    804a51a <parse_octal_field+0x7b>
          return ofs > 0;
        }
      else
        {
          /* Bad character. */
          return false;
 804a4e9:	b8 00 00 00 00       	mov    $0x0,%eax
              /* Overflow. */
              return false;
            }
          *value = c - '0' + *value * 8;
        }
      else if (c == ' ' || c == '\0')
 804a4ee:	f6 c3 df             	test   $0xdf,%bl
 804a4f1:	75 27                	jne    804a51a <parse_octal_field+0x7b>
        {
          /* End of field, but disallow completely empty
             fields. */
          return ofs > 0;
 804a4f3:	85 f6                	test   %esi,%esi
 804a4f5:	0f 95 c0             	setne  %al
 804a4f8:	eb 20                	jmp    804a51a <parse_octal_field+0x7b>
  size_t ofs;

  *value = 0;
  for (ofs = 0; ofs < size; ofs++)
    {
      char c = s[ofs];
 804a4fa:	8b 04 24             	mov    (%esp),%eax
 804a4fd:	0f b6 18             	movzbl (%eax),%ebx
      if (c >= '0' && c <= '7')
 804a500:	8d 6b d0             	lea    -0x30(%ebx),%ebp
 804a503:	bf 00 00 00 00       	mov    $0x0,%edi
 804a508:	be 00 00 00 00       	mov    $0x0,%esi
 804a50d:	89 e8                	mov    %ebp,%eax
 804a50f:	3c 07                	cmp    $0x7,%al
 804a511:	76 bf                	jbe    804a4d2 <parse_octal_field+0x33>
 804a513:	eb d4                	jmp    804a4e9 <parse_octal_field+0x4a>
        {
          if (*value > ULONG_MAX / 8)
            {
              /* Overflow. */
              return false;
 804a515:	b8 00 00 00 00       	mov    $0x0,%eax
        }
    }

  /* Field did not end in space or null byte. */
  return false;
}
 804a51a:	83 c4 04             	add    $0x4,%esp
 804a51d:	5b                   	pop    %ebx
 804a51e:	5e                   	pop    %esi
 804a51f:	5f                   	pop    %edi
 804a520:	5d                   	pop    %ebp
 804a521:	c3                   	ret    

0804a522 <strip_antisocial_prefixes>:

   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
 804a522:	57                   	push   %edi
 804a523:	56                   	push   %esi
 804a524:	53                   	push   %ebx
 804a525:	89 c3                	mov    %eax,%ebx
  while (*file_name == '/'
 804a527:	eb 11                	jmp    804a53a <strip_antisocial_prefixes+0x18>
         || !memcmp (file_name, "./", 2)
         || !memcmp (file_name, "../", 3))
    file_name = strchr (file_name, '/') + 1;
 804a529:	83 ec 08             	sub    $0x8,%esp
 804a52c:	6a 2f                	push   $0x2f
 804a52e:	53                   	push   %ebx
 804a52f:	e8 27 f8 ff ff       	call   8049d5b <strchr>
 804a534:	83 c4 10             	add    $0x10,%esp
 804a537:	8d 58 01             	lea    0x1(%eax),%ebx
   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
  while (*file_name == '/'
 804a53a:	0f b6 33             	movzbl (%ebx),%esi
 804a53d:	89 f0                	mov    %esi,%eax
 804a53f:	3c 2f                	cmp    $0x2f,%al
 804a541:	74 e6                	je     804a529 <strip_antisocial_prefixes+0x7>
         || !memcmp (file_name, "./", 2)
 804a543:	83 ec 04             	sub    $0x4,%esp
 804a546:	6a 02                	push   $0x2
 804a548:	68 2f b7 04 08       	push   $0x804b72f
 804a54d:	53                   	push   %ebx
 804a54e:	e8 75 f6 ff ff       	call   8049bc8 <memcmp>
 804a553:	83 c4 10             	add    $0x10,%esp
 804a556:	85 c0                	test   %eax,%eax
 804a558:	74 cf                	je     804a529 <strip_antisocial_prefixes+0x7>
         || !memcmp (file_name, "../", 3))
 804a55a:	83 ec 04             	sub    $0x4,%esp
 804a55d:	6a 03                	push   $0x3
 804a55f:	68 2e b7 04 08       	push   $0x804b72e
 804a564:	53                   	push   %ebx
 804a565:	e8 5e f6 ff ff       	call   8049bc8 <memcmp>
 804a56a:	83 c4 10             	add    $0x10,%esp
 804a56d:	85 c0                	test   %eax,%eax
 804a56f:	74 b8                	je     804a529 <strip_antisocial_prefixes+0x7>
    file_name = strchr (file_name, '/') + 1;
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
 804a571:	b8 33 b7 04 08       	mov    $0x804b733,%eax
 804a576:	89 f2                	mov    %esi,%edx
 804a578:	84 d2                	test   %dl,%dl
 804a57a:	74 23                	je     804a59f <strip_antisocial_prefixes+0x7d>
 804a57c:	bf 32 b7 04 08       	mov    $0x804b732,%edi
 804a581:	b9 03 00 00 00       	mov    $0x3,%ecx
 804a586:	89 de                	mov    %ebx,%esi
 804a588:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
 804a58a:	0f 97 c0             	seta   %al
 804a58d:	0f 92 c2             	setb   %dl
 804a590:	29 d0                	sub    %edx,%eax
 804a592:	0f be c0             	movsbl %al,%eax
 804a595:	85 c0                	test   %eax,%eax
 804a597:	b8 33 b7 04 08       	mov    $0x804b733,%eax
 804a59c:	0f 45 c3             	cmovne %ebx,%eax
}
 804a59f:	5b                   	pop    %ebx
 804a5a0:	5e                   	pop    %esi
 804a5a1:	5f                   	pop    %edi
 804a5a2:	c3                   	ret    

0804a5a3 <ustar_make_header>:
   If successful, returns true.  On failure (due to an
   excessively long file name), returns false. */
bool
ustar_make_header (const char *file_name, enum ustar_type type,
                   int size, char header[USTAR_HEADER_SIZE])
{
 804a5a3:	55                   	push   %ebp
 804a5a4:	57                   	push   %edi
 804a5a5:	56                   	push   %esi
 804a5a6:	53                   	push   %ebx
 804a5a7:	83 ec 0c             	sub    $0xc,%esp
 804a5aa:	8b 74 24 24          	mov    0x24(%esp),%esi
 804a5ae:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  struct ustar_header *h = (struct ustar_header *) header;

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
 804a5b2:	83 fe 30             	cmp    $0x30,%esi
 804a5b5:	0f 94 c2             	sete   %dl
 804a5b8:	83 fe 35             	cmp    $0x35,%esi
 804a5bb:	0f 94 c0             	sete   %al
 804a5be:	08 c2                	or     %al,%dl
 804a5c0:	75 1e                	jne    804a5e0 <ustar_make_header+0x3d>
 804a5c2:	83 ec 0c             	sub    $0xc,%esp
 804a5c5:	68 d4 ba 04 08       	push   $0x804bad4
 804a5ca:	68 43 b6 04 08       	push   $0x804b643
 804a5cf:	68 3c b4 04 08       	push   $0x804b43c
 804a5d4:	6a 59                	push   $0x59
 804a5d6:	68 35 b7 04 08       	push   $0x804b735
 804a5db:	e8 21 03 00 00       	call   804a901 <debug_panic>
 804a5e0:	89 d5                	mov    %edx,%ebp

  /* Check file name. */
  file_name = strip_antisocial_prefixes (file_name);
 804a5e2:	8b 44 24 20          	mov    0x20(%esp),%eax
 804a5e6:	e8 37 ff ff ff       	call   804a522 <strip_antisocial_prefixes>
 804a5eb:	89 c2                	mov    %eax,%edx
  if (strlen (file_name) > 99)
 804a5ed:	b8 00 00 00 00       	mov    $0x0,%eax
 804a5f2:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 804a5f7:	89 d7                	mov    %edx,%edi
 804a5f9:	f2 ae                	repnz scas %es:(%edi),%al
 804a5fb:	f7 d1                	not    %ecx
 804a5fd:	83 e9 01             	sub    $0x1,%ecx
 804a600:	83 f9 63             	cmp    $0x63,%ecx
 804a603:	76 1b                	jbe    804a620 <ustar_make_header+0x7d>
    {
      printf ("%s: file name too long\n", file_name);
 804a605:	83 ec 08             	sub    $0x8,%esp
 804a608:	52                   	push   %edx
 804a609:	68 83 b4 04 08       	push   $0x804b483
 804a60e:	e8 f3 ea ff ff       	call   8049106 <printf>
      return false;
 804a613:	83 c4 10             	add    $0x10,%esp
 804a616:	bd 00 00 00 00       	mov    $0x0,%ebp
 804a61b:	e9 4b 01 00 00       	jmp    804a76b <ustar_make_header+0x1c8>
    }

  /* Fill in header except for final checksum. */
  memset (h, 0, sizeof *h);
 804a620:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
 804a626:	c7 83 fc 01 00 00 00 	movl   $0x0,0x1fc(%ebx)
 804a62d:	00 00 00 
 804a630:	8d 7b 04             	lea    0x4(%ebx),%edi
 804a633:	83 e7 fc             	and    $0xfffffffc,%edi
 804a636:	89 d9                	mov    %ebx,%ecx
 804a638:	29 f9                	sub    %edi,%ecx
 804a63a:	81 c1 00 02 00 00    	add    $0x200,%ecx
 804a640:	c1 e9 02             	shr    $0x2,%ecx
 804a643:	b8 00 00 00 00       	mov    $0x0,%eax
 804a648:	f3 ab                	rep stos %eax,%es:(%edi)
  strlcpy (h->name, file_name, sizeof h->name);
 804a64a:	83 ec 04             	sub    $0x4,%esp
 804a64d:	6a 64                	push   $0x64
 804a64f:	52                   	push   %edx
 804a650:	53                   	push   %ebx
 804a651:	e8 97 fa ff ff       	call   804a0ed <strlcpy>
  snprintf (h->mode, sizeof h->mode, "%07o",
 804a656:	83 c4 10             	add    $0x10,%esp
 804a659:	83 fe 30             	cmp    $0x30,%esi
 804a65c:	ba ed 01 00 00       	mov    $0x1ed,%edx
 804a661:	b8 a4 01 00 00       	mov    $0x1a4,%eax
 804a666:	0f 45 c2             	cmovne %edx,%eax
 804a669:	50                   	push   %eax
 804a66a:	68 47 b7 04 08       	push   $0x804b747
 804a66f:	6a 08                	push   $0x8
 804a671:	8d 43 64             	lea    0x64(%ebx),%eax
 804a674:	50                   	push   %eax
 804a675:	e8 99 f1 ff ff       	call   8049813 <snprintf>
            type == USTAR_REGULAR ? 0644 : 0755);
  strlcpy (h->uid, "0000000", sizeof h->uid);
 804a67a:	83 c4 0c             	add    $0xc,%esp
 804a67d:	6a 08                	push   $0x8
 804a67f:	68 4c b7 04 08       	push   $0x804b74c
 804a684:	8d 43 6c             	lea    0x6c(%ebx),%eax
 804a687:	50                   	push   %eax
 804a688:	e8 60 fa ff ff       	call   804a0ed <strlcpy>
  strlcpy (h->gid, "0000000", sizeof h->gid);
 804a68d:	83 c4 0c             	add    $0xc,%esp
 804a690:	6a 08                	push   $0x8
 804a692:	68 4c b7 04 08       	push   $0x804b74c
 804a697:	8d 43 74             	lea    0x74(%ebx),%eax
 804a69a:	50                   	push   %eax
 804a69b:	e8 4d fa ff ff       	call   804a0ed <strlcpy>
  snprintf (h->size, sizeof h->size, "%011o", size);
 804a6a0:	ff 74 24 38          	pushl  0x38(%esp)
 804a6a4:	68 54 b7 04 08       	push   $0x804b754
 804a6a9:	6a 0c                	push   $0xc
 804a6ab:	8d 43 7c             	lea    0x7c(%ebx),%eax
 804a6ae:	50                   	push   %eax
 804a6af:	e8 5f f1 ff ff       	call   8049813 <snprintf>
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
 804a6b4:	83 c4 20             	add    $0x20,%esp
 804a6b7:	68 00 8c b7 43       	push   $0x43b78c00
 804a6bc:	68 54 b7 04 08       	push   $0x804b754
 804a6c1:	6a 0c                	push   $0xc
 804a6c3:	8d 83 88 00 00 00    	lea    0x88(%ebx),%eax
 804a6c9:	50                   	push   %eax
 804a6ca:	e8 44 f1 ff ff       	call   8049813 <snprintf>
  h->typeflag = type;
 804a6cf:	89 f0                	mov    %esi,%eax
 804a6d1:	88 83 9c 00 00 00    	mov    %al,0x9c(%ebx)
  strlcpy (h->magic, "ustar", sizeof h->magic);
 804a6d7:	83 c4 0c             	add    $0xc,%esp
 804a6da:	6a 06                	push   $0x6
 804a6dc:	68 5a b7 04 08       	push   $0x804b75a
 804a6e1:	8d 83 01 01 00 00    	lea    0x101(%ebx),%eax
 804a6e7:	50                   	push   %eax
 804a6e8:	e8 00 fa ff ff       	call   804a0ed <strlcpy>
  h->version[0] = h->version[1] = '0';
 804a6ed:	c6 83 08 01 00 00 30 	movb   $0x30,0x108(%ebx)
 804a6f4:	c6 83 07 01 00 00 30 	movb   $0x30,0x107(%ebx)
  strlcpy (h->gname, "root", sizeof h->gname);
 804a6fb:	83 c4 0c             	add    $0xc,%esp
 804a6fe:	6a 20                	push   $0x20
 804a700:	68 60 b7 04 08       	push   $0x804b760
 804a705:	8d 83 29 01 00 00    	lea    0x129(%ebx),%eax
 804a70b:	50                   	push   %eax
 804a70c:	e8 dc f9 ff ff       	call   804a0ed <strlcpy>
  strlcpy (h->uname, "root", sizeof h->uname);
 804a711:	83 c4 0c             	add    $0xc,%esp
 804a714:	6a 20                	push   $0x20
 804a716:	68 60 b7 04 08       	push   $0x804b760
 804a71b:	8d 83 09 01 00 00    	lea    0x109(%ebx),%eax
 804a721:	50                   	push   %eax
 804a722:	e8 c6 f9 ff ff       	call   804a0ed <strlcpy>
 804a727:	83 c4 10             	add    $0x10,%esp
 804a72a:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
{
  const uint8_t *header = (const uint8_t *) h;
  unsigned int chksum;
  size_t i;

  chksum = 0;
 804a72f:	ba 00 00 00 00       	mov    $0x0,%edx
      /* The ustar checksum is calculated as if the chksum field
         were all spaces. */
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
      const size_t chksum_end = chksum_start + sizeof h->chksum;
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
      chksum += in_chksum_field ? ' ' : header[i];
 804a734:	83 f8 07             	cmp    $0x7,%eax
 804a737:	76 0a                	jbe    804a743 <ustar_make_header+0x1a0>
 804a739:	0f b6 8c 03 94 00 00 	movzbl 0x94(%ebx,%eax,1),%ecx
 804a740:	00 
 804a741:	eb 05                	jmp    804a748 <ustar_make_header+0x1a5>
 804a743:	b9 20 00 00 00       	mov    $0x20,%ecx
 804a748:	01 ca                	add    %ecx,%edx
 804a74a:	83 c0 01             	add    $0x1,%eax
  const uint8_t *header = (const uint8_t *) h;
  unsigned int chksum;
  size_t i;

  chksum = 0;
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
 804a74d:	3d 6c 01 00 00       	cmp    $0x16c,%eax
 804a752:	75 e0                	jne    804a734 <ustar_make_header+0x191>
  h->version[0] = h->version[1] = '0';
  strlcpy (h->gname, "root", sizeof h->gname);
  strlcpy (h->uname, "root", sizeof h->uname);

  /* Compute and fill in final checksum. */
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
 804a754:	52                   	push   %edx
 804a755:	68 47 b7 04 08       	push   $0x804b747
 804a75a:	6a 08                	push   $0x8
 804a75c:	81 c3 94 00 00 00    	add    $0x94,%ebx
 804a762:	53                   	push   %ebx
 804a763:	e8 ab f0 ff ff       	call   8049813 <snprintf>

  return true;
 804a768:	83 c4 10             	add    $0x10,%esp
}
 804a76b:	89 e8                	mov    %ebp,%eax
 804a76d:	83 c4 0c             	add    $0xc,%esp
 804a770:	5b                   	pop    %ebx
 804a771:	5e                   	pop    %esi
 804a772:	5f                   	pop    %edi
 804a773:	5d                   	pop    %ebp
 804a774:	c3                   	ret    

0804a775 <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
 804a775:	53                   	push   %ebx
 804a776:	83 ec 18             	sub    $0x18,%esp
 804a779:	8b 5c 24 20          	mov    0x20(%esp),%ebx
 804a77d:	8d 93 00 02 00 00    	lea    0x200(%ebx),%edx
 804a783:	89 d8                	mov    %ebx,%eax
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
  while (cnt-- > 0)
    if (*block++ != 0)
 804a785:	83 c0 01             	add    $0x1,%eax
 804a788:	80 78 ff 00          	cmpb   $0x0,-0x1(%eax)
 804a78c:	0f 85 1d 01 00 00    	jne    804a8af <ustar_parse_header+0x13a>
/* Returns true if the CNT bytes starting at BLOCK are all zero,
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
  while (cnt-- > 0)
 804a792:	39 d0                	cmp    %edx,%eax
 804a794:	75 ef                	jne    804a785 <ustar_parse_header+0x10>
 804a796:	e9 3c 01 00 00       	jmp    804a8d7 <ustar_parse_header+0x162>

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
    return "not a ustar archive";
  else if (h->version[0] != '0' || h->version[1] != '0')
    return "invalid ustar version";
 804a79b:	b9 79 b7 04 08       	mov    $0x804b779,%ecx
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
    return "not a ustar archive";
  else if (h->version[0] != '0' || h->version[1] != '0')
 804a7a0:	80 bb 07 01 00 00 30 	cmpb   $0x30,0x107(%ebx)
 804a7a7:	0f 85 4d 01 00 00    	jne    804a8fa <ustar_parse_header+0x185>
 804a7ad:	80 bb 08 01 00 00 30 	cmpb   $0x30,0x108(%ebx)
 804a7b4:	0f 85 40 01 00 00    	jne    804a8fa <ustar_parse_header+0x185>
    return "invalid ustar version";
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
 804a7ba:	8d 83 94 00 00 00    	lea    0x94(%ebx),%eax
 804a7c0:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
 804a7c4:	ba 08 00 00 00       	mov    $0x8,%edx
 804a7c9:	e8 d1 fc ff ff       	call   804a49f <parse_octal_field>
    return "corrupt chksum field";
 804a7ce:	b9 8f b7 04 08       	mov    $0x804b78f,%ecx
  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
    return "not a ustar archive";
  else if (h->version[0] != '0' || h->version[1] != '0')
    return "invalid ustar version";
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
 804a7d3:	84 c0                	test   %al,%al
 804a7d5:	0f 84 1f 01 00 00    	je     804a8fa <ustar_parse_header+0x185>
 804a7db:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
 804a7e0:	ba 00 00 00 00       	mov    $0x0,%edx
      /* The ustar checksum is calculated as if the chksum field
         were all spaces. */
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
      const size_t chksum_end = chksum_start + sizeof h->chksum;
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
      chksum += in_chksum_field ? ' ' : header[i];
 804a7e5:	83 f8 07             	cmp    $0x7,%eax
 804a7e8:	76 0a                	jbe    804a7f4 <ustar_parse_header+0x7f>
 804a7ea:	0f b6 8c 03 94 00 00 	movzbl 0x94(%ebx,%eax,1),%ecx
 804a7f1:	00 
 804a7f2:	eb 05                	jmp    804a7f9 <ustar_parse_header+0x84>
 804a7f4:	b9 20 00 00 00       	mov    $0x20,%ecx
 804a7f9:	01 ca                	add    %ecx,%edx
 804a7fb:	83 c0 01             	add    $0x1,%eax
  const uint8_t *header = (const uint8_t *) h;
  unsigned int chksum;
  size_t i;

  chksum = 0;
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
 804a7fe:	3d 6c 01 00 00       	cmp    $0x16c,%eax
 804a803:	75 e0                	jne    804a7e5 <ustar_parse_header+0x70>
  else if (h->version[0] != '0' || h->version[1] != '0')
    return "invalid ustar version";
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
    return "corrupt chksum field";
  else if (chksum != calculate_chksum (h))
    return "checksum mismatch";
 804a805:	b9 a4 b7 04 08       	mov    $0x804b7a4,%ecx
    return "not a ustar archive";
  else if (h->version[0] != '0' || h->version[1] != '0')
    return "invalid ustar version";
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
    return "corrupt chksum field";
  else if (chksum != calculate_chksum (h))
 804a80a:	39 54 24 0c          	cmp    %edx,0xc(%esp)
 804a80e:	0f 85 e6 00 00 00    	jne    804a8fa <ustar_parse_header+0x185>
    return "checksum mismatch";
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
    return "file name too long";
 804a814:	b9 b6 b7 04 08       	mov    $0x804b7b6,%ecx
    return "invalid ustar version";
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
    return "corrupt chksum field";
  else if (chksum != calculate_chksum (h))
    return "checksum mismatch";
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
 804a819:	80 7b 63 00          	cmpb   $0x0,0x63(%ebx)
 804a81d:	0f 85 d7 00 00 00    	jne    804a8fa <ustar_parse_header+0x185>
 804a823:	80 bb 59 01 00 00 00 	cmpb   $0x0,0x159(%ebx)
 804a82a:	0f 85 ca 00 00 00    	jne    804a8fa <ustar_parse_header+0x185>
    return "file name too long";
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
 804a830:	0f b6 83 9c 00 00 00 	movzbl 0x9c(%ebx),%eax
 804a837:	3c 30                	cmp    $0x30,%al
 804a839:	74 0d                	je     804a848 <ustar_parse_header+0xd3>
    return "unimplemented file type";
 804a83b:	b9 c9 b7 04 08       	mov    $0x804b7c9,%ecx
    return "corrupt chksum field";
  else if (chksum != calculate_chksum (h))
    return "checksum mismatch";
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
    return "file name too long";
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
 804a840:	3c 35                	cmp    $0x35,%al
 804a842:	0f 85 b2 00 00 00    	jne    804a8fa <ustar_parse_header+0x185>
    return "unimplemented file type";
  if (h->typeflag == USTAR_REGULAR)
 804a848:	3c 30                	cmp    $0x30,%al
 804a84a:	75 30                	jne    804a87c <ustar_parse_header+0x107>
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
 804a84c:	8d 43 7c             	lea    0x7c(%ebx),%eax
 804a84f:	8d 4c 24 08          	lea    0x8(%esp),%ecx
 804a853:	ba 0c 00 00 00       	mov    $0xc,%edx
 804a858:	e8 42 fc ff ff       	call   804a49f <parse_octal_field>
        return "corrupt file size field";
 804a85d:	b9 e1 b7 04 08       	mov    $0x804b7e1,%ecx
    return "file name too long";
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
    return "unimplemented file type";
  if (h->typeflag == USTAR_REGULAR)
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
 804a862:	84 c0                	test   %al,%al
 804a864:	0f 84 90 00 00 00    	je     804a8fa <ustar_parse_header+0x185>
        return "corrupt file size field";
      else if (size_ul > INT_MAX)
        return "file too large";
 804a86a:	b9 f9 b7 04 08       	mov    $0x804b7f9,%ecx
    return "unimplemented file type";
  if (h->typeflag == USTAR_REGULAR)
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
        return "corrupt file size field";
      else if (size_ul > INT_MAX)
 804a86f:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
 804a874:	0f 88 80 00 00 00    	js     804a8fa <ustar_parse_header+0x185>
 804a87a:	eb 08                	jmp    804a884 <ustar_parse_header+0x10f>
        return "file too large";
    }
  else
    size_ul = 0;
 804a87c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804a883:	00 

  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
 804a884:	89 d8                	mov    %ebx,%eax
 804a886:	e8 97 fc ff ff       	call   804a522 <strip_antisocial_prefixes>
 804a88b:	8b 4c 24 24          	mov    0x24(%esp),%ecx
 804a88f:	89 01                	mov    %eax,(%ecx)
  *type = h->typeflag;
 804a891:	0f be 83 9c 00 00 00 	movsbl 0x9c(%ebx),%eax
 804a898:	8b 5c 24 28          	mov    0x28(%esp),%ebx
 804a89c:	89 03                	mov    %eax,(%ebx)
  *size = size_ul;
 804a89e:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a8a2:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 804a8a6:	89 03                	mov    %eax,(%ebx)
  return NULL;
 804a8a8:	b9 00 00 00 00       	mov    $0x0,%ecx
 804a8ad:	eb 4b                	jmp    804a8fa <ustar_parse_header+0x185>
      *size = 0;
      return NULL;
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
 804a8af:	83 ec 04             	sub    $0x4,%esp
 804a8b2:	6a 06                	push   $0x6
 804a8b4:	68 5a b7 04 08       	push   $0x804b75a
 804a8b9:	8d 83 01 01 00 00    	lea    0x101(%ebx),%eax
 804a8bf:	50                   	push   %eax
 804a8c0:	e8 03 f3 ff ff       	call   8049bc8 <memcmp>
 804a8c5:	83 c4 10             	add    $0x10,%esp
    return "not a ustar archive";
 804a8c8:	b9 65 b7 04 08       	mov    $0x804b765,%ecx
      *size = 0;
      return NULL;
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
 804a8cd:	85 c0                	test   %eax,%eax
 804a8cf:	0f 84 c6 fe ff ff    	je     804a79b <ustar_parse_header+0x26>
 804a8d5:	eb 23                	jmp    804a8fa <ustar_parse_header+0x185>
  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
    {
      *file_name = NULL;
 804a8d7:	8b 44 24 24          	mov    0x24(%esp),%eax
 804a8db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
 804a8e1:	8b 44 24 28          	mov    0x28(%esp),%eax
 804a8e5:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
 804a8eb:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 804a8ef:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
 804a8f5:	b9 00 00 00 00       	mov    $0x0,%ecx
  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
  *type = h->typeflag;
  *size = size_ul;
  return NULL;
}
 804a8fa:	89 c8                	mov    %ecx,%eax
 804a8fc:	83 c4 18             	add    $0x18,%esp
 804a8ff:	5b                   	pop    %ebx
 804a900:	c3                   	ret    

0804a901 <debug_panic>:
/* Aborts the user program, printing the source file name, line
   number, and function name, plus a user-specific message. */
void
debug_panic (const char *file, int line, const char *function,
             const char *message, ...)
{
 804a901:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  printf ("User process ABORT at %s:%d in %s(): ", file, line, function);
 804a904:	ff 74 24 18          	pushl  0x18(%esp)
 804a908:	ff 74 24 18          	pushl  0x18(%esp)
 804a90c:	ff 74 24 18          	pushl  0x18(%esp)
 804a910:	68 08 bb 04 08       	push   $0x804bb08
 804a915:	e8 ec e7 ff ff       	call   8049106 <printf>

  va_start (args, message);
 804a91a:	8d 44 24 30          	lea    0x30(%esp),%eax
  vprintf (message, args);
 804a91e:	83 c4 08             	add    $0x8,%esp
 804a921:	50                   	push   %eax
 804a922:	ff 74 24 28          	pushl  0x28(%esp)
 804a926:	e8 82 02 00 00       	call   804abad <vprintf>
  printf ("\n");
 804a92b:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 804a932:	e8 dc 01 00 00       	call   804ab13 <putchar>
  va_end (args);

  debug_backtrace ();
 804a937:	e8 a3 02 00 00       	call   804abdf <debug_backtrace>
  
  exit (1);
 804a93c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a943:	e8 20 00 00 00       	call   804a968 <exit>

0804a948 <halt>:
          retval;                                               \
        })

void
halt (void) 
{
 804a948:	83 ec 0c             	sub    $0xc,%esp
  syscall0 (SYS_HALT);
 804a94b:	6a 00                	push   $0x0
 804a94d:	cd 30                	int    $0x30
 804a94f:	83 c4 04             	add    $0x4,%esp
  NOT_REACHED ();
 804a952:	68 b0 ba 04 08       	push   $0x804bab0
 804a957:	68 58 b4 04 08       	push   $0x804b458
 804a95c:	6a 47                	push   $0x47
 804a95e:	68 08 b8 04 08       	push   $0x804b808
 804a963:	e8 99 ff ff ff       	call   804a901 <debug_panic>

0804a968 <exit>:
}

void
exit (int status)
{
 804a968:	83 ec 0c             	sub    $0xc,%esp
  syscall1 (SYS_EXIT, status);
 804a96b:	8b 44 24 10          	mov    0x10(%esp),%eax
 804a96f:	50                   	push   %eax
 804a970:	6a 01                	push   $0x1
 804a972:	cd 30                	int    $0x30
 804a974:	83 c4 08             	add    $0x8,%esp
  NOT_REACHED ();
 804a977:	68 b0 ba 04 08       	push   $0x804bab0
 804a97c:	68 50 b4 04 08       	push   $0x804b450
 804a981:	6a 4e                	push   $0x4e
 804a983:	68 08 b8 04 08       	push   $0x804b808
 804a988:	e8 74 ff ff ff       	call   804a901 <debug_panic>

0804a98d <exec>:
}

pid_t
exec (const char *file)
{
  return (pid_t) syscall1 (SYS_EXEC, file);
 804a98d:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a991:	50                   	push   %eax
 804a992:	6a 02                	push   $0x2
 804a994:	cd 30                	int    $0x30
 804a996:	83 c4 08             	add    $0x8,%esp
}
 804a999:	c3                   	ret    

0804a99a <wait>:

int
wait (pid_t pid)
{
  return syscall1 (SYS_WAIT, pid);
 804a99a:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a99e:	50                   	push   %eax
 804a99f:	6a 03                	push   $0x3
 804a9a1:	cd 30                	int    $0x30
 804a9a3:	83 c4 08             	add    $0x8,%esp
}
 804a9a6:	c3                   	ret    

0804a9a7 <create>:

bool
create (const char *file, unsigned initial_size)
{
  return syscall2 (SYS_CREATE, file, initial_size);
 804a9a7:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a9ab:	8b 4c 24 04          	mov    0x4(%esp),%ecx
 804a9af:	50                   	push   %eax
 804a9b0:	51                   	push   %ecx
 804a9b1:	6a 04                	push   $0x4
 804a9b3:	cd 30                	int    $0x30
 804a9b5:	83 c4 0c             	add    $0xc,%esp
 804a9b8:	85 c0                	test   %eax,%eax
 804a9ba:	0f 95 c0             	setne  %al
}
 804a9bd:	c3                   	ret    

0804a9be <remove>:

bool
remove (const char *file)
{
  return syscall1 (SYS_REMOVE, file);
 804a9be:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a9c2:	50                   	push   %eax
 804a9c3:	6a 05                	push   $0x5
 804a9c5:	cd 30                	int    $0x30
 804a9c7:	83 c4 08             	add    $0x8,%esp
 804a9ca:	85 c0                	test   %eax,%eax
 804a9cc:	0f 95 c0             	setne  %al
}
 804a9cf:	c3                   	ret    

0804a9d0 <open>:

int
open (const char *file)
{
  return syscall1 (SYS_OPEN, file);
 804a9d0:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a9d4:	50                   	push   %eax
 804a9d5:	6a 06                	push   $0x6
 804a9d7:	cd 30                	int    $0x30
 804a9d9:	83 c4 08             	add    $0x8,%esp
}
 804a9dc:	c3                   	ret    

0804a9dd <filesize>:

int
filesize (int fd) 
{
  return syscall1 (SYS_FILESIZE, fd);
 804a9dd:	8b 44 24 04          	mov    0x4(%esp),%eax
 804a9e1:	50                   	push   %eax
 804a9e2:	6a 07                	push   $0x7
 804a9e4:	cd 30                	int    $0x30
 804a9e6:	83 c4 08             	add    $0x8,%esp
}
 804a9e9:	c3                   	ret    

0804a9ea <read>:

int
read (int fd, void *buffer, unsigned size)
{
  return syscall3 (SYS_READ, fd, buffer, size);
 804a9ea:	8b 44 24 0c          	mov    0xc(%esp),%eax
 804a9ee:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 804a9f2:	8b 54 24 04          	mov    0x4(%esp),%edx
 804a9f6:	50                   	push   %eax
 804a9f7:	51                   	push   %ecx
 804a9f8:	52                   	push   %edx
 804a9f9:	6a 08                	push   $0x8
 804a9fb:	cd 30                	int    $0x30
 804a9fd:	83 c4 10             	add    $0x10,%esp
}
 804aa00:	c3                   	ret    

0804aa01 <write>:

int
write (int fd, const void *buffer, unsigned size)
{
  return syscall3 (SYS_WRITE, fd, buffer, size);
 804aa01:	8b 44 24 0c          	mov    0xc(%esp),%eax
 804aa05:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 804aa09:	8b 54 24 04          	mov    0x4(%esp),%edx
 804aa0d:	50                   	push   %eax
 804aa0e:	51                   	push   %ecx
 804aa0f:	52                   	push   %edx
 804aa10:	6a 09                	push   $0x9
 804aa12:	cd 30                	int    $0x30
 804aa14:	83 c4 10             	add    $0x10,%esp
}
 804aa17:	c3                   	ret    

0804aa18 <seek>:

void
seek (int fd, unsigned position) 
{
  syscall2 (SYS_SEEK, fd, position);
 804aa18:	8b 44 24 08          	mov    0x8(%esp),%eax
 804aa1c:	8b 4c 24 04          	mov    0x4(%esp),%ecx
 804aa20:	50                   	push   %eax
 804aa21:	51                   	push   %ecx
 804aa22:	6a 0a                	push   $0xa
 804aa24:	cd 30                	int    $0x30
 804aa26:	83 c4 0c             	add    $0xc,%esp
 804aa29:	c3                   	ret    

0804aa2a <tell>:
}

unsigned
tell (int fd) 
{
  return syscall1 (SYS_TELL, fd);
 804aa2a:	8b 44 24 04          	mov    0x4(%esp),%eax
 804aa2e:	50                   	push   %eax
 804aa2f:	6a 0b                	push   $0xb
 804aa31:	cd 30                	int    $0x30
 804aa33:	83 c4 08             	add    $0x8,%esp
}
 804aa36:	c3                   	ret    

0804aa37 <close>:

void
close (int fd)
{
  syscall1 (SYS_CLOSE, fd);
 804aa37:	8b 44 24 04          	mov    0x4(%esp),%eax
 804aa3b:	50                   	push   %eax
 804aa3c:	6a 0c                	push   $0xc
 804aa3e:	cd 30                	int    $0x30
 804aa40:	83 c4 08             	add    $0x8,%esp
 804aa43:	c3                   	ret    

0804aa44 <mmap>:
}

mapid_t
mmap (int fd, void *addr)
{
  return syscall2 (SYS_MMAP, fd, addr);
 804aa44:	8b 44 24 08          	mov    0x8(%esp),%eax
 804aa48:	8b 4c 24 04          	mov    0x4(%esp),%ecx
 804aa4c:	50                   	push   %eax
 804aa4d:	51                   	push   %ecx
 804aa4e:	6a 0d                	push   $0xd
 804aa50:	cd 30                	int    $0x30
 804aa52:	83 c4 0c             	add    $0xc,%esp
}
 804aa55:	c3                   	ret    

0804aa56 <munmap>:

void
munmap (mapid_t mapid)
{
  syscall1 (SYS_MUNMAP, mapid);
 804aa56:	8b 44 24 04          	mov    0x4(%esp),%eax
 804aa5a:	50                   	push   %eax
 804aa5b:	6a 0e                	push   $0xe
 804aa5d:	cd 30                	int    $0x30
 804aa5f:	83 c4 08             	add    $0x8,%esp
 804aa62:	c3                   	ret    

0804aa63 <chdir>:
}

bool
chdir (const char *dir)
{
  return syscall1 (SYS_CHDIR, dir);
 804aa63:	8b 44 24 04          	mov    0x4(%esp),%eax
 804aa67:	50                   	push   %eax
 804aa68:	6a 0f                	push   $0xf
 804aa6a:	cd 30                	int    $0x30
 804aa6c:	83 c4 08             	add    $0x8,%esp
 804aa6f:	85 c0                	test   %eax,%eax
 804aa71:	0f 95 c0             	setne  %al
}
 804aa74:	c3                   	ret    

0804aa75 <mkdir>:

bool
mkdir (const char *dir)
{
  return syscall1 (SYS_MKDIR, dir);
 804aa75:	8b 44 24 04          	mov    0x4(%esp),%eax
 804aa79:	50                   	push   %eax
 804aa7a:	6a 10                	push   $0x10
 804aa7c:	cd 30                	int    $0x30
 804aa7e:	83 c4 08             	add    $0x8,%esp
 804aa81:	85 c0                	test   %eax,%eax
 804aa83:	0f 95 c0             	setne  %al
}
 804aa86:	c3                   	ret    

0804aa87 <readdir>:

bool
readdir (int fd, char name[READDIR_MAX_LEN + 1]) 
{
  return syscall2 (SYS_READDIR, fd, name);
 804aa87:	8b 44 24 08          	mov    0x8(%esp),%eax
 804aa8b:	8b 4c 24 04          	mov    0x4(%esp),%ecx
 804aa8f:	50                   	push   %eax
 804aa90:	51                   	push   %ecx
 804aa91:	6a 11                	push   $0x11
 804aa93:	cd 30                	int    $0x30
 804aa95:	83 c4 0c             	add    $0xc,%esp
 804aa98:	85 c0                	test   %eax,%eax
 804aa9a:	0f 95 c0             	setne  %al
}
 804aa9d:	c3                   	ret    

0804aa9e <isdir>:

bool
isdir (int fd) 
{
  return syscall1 (SYS_ISDIR, fd);
 804aa9e:	8b 44 24 04          	mov    0x4(%esp),%eax
 804aaa2:	50                   	push   %eax
 804aaa3:	6a 12                	push   $0x12
 804aaa5:	cd 30                	int    $0x30
 804aaa7:	83 c4 08             	add    $0x8,%esp
 804aaaa:	85 c0                	test   %eax,%eax
 804aaac:	0f 95 c0             	setne  %al
}
 804aaaf:	c3                   	ret    

0804aab0 <inumber>:

int
inumber (int fd) 
{
  return syscall1 (SYS_INUMBER, fd);
 804aab0:	8b 44 24 04          	mov    0x4(%esp),%eax
 804aab4:	50                   	push   %eax
 804aab5:	6a 13                	push   $0x13
 804aab7:	cd 30                	int    $0x30
 804aab9:	83 c4 08             	add    $0x8,%esp
}
 804aabc:	c3                   	ret    

0804aabd <flush>:
}

/* Flushes the buffer in AUX. */
static void
flush (struct vhprintf_aux *aux)
{
 804aabd:	53                   	push   %ebx
 804aabe:	83 ec 08             	sub    $0x8,%esp
 804aac1:	89 c3                	mov    %eax,%ebx
  if (aux->p > aux->buf)
 804aac3:	8b 40 40             	mov    0x40(%eax),%eax
 804aac6:	39 d8                	cmp    %ebx,%eax
 804aac8:	76 12                	jbe    804aadc <flush+0x1f>
    write (aux->handle, aux->buf, aux->p - aux->buf);
 804aaca:	83 ec 04             	sub    $0x4,%esp
 804aacd:	29 d8                	sub    %ebx,%eax
 804aacf:	50                   	push   %eax
 804aad0:	53                   	push   %ebx
 804aad1:	ff 73 48             	pushl  0x48(%ebx)
 804aad4:	e8 28 ff ff ff       	call   804aa01 <write>
 804aad9:	83 c4 10             	add    $0x10,%esp
  aux->p = aux->buf;
 804aadc:	89 5b 40             	mov    %ebx,0x40(%ebx)
}
 804aadf:	83 c4 08             	add    $0x8,%esp
 804aae2:	5b                   	pop    %ebx
 804aae3:	c3                   	ret    

0804aae4 <add_char>:

/* Adds C to the buffer in AUX, flushing it if the buffer fills
   up. */
static void
add_char (char c, void *aux_) 
{
 804aae4:	53                   	push   %ebx
 804aae5:	83 ec 08             	sub    $0x8,%esp
 804aae8:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  struct vhprintf_aux *aux = aux_;
  *aux->p++ = c;
 804aaec:	8b 43 40             	mov    0x40(%ebx),%eax
 804aaef:	8d 50 01             	lea    0x1(%eax),%edx
 804aaf2:	89 53 40             	mov    %edx,0x40(%ebx)
 804aaf5:	8b 54 24 10          	mov    0x10(%esp),%edx
 804aaf9:	88 10                	mov    %dl,(%eax)
  if (aux->p >= aux->buf + sizeof aux->buf)
 804aafb:	8d 43 40             	lea    0x40(%ebx),%eax
 804aafe:	39 43 40             	cmp    %eax,0x40(%ebx)
 804ab01:	72 07                	jb     804ab0a <add_char+0x26>
    flush (aux);
 804ab03:	89 d8                	mov    %ebx,%eax
 804ab05:	e8 b3 ff ff ff       	call   804aabd <flush>
  aux->char_cnt++;
 804ab0a:	83 43 44 01          	addl   $0x1,0x44(%ebx)
}
 804ab0e:	83 c4 08             	add    $0x8,%esp
 804ab11:	5b                   	pop    %ebx
 804ab12:	c3                   	ret    

0804ab13 <putchar>:
}

/* Writes C to the console. */
int
putchar (int c) 
{
 804ab13:	53                   	push   %ebx
 804ab14:	83 ec 1c             	sub    $0x1c,%esp
 804ab17:	8b 5c 24 24          	mov    0x24(%esp),%ebx
  char c2 = c;
 804ab1b:	88 5c 24 13          	mov    %bl,0x13(%esp)
  write (STDOUT_FILENO, &c2, 1);
 804ab1f:	6a 01                	push   $0x1
 804ab21:	8d 44 24 17          	lea    0x17(%esp),%eax
 804ab25:	50                   	push   %eax
 804ab26:	6a 01                	push   $0x1
 804ab28:	e8 d4 fe ff ff       	call   804aa01 <write>
  return c;
}
 804ab2d:	89 d8                	mov    %ebx,%eax
 804ab2f:	83 c4 28             	add    $0x28,%esp
 804ab32:	5b                   	pop    %ebx
 804ab33:	c3                   	ret    

0804ab34 <puts>:

/* Writes string S to the console, followed by a new-line
   character. */
int
puts (const char *s) 
{
 804ab34:	57                   	push   %edi
 804ab35:	83 ec 0c             	sub    $0xc,%esp
 804ab38:	8b 54 24 14          	mov    0x14(%esp),%edx
  write (STDOUT_FILENO, s, strlen (s));
 804ab3c:	b8 00 00 00 00       	mov    $0x0,%eax
 804ab41:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 804ab46:	89 d7                	mov    %edx,%edi
 804ab48:	f2 ae                	repnz scas %es:(%edi),%al
 804ab4a:	f7 d1                	not    %ecx
 804ab4c:	83 e9 01             	sub    $0x1,%ecx
 804ab4f:	51                   	push   %ecx
 804ab50:	52                   	push   %edx
 804ab51:	6a 01                	push   $0x1
 804ab53:	e8 a9 fe ff ff       	call   804aa01 <write>
  putchar ('\n');
 804ab58:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 804ab5f:	e8 af ff ff ff       	call   804ab13 <putchar>

  return 0;
}
 804ab64:	b8 00 00 00 00       	mov    $0x0,%eax
 804ab69:	83 c4 18             	add    $0x18,%esp
 804ab6c:	5f                   	pop    %edi
 804ab6d:	c3                   	ret    

0804ab6e <vhprintf>:
/* Formats the printf() format specification FORMAT with
   arguments given in ARGS and writes the output to the given
   HANDLE. */
int
vhprintf (int handle, const char *format, va_list args) 
{
 804ab6e:	53                   	push   %ebx
 804ab6f:	83 ec 58             	sub    $0x58,%esp
  struct vhprintf_aux aux;
  aux.p = aux.buf;
 804ab72:	8d 5c 24 04          	lea    0x4(%esp),%ebx
 804ab76:	89 5c 24 44          	mov    %ebx,0x44(%esp)
  aux.char_cnt = 0;
 804ab7a:	c7 44 24 48 00 00 00 	movl   $0x0,0x48(%esp)
 804ab81:	00 
  aux.handle = handle;
 804ab82:	8b 44 24 60          	mov    0x60(%esp),%eax
 804ab86:	89 44 24 4c          	mov    %eax,0x4c(%esp)
  __vprintf (format, args, add_char, &aux);
 804ab8a:	53                   	push   %ebx
 804ab8b:	68 e4 aa 04 08       	push   $0x804aae4
 804ab90:	ff 74 24 70          	pushl  0x70(%esp)
 804ab94:	ff 74 24 70          	pushl  0x70(%esp)
 804ab98:	e8 9e e5 ff ff       	call   804913b <__vprintf>
  flush (&aux);
 804ab9d:	89 d8                	mov    %ebx,%eax
 804ab9f:	e8 19 ff ff ff       	call   804aabd <flush>
  return aux.char_cnt;
}
 804aba4:	8b 44 24 58          	mov    0x58(%esp),%eax
 804aba8:	83 c4 68             	add    $0x68,%esp
 804abab:	5b                   	pop    %ebx
 804abac:	c3                   	ret    

0804abad <vprintf>:

/* The standard vprintf() function,
   which is like printf() but uses a va_list. */
int
vprintf (const char *format, va_list args) 
{
 804abad:	83 ec 10             	sub    $0x10,%esp
  return vhprintf (STDOUT_FILENO, format, args);
 804abb0:	ff 74 24 18          	pushl  0x18(%esp)
 804abb4:	ff 74 24 18          	pushl  0x18(%esp)
 804abb8:	6a 01                	push   $0x1
 804abba:	e8 af ff ff ff       	call   804ab6e <vhprintf>
}
 804abbf:	83 c4 1c             	add    $0x1c,%esp
 804abc2:	c3                   	ret    

0804abc3 <hprintf>:

/* Like printf(), but writes output to the given HANDLE. */
int
hprintf (int handle, const char *format, ...) 
{
 804abc3:	83 ec 0c             	sub    $0xc,%esp
  va_list args;
  int retval;

  va_start (args, format);
 804abc6:	8d 44 24 18          	lea    0x18(%esp),%eax
  retval = vhprintf (handle, format, args);
 804abca:	83 ec 04             	sub    $0x4,%esp
 804abcd:	50                   	push   %eax
 804abce:	ff 74 24 1c          	pushl  0x1c(%esp)
 804abd2:	ff 74 24 1c          	pushl  0x1c(%esp)
 804abd6:	e8 93 ff ff ff       	call   804ab6e <vhprintf>
  va_end (args);

  return retval;
}
 804abdb:	83 c4 1c             	add    $0x1c,%esp
 804abde:	c3                   	ret    

0804abdf <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
 804abdf:	55                   	push   %ebp
 804abe0:	89 e5                	mov    %esp,%ebp
 804abe2:	53                   	push   %ebx
 804abe3:	83 ec 0c             	sub    $0xc,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
 804abe6:	ff 75 04             	pushl  0x4(%ebp)
 804abe9:	68 21 b8 04 08       	push   $0x804b821
 804abee:	e8 13 e5 ff ff       	call   8049106 <printf>
  for (frame = __builtin_frame_address (1);
 804abf3:	8b 5d 00             	mov    0x0(%ebp),%ebx
 804abf6:	83 c4 10             	add    $0x10,%esp
 804abf9:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
 804abff:	76 27                	jbe    804ac28 <debug_backtrace+0x49>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
 804ac01:	83 3b 00             	cmpl   $0x0,(%ebx)
 804ac04:	74 22                	je     804ac28 <debug_backtrace+0x49>
       frame = frame[0]) 
    printf (" %p", frame[1]);
 804ac06:	83 ec 08             	sub    $0x8,%esp
 804ac09:	ff 73 04             	pushl  0x4(%ebx)
 804ac0c:	68 2c b8 04 08       	push   $0x804b82c
 804ac11:	e8 f0 e4 ff ff       	call   8049106 <printf>
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
 804ac16:	8b 1b                	mov    (%ebx),%ebx
{
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
 804ac18:	83 c4 10             	add    $0x10,%esp
 804ac1b:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
 804ac21:	76 05                	jbe    804ac28 <debug_backtrace+0x49>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
 804ac23:	83 3b 00             	cmpl   $0x0,(%ebx)
 804ac26:	75 de                	jne    804ac06 <debug_backtrace+0x27>
       frame = frame[0]) 
    printf (" %p", frame[1]);
  printf (".\n");
 804ac28:	83 ec 0c             	sub    $0xc,%esp
 804ac2b:	68 33 b7 04 08       	push   $0x804b733
 804ac30:	e8 ff fe ff ff       	call   804ab34 <puts>

  if (!explained) 
 804ac35:	83 c4 10             	add    $0x10,%esp
 804ac38:	80 3d 40 d7 04 08 00 	cmpb   $0x0,0x804d740
 804ac3f:	75 17                	jne    804ac58 <debug_backtrace+0x79>
    {
      explained = true;
 804ac41:	c6 05 40 d7 04 08 01 	movb   $0x1,0x804d740
      printf ("The `backtrace' program can make call stacks useful.\n"
 804ac48:	83 ec 0c             	sub    $0xc,%esp
 804ac4b:	68 30 bb 04 08       	push   $0x804bb30
 804ac50:	e8 df fe ff ff       	call   804ab34 <puts>
 804ac55:	83 c4 10             	add    $0x10,%esp
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
 804ac58:	8b 5d fc             	mov    -0x4(%ebp),%ebx
 804ac5b:	c9                   	leave  
 804ac5c:	c3                   	ret    
