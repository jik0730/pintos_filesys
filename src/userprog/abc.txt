
build/tests/userprog/read-normal:     file format elf32-i386


Disassembly of section .text:

080480a0 <test_main>:
#include "tests/lib.h"
#include "tests/main.h"

void
test_main (void) 
{
 80480a0:	83 ec 1c             	sub    $0x1c,%esp
  check_file ("sample.txt", sample, sizeof sample - 1);
 80480a3:	c7 44 24 08 ef 00 00 	movl   $0xef,0x8(%esp)
 80480aa:	00 
 80480ab:	c7 44 24 04 80 bd 04 	movl   $0x804bd80,0x4(%esp)
 80480b2:	08 
 80480b3:	c7 04 24 bc a8 04 08 	movl   $0x804a8bc,(%esp)
 80480ba:	e8 e2 05 00 00       	call   80486a1 <check_file>
}
 80480bf:	83 c4 1c             	add    $0x1c,%esp
 80480c2:	c3                   	ret    
 80480c3:	90                   	nop

080480c4 <main>:
#include "tests/lib.h"
#include "tests/main.h"

int
main (int argc UNUSED, char *argv[]) 
{
 80480c4:	55                   	push   %ebp
 80480c5:	89 e5                	mov    %esp,%ebp
 80480c7:	83 e4 f0             	and    $0xfffffff0,%esp
 80480ca:	83 ec 10             	sub    $0x10,%esp
  test_name = argv[0];
 80480cd:	8b 45 0c             	mov    0xc(%ebp),%eax
 80480d0:	8b 00                	mov    (%eax),%eax
 80480d2:	a3 c8 c3 04 08       	mov    %eax,0x804c3c8

  msg ("begin");
 80480d7:	c7 04 24 c7 a8 04 08 	movl   $0x804a8c7,(%esp)
 80480de:	e8 12 01 00 00       	call   80481f5 <msg>
  random_init (0);
 80480e3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80480ea:	e8 45 06 00 00       	call   8048734 <random_init>
  test_main ();
 80480ef:	e8 ac ff ff ff       	call   80480a0 <test_main>
  msg ("end");
 80480f4:	c7 04 24 cd a8 04 08 	movl   $0x804a8cd,(%esp)
 80480fb:	e8 f5 00 00 00       	call   80481f5 <msg>
  return 0;
}
 8048100:	b8 00 00 00 00       	mov    $0x0,%eax
 8048105:	c9                   	leave  
 8048106:	c3                   	ret    
 8048107:	90                   	nop

08048108 <vmsg>:
const char *test_name;
bool quiet = false;

static void
vmsg (const char *format, va_list args, const char *suffix) 
{
 8048108:	83 ec 3c             	sub    $0x3c,%esp
 804810b:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
 804810f:	89 74 24 30          	mov    %esi,0x30(%esp)
 8048113:	89 7c 24 34          	mov    %edi,0x34(%esp)
 8048117:	89 6c 24 38          	mov    %ebp,0x38(%esp)
 804811b:	89 44 24 18          	mov    %eax,0x18(%esp)
 804811f:	89 d3                	mov    %edx,%ebx
 8048121:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
     that'll (typically) ensure that it gets sent to the console
     atomically.  Otherwise kernel messages like "foo: exit(0)"
     can end up being interleaved if we're unlucky. */
  static char buf[1024];

  snprintf (buf, sizeof buf, "(%s) ", test_name);
 8048125:	a1 c8 c3 04 08       	mov    0x804c3c8,%eax
 804812a:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804812e:	c7 44 24 08 d1 a8 04 	movl   $0x804a8d1,0x8(%esp)
 8048135:	08 
 8048136:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
 804813d:	00 
 804813e:	c7 04 24 c0 be 04 08 	movl   $0x804bec0,(%esp)
 8048145:	e8 78 13 00 00       	call   80494c2 <snprintf>
  vsnprintf (buf + strlen (buf), sizeof buf - strlen (buf), format, args);
 804814a:	be ff ff ff ff       	mov    $0xffffffff,%esi
 804814f:	bf c0 be 04 08       	mov    $0x804bec0,%edi
 8048154:	bd 00 00 00 00       	mov    $0x0,%ebp
 8048159:	89 f1                	mov    %esi,%ecx
 804815b:	89 e8                	mov    %ebp,%eax
 804815d:	f2 ae                	repnz scas %es:(%edi),%al
 804815f:	f7 d1                	not    %ecx
 8048161:	83 e9 01             	sub    $0x1,%ecx
 8048164:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 8048168:	8b 44 24 18          	mov    0x18(%esp),%eax
 804816c:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048170:	bb 00 04 00 00       	mov    $0x400,%ebx
 8048175:	89 d8                	mov    %ebx,%eax
 8048177:	29 c8                	sub    %ecx,%eax
 8048179:	89 44 24 04          	mov    %eax,0x4(%esp)
 804817d:	81 c1 c0 be 04 08    	add    $0x804bec0,%ecx
 8048183:	89 0c 24             	mov    %ecx,(%esp)
 8048186:	e8 ba 12 00 00       	call   8049445 <vsnprintf>
  strlcpy (buf + strlen (buf), suffix, sizeof buf - strlen (buf));
 804818b:	bf c0 be 04 08       	mov    $0x804bec0,%edi
 8048190:	89 f1                	mov    %esi,%ecx
 8048192:	89 e8                	mov    %ebp,%eax
 8048194:	f2 ae                	repnz scas %es:(%edi),%al
 8048196:	f7 d1                	not    %ecx
 8048198:	83 e9 01             	sub    $0x1,%ecx
 804819b:	29 cb                	sub    %ecx,%ebx
 804819d:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 80481a1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80481a5:	89 44 24 04          	mov    %eax,0x4(%esp)
 80481a9:	81 c1 c0 be 04 08    	add    $0x804bec0,%ecx
 80481af:	89 0c 24             	mov    %ecx,(%esp)
 80481b2:	e8 6b 1c 00 00       	call   8049e22 <strlcpy>
  write (STDOUT_FILENO, buf, strlen (buf));
 80481b7:	bf c0 be 04 08       	mov    $0x804bec0,%edi
 80481bc:	89 f1                	mov    %esi,%ecx
 80481be:	89 e8                	mov    %ebp,%eax
 80481c0:	f2 ae                	repnz scas %es:(%edi),%al
 80481c2:	89 ce                	mov    %ecx,%esi
 80481c4:	f7 d6                	not    %esi
 80481c6:	83 ee 01             	sub    $0x1,%esi
 80481c9:	89 74 24 08          	mov    %esi,0x8(%esp)
 80481cd:	c7 44 24 04 c0 be 04 	movl   $0x804bec0,0x4(%esp)
 80481d4:	08 
 80481d5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 80481dc:	e8 01 22 00 00       	call   804a3e2 <write>
}
 80481e1:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 80481e5:	8b 74 24 30          	mov    0x30(%esp),%esi
 80481e9:	8b 7c 24 34          	mov    0x34(%esp),%edi
 80481ed:	8b 6c 24 38          	mov    0x38(%esp),%ebp
 80481f1:	83 c4 3c             	add    $0x3c,%esp
 80481f4:	c3                   	ret    

080481f5 <msg>:

void
msg (const char *format, ...) 
{
 80481f5:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  if (quiet)
 80481f8:	80 3d a0 be 04 08 00 	cmpb   $0x0,0x804bea0
 80481ff:	75 12                	jne    8048213 <msg+0x1e>
    return;
  va_start (args, format);
  vmsg (format, args, "\n");
 8048201:	b9 df a8 04 08       	mov    $0x804a8df,%ecx
 8048206:	8d 54 24 14          	lea    0x14(%esp),%edx
 804820a:	8b 44 24 10          	mov    0x10(%esp),%eax
 804820e:	e8 f5 fe ff ff       	call   8048108 <vmsg>
  va_end (args);
}
 8048213:	83 c4 0c             	add    $0xc,%esp
 8048216:	c3                   	ret    

08048217 <fail>:

void
fail (const char *format, ...) 
{
 8048217:	83 ec 1c             	sub    $0x1c,%esp
  va_list args;

  va_start (args, format);
  vmsg (format, args, ": FAILED\n");
 804821a:	b9 d7 a8 04 08       	mov    $0x804a8d7,%ecx
 804821f:	8d 54 24 24          	lea    0x24(%esp),%edx
 8048223:	8b 44 24 20          	mov    0x20(%esp),%eax
 8048227:	e8 dc fe ff ff       	call   8048108 <vmsg>
  va_end (args);

  exit (1);
 804822c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8048233:	e8 0e 21 00 00       	call   804a346 <exit>

08048238 <shuffle>:
    }
}

void
shuffle (void *buf_, size_t cnt, size_t size) 
{
 8048238:	55                   	push   %ebp
 8048239:	57                   	push   %edi
 804823a:	56                   	push   %esi
 804823b:	53                   	push   %ebx
 804823c:	83 ec 1c             	sub    $0x1c,%esp
 804823f:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  char *buf = buf_;
  size_t i;

  for (i = 0; i < cnt; i++)
 8048243:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
 8048248:	74 66                	je     80482b0 <shuffle+0x78>
 804824a:	8b 6c 24 30          	mov    0x30(%esp),%ebp
 804824e:	be 00 00 00 00       	mov    $0x0,%esi
 8048253:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
    {
      size_t j = i + random_ulong () % (cnt - i);
 8048257:	e8 03 06 00 00       	call   804885f <random_ulong>
 804825c:	8b 4c 24 34          	mov    0x34(%esp),%ecx
 8048260:	29 f1                	sub    %esi,%ecx
 8048262:	ba 00 00 00 00       	mov    $0x0,%edx
 8048267:	f7 f1                	div    %ecx
 8048269:	01 f2                	add    %esi,%edx
      swap (buf + i * size, buf + j * size, size);
 804826b:	0f af d3             	imul   %ebx,%edx
 804826e:	03 54 24 30          	add    0x30(%esp),%edx
 8048272:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
{
  uint8_t *a = a_;
  uint8_t *b = b_;
  size_t i;

  for (i = 0; i < size; i++) 
 8048276:	85 db                	test   %ebx,%ebx
 8048278:	74 29                	je     80482a3 <shuffle+0x6b>
 804827a:	b8 00 00 00 00       	mov    $0x0,%eax
 804827f:	89 dd                	mov    %ebx,%ebp
    {
      uint8_t t = a[i];
 8048281:	0f b6 1c 01          	movzbl (%ecx,%eax,1),%ebx
 8048285:	88 5c 24 0b          	mov    %bl,0xb(%esp)
      a[i] = b[i];
 8048289:	0f b6 3c 02          	movzbl (%edx,%eax,1),%edi
 804828d:	89 fb                	mov    %edi,%ebx
 804828f:	88 1c 01             	mov    %bl,(%ecx,%eax,1)
      b[i] = t;
 8048292:	0f b6 5c 24 0b       	movzbl 0xb(%esp),%ebx
 8048297:	88 1c 02             	mov    %bl,(%edx,%eax,1)
{
  uint8_t *a = a_;
  uint8_t *b = b_;
  size_t i;

  for (i = 0; i < size; i++) 
 804829a:	83 c0 01             	add    $0x1,%eax
 804829d:	39 e8                	cmp    %ebp,%eax
 804829f:	75 e0                	jne    8048281 <shuffle+0x49>
 80482a1:	89 eb                	mov    %ebp,%ebx
shuffle (void *buf_, size_t cnt, size_t size) 
{
  char *buf = buf_;
  size_t i;

  for (i = 0; i < cnt; i++)
 80482a3:	83 c6 01             	add    $0x1,%esi
 80482a6:	01 5c 24 0c          	add    %ebx,0xc(%esp)
 80482aa:	3b 74 24 34          	cmp    0x34(%esp),%esi
 80482ae:	75 a7                	jne    8048257 <shuffle+0x1f>
    {
      size_t j = i + random_ulong () % (cnt - i);
      swap (buf + i * size, buf + j * size, size);
    }
}
 80482b0:	83 c4 1c             	add    $0x1c,%esp
 80482b3:	5b                   	pop    %ebx
 80482b4:	5e                   	pop    %esi
 80482b5:	5f                   	pop    %edi
 80482b6:	5d                   	pop    %ebp
 80482b7:	c3                   	ret    

080482b8 <exec_children>:

void
exec_children (const char *child_name, pid_t pids[], size_t child_cnt) 
{
 80482b8:	55                   	push   %ebp
 80482b9:	57                   	push   %edi
 80482ba:	56                   	push   %esi
 80482bb:	53                   	push   %ebx
 80482bc:	81 ec ac 00 00 00    	sub    $0xac,%esp
 80482c2:	8b ac 24 c4 00 00 00 	mov    0xc4(%esp),%ebp
 80482c9:	8b bc 24 c8 00 00 00 	mov    0xc8(%esp),%edi
  size_t i;

  for (i = 0; i < child_cnt; i++) 
 80482d0:	85 ff                	test   %edi,%edi
 80482d2:	74 7c                	je     8048350 <exec_children+0x98>
 80482d4:	bb 00 00 00 00       	mov    $0x0,%ebx
    {
      char cmd_line[128];
      snprintf (cmd_line, sizeof cmd_line, "%s %zu", child_name, i);
 80482d9:	8d 74 24 20          	lea    0x20(%esp),%esi
 80482dd:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 80482e1:	8b 84 24 c0 00 00 00 	mov    0xc0(%esp),%eax
 80482e8:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80482ec:	c7 44 24 08 e1 a8 04 	movl   $0x804a8e1,0x8(%esp)
 80482f3:	08 
 80482f4:	c7 44 24 04 80 00 00 	movl   $0x80,0x4(%esp)
 80482fb:	00 
 80482fc:	89 34 24             	mov    %esi,(%esp)
 80482ff:	e8 be 11 00 00       	call   80494c2 <snprintf>
      CHECK ((pids[i] = exec (cmd_line)) != PID_ERROR,
 8048304:	83 c3 01             	add    $0x1,%ebx
 8048307:	89 74 24 0c          	mov    %esi,0xc(%esp)
 804830b:	89 7c 24 08          	mov    %edi,0x8(%esp)
 804830f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8048313:	c7 04 24 e8 a8 04 08 	movl   $0x804a8e8,(%esp)
 804831a:	e8 d6 fe ff ff       	call   80481f5 <msg>
 804831f:	89 34 24             	mov    %esi,(%esp)
 8048322:	e8 51 20 00 00       	call   804a378 <exec>
 8048327:	89 44 9d fc          	mov    %eax,-0x4(%ebp,%ebx,4)
 804832b:	83 f8 ff             	cmp    $0xffffffff,%eax
 804832e:	75 1c                	jne    804834c <exec_children+0x94>
 8048330:	8d 44 24 20          	lea    0x20(%esp),%eax
 8048334:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048338:	89 7c 24 08          	mov    %edi,0x8(%esp)
 804833c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8048340:	c7 04 24 e8 a8 04 08 	movl   $0x804a8e8,(%esp)
 8048347:	e8 cb fe ff ff       	call   8048217 <fail>
void
exec_children (const char *child_name, pid_t pids[], size_t child_cnt) 
{
  size_t i;

  for (i = 0; i < child_cnt; i++) 
 804834c:	39 fb                	cmp    %edi,%ebx
 804834e:	75 8d                	jne    80482dd <exec_children+0x25>
      char cmd_line[128];
      snprintf (cmd_line, sizeof cmd_line, "%s %zu", child_name, i);
      CHECK ((pids[i] = exec (cmd_line)) != PID_ERROR,
             "exec child %zu of %zu: \"%s\"", i + 1, child_cnt, cmd_line);
    }
}
 8048350:	81 c4 ac 00 00 00    	add    $0xac,%esp
 8048356:	5b                   	pop    %ebx
 8048357:	5e                   	pop    %esi
 8048358:	5f                   	pop    %edi
 8048359:	5d                   	pop    %ebp
 804835a:	c3                   	ret    

0804835b <wait_children>:

void
wait_children (pid_t pids[], size_t child_cnt) 
{
 804835b:	55                   	push   %ebp
 804835c:	57                   	push   %edi
 804835d:	56                   	push   %esi
 804835e:	53                   	push   %ebx
 804835f:	83 ec 2c             	sub    $0x2c,%esp
 8048362:	8b 6c 24 40          	mov    0x40(%esp),%ebp
  size_t i;
  
  for (i = 0; i < child_cnt; i++) 
 8048366:	bb 00 00 00 00       	mov    $0x0,%ebx
 804836b:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
 8048370:	75 04                	jne    8048376 <wait_children+0x1b>
 8048372:	eb 5d                	jmp    80483d1 <wait_children+0x76>
    {
      int status = wait (pids[i]);
      CHECK (status == (int) i,
 8048374:	89 f3                	mov    %esi,%ebx
{
  size_t i;
  
  for (i = 0; i < child_cnt; i++) 
    {
      int status = wait (pids[i]);
 8048376:	8b 44 9d 00          	mov    0x0(%ebp,%ebx,4),%eax
 804837a:	89 04 24             	mov    %eax,(%esp)
 804837d:	e8 02 20 00 00       	call   804a384 <wait>
 8048382:	89 c7                	mov    %eax,%edi
      CHECK (status == (int) i,
 8048384:	8d 73 01             	lea    0x1(%ebx),%esi
 8048387:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 804838b:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804838f:	8b 44 24 44          	mov    0x44(%esp),%eax
 8048393:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048397:	89 74 24 04          	mov    %esi,0x4(%esp)
 804839b:	c7 04 24 48 ab 04 08 	movl   $0x804ab48,(%esp)
 80483a2:	e8 4e fe ff ff       	call   80481f5 <msg>
 80483a7:	39 df                	cmp    %ebx,%edi
 80483a9:	74 20                	je     80483cb <wait_children+0x70>
 80483ab:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 80483af:	89 7c 24 0c          	mov    %edi,0xc(%esp)
 80483b3:	8b 44 24 44          	mov    0x44(%esp),%eax
 80483b7:	89 44 24 08          	mov    %eax,0x8(%esp)
 80483bb:	89 74 24 04          	mov    %esi,0x4(%esp)
 80483bf:	c7 04 24 48 ab 04 08 	movl   $0x804ab48,(%esp)
 80483c6:	e8 4c fe ff ff       	call   8048217 <fail>
void
wait_children (pid_t pids[], size_t child_cnt) 
{
  size_t i;
  
  for (i = 0; i < child_cnt; i++) 
 80483cb:	3b 74 24 44          	cmp    0x44(%esp),%esi
 80483cf:	75 a3                	jne    8048374 <wait_children+0x19>
      int status = wait (pids[i]);
      CHECK (status == (int) i,
             "wait for child %zu of %zu returned %d (expected %zu)",
             i + 1, child_cnt, status, i);
    }
}
 80483d1:	83 c4 2c             	add    $0x2c,%esp
 80483d4:	5b                   	pop    %ebx
 80483d5:	5e                   	pop    %esi
 80483d6:	5f                   	pop    %edi
 80483d7:	5d                   	pop    %ebp
 80483d8:	c3                   	ret    

080483d9 <compare_bytes>:
}

void
compare_bytes (const void *read_data_, const void *expected_data_, size_t size,
               size_t ofs, const char *file_name) 
{
 80483d9:	83 ec 3c             	sub    $0x3c,%esp
 80483dc:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
 80483e0:	89 74 24 30          	mov    %esi,0x30(%esp)
 80483e4:	89 7c 24 34          	mov    %edi,0x34(%esp)
 80483e8:	89 6c 24 38          	mov    %ebp,0x38(%esp)
 80483ec:	8b 74 24 40          	mov    0x40(%esp),%esi
 80483f0:	8b 5c 24 44          	mov    0x44(%esp),%ebx
 80483f4:	8b 7c 24 48          	mov    0x48(%esp),%edi
  const uint8_t *read_data = read_data_;
  const uint8_t *expected_data = expected_data_;
  size_t i, j;
  size_t show_cnt;

  if (!memcmp (read_data, expected_data, size))
 80483f8:	89 7c 24 08          	mov    %edi,0x8(%esp)
 80483fc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8048400:	89 34 24             	mov    %esi,(%esp)
 8048403:	e8 6f 14 00 00       	call   8049877 <memcmp>
 8048408:	85 c0                	test   %eax,%eax
 804840a:	0f 84 5c 01 00 00    	je     804856c <compare_bytes+0x193>
    return;
  
  for (i = 0; i < size; i++)
 8048410:	85 ff                	test   %edi,%edi
 8048412:	0f 84 12 01 00 00    	je     804852a <compare_bytes+0x151>
    if (read_data[i] != expected_data[i])
 8048418:	bd 00 00 00 00       	mov    $0x0,%ebp
 804841d:	0f b6 03             	movzbl (%ebx),%eax
 8048420:	38 06                	cmp    %al,(%esi)
 8048422:	74 0b                	je     804842f <compare_bytes+0x56>
 8048424:	eb 10                	jmp    8048436 <compare_bytes+0x5d>
 8048426:	0f b6 14 2b          	movzbl (%ebx,%ebp,1),%edx
 804842a:	38 14 2e             	cmp    %dl,(%esi,%ebp,1)
 804842d:	75 07                	jne    8048436 <compare_bytes+0x5d>
  size_t show_cnt;

  if (!memcmp (read_data, expected_data, size))
    return;
  
  for (i = 0; i < size; i++)
 804842f:	83 c5 01             	add    $0x1,%ebp
 8048432:	39 fd                	cmp    %edi,%ebp
 8048434:	75 f0                	jne    8048426 <compare_bytes+0x4d>
    if (read_data[i] != expected_data[i])
      break;
  for (j = i + 1; j < size; j++)
 8048436:	8d 45 01             	lea    0x1(%ebp),%eax
 8048439:	39 c7                	cmp    %eax,%edi
 804843b:	76 1d                	jbe    804845a <compare_bytes+0x81>
    if (read_data[j] == expected_data[j])
 804843d:	0f b6 54 2b 01       	movzbl 0x1(%ebx,%ebp,1),%edx
 8048442:	38 54 2e 01          	cmp    %dl,0x1(%esi,%ebp,1)
 8048446:	75 0b                	jne    8048453 <compare_bytes+0x7a>
 8048448:	eb 10                	jmp    804845a <compare_bytes+0x81>
 804844a:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
 804844e:	38 14 06             	cmp    %dl,(%esi,%eax,1)
 8048451:	74 07                	je     804845a <compare_bytes+0x81>
    return;
  
  for (i = 0; i < size; i++)
    if (read_data[i] != expected_data[i])
      break;
  for (j = i + 1; j < size; j++)
 8048453:	83 c0 01             	add    $0x1,%eax
 8048456:	39 c7                	cmp    %eax,%edi
 8048458:	77 f0                	ja     804844a <compare_bytes+0x71>
    if (read_data[j] == expected_data[j])
      break;

  quiet = false;
 804845a:	c6 05 a0 be 04 08 00 	movb   $0x0,0x804bea0
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
 8048461:	01 6c 24 4c          	add    %ebp,0x4c(%esp)
 8048465:	89 c7                	mov    %eax,%edi
 8048467:	29 ef                	sub    %ebp,%edi
 8048469:	8b 44 24 50          	mov    0x50(%esp),%eax
 804846d:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048471:	8b 54 24 4c          	mov    0x4c(%esp),%edx
 8048475:	89 54 24 08          	mov    %edx,0x8(%esp)
 8048479:	89 7c 24 04          	mov    %edi,0x4(%esp)
 804847d:	c7 04 24 80 ab 04 08 	movl   $0x804ab80,(%esp)
 8048484:	e8 6c fd ff ff       	call   80481f5 <msg>
 8048489:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
       "from expected.", j - i, ofs + i, file_name);
  show_cnt = j - i;
  if (j - i > 64) 
 804848d:	83 ff 40             	cmp    $0x40,%edi
 8048490:	76 1c                	jbe    80484ae <compare_bytes+0xd5>
    {
      show_cnt = 64;
      msg ("Showing first differing %zu bytes.", show_cnt);
 8048492:	c7 44 24 04 40 00 00 	movl   $0x40,0x4(%esp)
 8048499:	00 
 804849a:	c7 04 24 c4 ab 04 08 	movl   $0x804abc4,(%esp)
 80484a1:	e8 4f fd ff ff       	call   80481f5 <msg>
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
       "from expected.", j - i, ofs + i, file_name);
  show_cnt = j - i;
  if (j - i > 64) 
    {
      show_cnt = 64;
 80484a6:	c7 44 24 1c 40 00 00 	movl   $0x40,0x1c(%esp)
 80484ad:	00 
      msg ("Showing first differing %zu bytes.", show_cnt);
    }
  msg ("Data actually read:");
 80484ae:	c7 04 24 04 a9 04 08 	movl   $0x804a904,(%esp)
 80484b5:	e8 3b fd ff ff       	call   80481f5 <msg>
  hex_dump (ofs + i, read_data + i, show_cnt, true);
 80484ba:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 80484c1:	00 
 80484c2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80484c6:	89 44 24 08          	mov    %eax,0x8(%esp)
 80484ca:	01 ee                	add    %ebp,%esi
 80484cc:	89 74 24 04          	mov    %esi,0x4(%esp)
 80484d0:	8b 54 24 4c          	mov    0x4c(%esp),%edx
 80484d4:	89 14 24             	mov    %edx,(%esp)
 80484d7:	e8 11 10 00 00       	call   80494ed <hex_dump>
  msg ("Expected data:");
 80484dc:	c7 04 24 18 a9 04 08 	movl   $0x804a918,(%esp)
 80484e3:	e8 0d fd ff ff       	call   80481f5 <msg>
  hex_dump (ofs + i, expected_data + i, show_cnt, true);
 80484e8:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 80484ef:	00 
 80484f0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80484f4:	89 44 24 08          	mov    %eax,0x8(%esp)
 80484f8:	01 eb                	add    %ebp,%ebx
 80484fa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 80484fe:	8b 54 24 4c          	mov    0x4c(%esp),%edx
 8048502:	89 14 24             	mov    %edx,(%esp)
 8048505:	e8 e3 0f 00 00       	call   80494ed <hex_dump>
  fail ("%zu bytes read starting at offset %zu in \"%s\" differ "
 804850a:	8b 44 24 50          	mov    0x50(%esp),%eax
 804850e:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048512:	8b 54 24 4c          	mov    0x4c(%esp),%edx
 8048516:	89 54 24 08          	mov    %edx,0x8(%esp)
 804851a:	89 7c 24 04          	mov    %edi,0x4(%esp)
 804851e:	c7 04 24 e8 ab 04 08 	movl   $0x804abe8,(%esp)
 8048525:	e8 ed fc ff ff       	call   8048217 <fail>
      break;
  for (j = i + 1; j < size; j++)
    if (read_data[j] == expected_data[j])
      break;

  quiet = false;
 804852a:	c6 05 a0 be 04 08 00 	movb   $0x0,0x804bea0
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
 8048531:	8b 44 24 50          	mov    0x50(%esp),%eax
 8048535:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048539:	8b 54 24 4c          	mov    0x4c(%esp),%edx
 804853d:	89 54 24 08          	mov    %edx,0x8(%esp)
 8048541:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 8048548:	00 
 8048549:	c7 04 24 80 ab 04 08 	movl   $0x804ab80,(%esp)
 8048550:	e8 a0 fc ff ff       	call   80481f5 <msg>
 8048555:	bd 00 00 00 00       	mov    $0x0,%ebp
 804855a:	bf 01 00 00 00       	mov    $0x1,%edi
 804855f:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
 8048566:	00 
 8048567:	e9 42 ff ff ff       	jmp    80484ae <compare_bytes+0xd5>
  hex_dump (ofs + i, read_data + i, show_cnt, true);
  msg ("Expected data:");
  hex_dump (ofs + i, expected_data + i, show_cnt, true);
  fail ("%zu bytes read starting at offset %zu in \"%s\" differ "
        "from expected", j - i, ofs + i, file_name);
}
 804856c:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8048570:	8b 74 24 30          	mov    0x30(%esp),%esi
 8048574:	8b 7c 24 34          	mov    0x34(%esp),%edi
 8048578:	8b 6c 24 38          	mov    0x38(%esp),%ebp
 804857c:	83 c4 3c             	add    $0x3c,%esp
 804857f:	c3                   	ret    

08048580 <check_file_handle>:
}

void
check_file_handle (int fd,
                   const char *file_name, const void *buf_, size_t size) 
{
 8048580:	55                   	push   %ebp
 8048581:	57                   	push   %edi
 8048582:	56                   	push   %esi
 8048583:	53                   	push   %ebx
 8048584:	81 ec 3c 02 00 00    	sub    $0x23c,%esp
 804858a:	8b ac 24 5c 02 00 00 	mov    0x25c(%esp),%ebp
  size_t file_size;

  /* Warn about file of wrong size.  Don't fail yet because we
     may still be able to get more information by reading the
     file. */
  file_size = filesize (fd);
 8048591:	8b 84 24 50 02 00 00 	mov    0x250(%esp),%eax
 8048598:	89 04 24             	mov    %eax,(%esp)
 804859b:	e8 22 1e 00 00       	call   804a3c2 <filesize>
 80485a0:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  if (file_size != size)
 80485a4:	39 e8                	cmp    %ebp,%eax
 80485a6:	74 1f                	je     80485c7 <check_file_handle+0x47>
    msg ("size of %s (%zu) differs from expected (%zu)",
 80485a8:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
 80485ac:	89 44 24 08          	mov    %eax,0x8(%esp)
 80485b0:	8b 84 24 54 02 00 00 	mov    0x254(%esp),%eax
 80485b7:	89 44 24 04          	mov    %eax,0x4(%esp)
 80485bb:	c7 04 24 2c ac 04 08 	movl   $0x804ac2c,(%esp)
 80485c2:	e8 2e fc ff ff       	call   80481f5 <msg>
          file_name, file_size, size);

  /* Read the file block-by-block, comparing data as we go. */
  while (ofs < size)
 80485c7:	85 ed                	test   %ebp,%ebp
 80485c9:	0f 84 87 00 00 00    	je     8048656 <check_file_handle+0xd6>
 80485cf:	bb 00 00 00 00       	mov    $0x0,%ebx

      block_size = size - ofs;
      if (block_size > sizeof block)
        block_size = sizeof block;

      ret_val = read (fd, block, block_size);
 80485d4:	8d 7c 24 30          	lea    0x30(%esp),%edi
  while (ofs < size)
    {
      char block[512];
      size_t block_size, ret_val;

      block_size = size - ofs;
 80485d8:	89 ee                	mov    %ebp,%esi
 80485da:	29 de                	sub    %ebx,%esi
 80485dc:	81 fe 00 02 00 00    	cmp    $0x200,%esi
 80485e2:	b8 00 02 00 00       	mov    $0x200,%eax
 80485e7:	0f 47 f0             	cmova  %eax,%esi
      if (block_size > sizeof block)
        block_size = sizeof block;

      ret_val = read (fd, block, block_size);
 80485ea:	89 74 24 08          	mov    %esi,0x8(%esp)
 80485ee:	89 7c 24 04          	mov    %edi,0x4(%esp)
 80485f2:	8b 84 24 50 02 00 00 	mov    0x250(%esp),%eax
 80485f9:	89 04 24             	mov    %eax,(%esp)
 80485fc:	e8 cd 1d 00 00       	call   804a3ce <read>
      if (ret_val != block_size)
 8048601:	39 c6                	cmp    %eax,%esi
 8048603:	74 23                	je     8048628 <check_file_handle+0xa8>
        fail ("read of %zu bytes at offset %zu in \"%s\" returned %zu",
 8048605:	89 44 24 10          	mov    %eax,0x10(%esp)
 8048609:	8b 84 24 54 02 00 00 	mov    0x254(%esp),%eax
 8048610:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048614:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 8048618:	89 74 24 04          	mov    %esi,0x4(%esp)
 804861c:	c7 04 24 5c ac 04 08 	movl   $0x804ac5c,(%esp)
 8048623:	e8 ef fb ff ff       	call   8048217 <fail>
              block_size, ofs, file_name, ret_val);

      compare_bytes (block, buf + ofs, block_size, ofs, file_name);
 8048628:	8b 84 24 54 02 00 00 	mov    0x254(%esp),%eax
 804862f:	89 44 24 10          	mov    %eax,0x10(%esp)
 8048633:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 8048637:	89 74 24 08          	mov    %esi,0x8(%esp)
 804863b:	8b 84 24 58 02 00 00 	mov    0x258(%esp),%eax
 8048642:	01 d8                	add    %ebx,%eax
 8048644:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048648:	89 3c 24             	mov    %edi,(%esp)
 804864b:	e8 89 fd ff ff       	call   80483d9 <compare_bytes>
      ofs += block_size;
 8048650:	01 f3                	add    %esi,%ebx
  if (file_size != size)
    msg ("size of %s (%zu) differs from expected (%zu)",
          file_name, file_size, size);

  /* Read the file block-by-block, comparing data as we go. */
  while (ofs < size)
 8048652:	39 dd                	cmp    %ebx,%ebp
 8048654:	77 82                	ja     80485d8 <check_file_handle+0x58>
      compare_bytes (block, buf + ofs, block_size, ofs, file_name);
      ofs += block_size;
    }

  /* Now fail due to wrong file size. */
  if (file_size != size)
 8048656:	39 6c 24 2c          	cmp    %ebp,0x2c(%esp)
 804865a:	74 23                	je     804867f <check_file_handle+0xff>
    fail ("size of %s (%zu) differs from expected (%zu)",
 804865c:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
 8048660:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 8048664:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048668:	8b 84 24 54 02 00 00 	mov    0x254(%esp),%eax
 804866f:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048673:	c7 04 24 2c ac 04 08 	movl   $0x804ac2c,(%esp)
 804867a:	e8 98 fb ff ff       	call   8048217 <fail>
          file_name, file_size, size);

  msg ("verified contents of \"%s\"", file_name);
 804867f:	8b 84 24 54 02 00 00 	mov    0x254(%esp),%eax
 8048686:	89 44 24 04          	mov    %eax,0x4(%esp)
 804868a:	c7 04 24 27 a9 04 08 	movl   $0x804a927,(%esp)
 8048691:	e8 5f fb ff ff       	call   80481f5 <msg>
}
 8048696:	81 c4 3c 02 00 00    	add    $0x23c,%esp
 804869c:	5b                   	pop    %ebx
 804869d:	5e                   	pop    %esi
 804869e:	5f                   	pop    %edi
 804869f:	5d                   	pop    %ebp
 80486a0:	c3                   	ret    

080486a1 <check_file>:

void
check_file (const char *file_name, const void *buf, size_t size) 
{
 80486a1:	56                   	push   %esi
 80486a2:	53                   	push   %ebx
 80486a3:	83 ec 14             	sub    $0x14,%esp
 80486a6:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  int fd;

  CHECK ((fd = open (file_name)) > 1, "open \"%s\" for verification",
 80486aa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 80486ae:	c7 04 24 41 a9 04 08 	movl   $0x804a941,(%esp)
 80486b5:	e8 3b fb ff ff       	call   80481f5 <msg>
 80486ba:	89 1c 24             	mov    %ebx,(%esp)
 80486bd:	e8 f4 1c 00 00       	call   804a3b6 <open>
 80486c2:	89 c6                	mov    %eax,%esi
 80486c4:	83 f8 01             	cmp    $0x1,%eax
 80486c7:	7f 10                	jg     80486d9 <check_file+0x38>
 80486c9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 80486cd:	c7 04 24 41 a9 04 08 	movl   $0x804a941,(%esp)
 80486d4:	e8 3e fb ff ff       	call   8048217 <fail>
         file_name);
  check_file_handle (fd, file_name, buf, size);
 80486d9:	8b 44 24 28          	mov    0x28(%esp),%eax
 80486dd:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80486e1:	8b 44 24 24          	mov    0x24(%esp),%eax
 80486e5:	89 44 24 08          	mov    %eax,0x8(%esp)
 80486e9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 80486ed:	89 34 24             	mov    %esi,(%esp)
 80486f0:	e8 8b fe ff ff       	call   8048580 <check_file_handle>
  msg ("close \"%s\"", file_name);
 80486f5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 80486f9:	c7 04 24 5c a9 04 08 	movl   $0x804a95c,(%esp)
 8048700:	e8 f0 fa ff ff       	call   80481f5 <msg>
  close (fd);
 8048705:	89 34 24             	mov    %esi,(%esp)
 8048708:	e8 05 1d 00 00       	call   804a412 <close>
}
 804870d:	83 c4 14             	add    $0x14,%esp
 8048710:	5b                   	pop    %ebx
 8048711:	5e                   	pop    %esi
 8048712:	c3                   	ret    
 8048713:	90                   	nop

08048714 <_start>:
int main (int, char *[]);
void _start (int argc, char *argv[]);

void
_start (int argc, char *argv[]) 
{
 8048714:	83 ec 1c             	sub    $0x1c,%esp
  exit (main (argc, argv));
 8048717:	8b 44 24 24          	mov    0x24(%esp),%eax
 804871b:	89 44 24 04          	mov    %eax,0x4(%esp)
 804871f:	8b 44 24 20          	mov    0x20(%esp),%eax
 8048723:	89 04 24             	mov    %eax,(%esp)
 8048726:	e8 99 f9 ff ff       	call   80480c4 <main>
 804872b:	89 04 24             	mov    %eax,(%esp)
 804872e:	e8 13 1c 00 00       	call   804a346 <exit>
 8048733:	90                   	nop

08048734 <random_init>:
}

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
 8048734:	56                   	push   %esi
 8048735:	53                   	push   %ebx
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
 8048736:	b8 00 00 00 00       	mov    $0x0,%eax
    s[i] = i;
 804873b:	88 80 c0 c2 04 08    	mov    %al,0x804c2c0(%eax)
{
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
 8048741:	83 c0 01             	add    $0x1,%eax
 8048744:	3d 00 01 00 00       	cmp    $0x100,%eax
 8048749:	75 f0                	jne    804873b <random_init+0x7>
 804874b:	be 00 00 00 00       	mov    $0x0,%esi
 8048750:	66 b8 00 00          	mov    $0x0,%ax
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
    {
      j += s[i] + seedp[i % sizeof seed];
 8048754:	89 c1                	mov    %eax,%ecx
 8048756:	83 e1 03             	and    $0x3,%ecx
 8048759:	0f b6 98 c0 c2 04 08 	movzbl 0x804c2c0(%eax),%ebx
 8048760:	0f b6 4c 0c 0c       	movzbl 0xc(%esp,%ecx,1),%ecx
 8048765:	01 d9                	add    %ebx,%ecx
 8048767:	01 ce                	add    %ecx,%esi
      swap_byte (s + i, s + j);
 8048769:	89 f2                	mov    %esi,%edx
 804876b:	0f b6 ca             	movzbl %dl,%ecx
/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
  uint8_t t = *a;
  *a = *b;
 804876e:	0f b6 91 c0 c2 04 08 	movzbl 0x804c2c0(%ecx),%edx
 8048775:	88 90 c0 c2 04 08    	mov    %dl,0x804c2c0(%eax)
  *b = t;
 804877b:	88 99 c0 c2 04 08    	mov    %bl,0x804c2c0(%ecx)
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
 8048781:	83 c0 01             	add    $0x1,%eax
 8048784:	3d 00 01 00 00       	cmp    $0x100,%eax
 8048789:	75 c9                	jne    8048754 <random_init+0x20>
    {
      j += s[i] + seedp[i % sizeof seed];
      swap_byte (s + i, s + j);
    }

  s_i = s_j = 0;
 804878b:	c6 05 c0 c3 04 08 00 	movb   $0x0,0x804c3c0
 8048792:	c6 05 c1 c3 04 08 00 	movb   $0x0,0x804c3c1
  inited = true;
 8048799:	c6 05 c2 c3 04 08 01 	movb   $0x1,0x804c3c2
}
 80487a0:	5b                   	pop    %ebx
 80487a1:	5e                   	pop    %esi
 80487a2:	c3                   	ret    

080487a3 <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
 80487a3:	55                   	push   %ebp
 80487a4:	57                   	push   %edi
 80487a5:	56                   	push   %esi
 80487a6:	53                   	push   %ebx
 80487a7:	83 ec 10             	sub    $0x10,%esp
 80487aa:	8b 5c 24 28          	mov    0x28(%esp),%ebx
  uint8_t *buf;

  if (!inited)
 80487ae:	80 3d c2 c3 04 08 00 	cmpb   $0x0,0x804c3c2
 80487b5:	75 0c                	jne    80487c3 <random_bytes+0x20>
    random_init (0);
 80487b7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80487be:	e8 71 ff ff ff       	call   8048734 <random_init>

  for (buf = buf_; size-- > 0; buf++)
 80487c3:	85 db                	test   %ebx,%ebx
 80487c5:	0f 84 8c 00 00 00    	je     8048857 <random_bytes+0xb4>
 80487cb:	8d 43 ff             	lea    -0x1(%ebx),%eax
 80487ce:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80487d2:	0f b6 0d c1 c3 04 08 	movzbl 0x804c3c1,%ecx
 80487d9:	88 4c 24 0b          	mov    %cl,0xb(%esp)
 80487dd:	0f b6 15 c0 c3 04 08 	movzbl 0x804c3c0,%edx
 80487e4:	89 ce                	mov    %ecx,%esi
 80487e6:	8b 4c 24 24          	mov    0x24(%esp),%ecx
 80487ea:	89 c8                	mov    %ecx,%eax
 80487ec:	89 f1                	mov    %esi,%ecx
 80487ee:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 80487f2:	89 c6                	mov    %eax,%esi
    {
      uint8_t s_k;
      
      s_i++;
 80487f4:	83 c1 01             	add    $0x1,%ecx
      s_j += s[s_i];
 80487f7:	0f b6 c1             	movzbl %cl,%eax
 80487fa:	02 90 c0 c2 04 08    	add    0x804c2c0(%eax),%dl
      swap_byte (s + s_i, s + s_j);
 8048800:	0f b6 ea             	movzbl %dl,%ebp

/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
  uint8_t t = *a;
 8048803:	0f b6 b8 c0 c2 04 08 	movzbl 0x804c2c0(%eax),%edi
  *a = *b;
 804880a:	0f b6 9d c0 c2 04 08 	movzbl 0x804c2c0(%ebp),%ebx
 8048811:	88 98 c0 c2 04 08    	mov    %bl,0x804c2c0(%eax)
  *b = t;
 8048817:	89 fb                	mov    %edi,%ebx
 8048819:	88 9d c0 c2 04 08    	mov    %bl,0x804c2c0(%ebp)
      
      s_i++;
      s_j += s[s_i];
      swap_byte (s + s_i, s + s_j);

      s_k = s[s_i] + s[s_j];
 804881f:	0f b6 80 c0 c2 04 08 	movzbl 0x804c2c0(%eax),%eax
 8048826:	01 f8                	add    %edi,%eax
      *buf = s[s_k];
 8048828:	0f b6 f8             	movzbl %al,%edi
 804882b:	0f b6 87 c0 c2 04 08 	movzbl 0x804c2c0(%edi),%eax
 8048832:	88 06                	mov    %al,(%esi)
  uint8_t *buf;

  if (!inited)
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
 8048834:	83 c6 01             	add    $0x1,%esi
 8048837:	83 6c 24 04 01       	subl   $0x1,0x4(%esp)
 804883c:	75 b6                	jne    80487f4 <random_bytes+0x51>
  inited = true;
}

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
 804883e:	0f b6 4c 24 0b       	movzbl 0xb(%esp),%ecx
 8048843:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
 8048848:	8d 44 19 01          	lea    0x1(%ecx,%ebx,1),%eax
 804884c:	a2 c1 c3 04 08       	mov    %al,0x804c3c1
 8048851:	88 15 c0 c3 04 08    	mov    %dl,0x804c3c0
      swap_byte (s + s_i, s + s_j);

      s_k = s[s_i] + s[s_j];
      *buf = s[s_k];
    }
}
 8048857:	83 c4 10             	add    $0x10,%esp
 804885a:	5b                   	pop    %ebx
 804885b:	5e                   	pop    %esi
 804885c:	5f                   	pop    %edi
 804885d:	5d                   	pop    %ebp
 804885e:	c3                   	ret    

0804885f <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
 804885f:	83 ec 18             	sub    $0x18,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
 8048862:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
 8048869:	00 
 804886a:	8d 44 24 14          	lea    0x14(%esp),%eax
 804886e:	89 04 24             	mov    %eax,(%esp)
 8048871:	e8 2d ff ff ff       	call   80487a3 <random_bytes>
  return ul;
}
 8048876:	8b 44 24 14          	mov    0x14(%esp),%eax
 804887a:	83 c4 18             	add    $0x18,%esp
 804887d:	c3                   	ret    
 804887e:	90                   	nop
 804887f:	90                   	nop

08048880 <vsnprintf_helper>:
}

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
 8048880:	83 ec 08             	sub    $0x8,%esp
 8048883:	89 1c 24             	mov    %ebx,(%esp)
 8048886:	89 74 24 04          	mov    %esi,0x4(%esp)
 804888a:	8b 44 24 10          	mov    0x10(%esp),%eax
 804888e:	0f b6 74 24 0c       	movzbl 0xc(%esp),%esi
  struct vsnprintf_aux *aux = aux_;

  if (aux->length++ < aux->max_length)
 8048893:	8b 50 04             	mov    0x4(%eax),%edx
 8048896:	8b 48 08             	mov    0x8(%eax),%ecx
 8048899:	8d 5a 01             	lea    0x1(%edx),%ebx
 804889c:	89 58 04             	mov    %ebx,0x4(%eax)
 804889f:	39 ca                	cmp    %ecx,%edx
 80488a1:	7d 0b                	jge    80488ae <vsnprintf_helper+0x2e>
    *aux->p++ = ch;
 80488a3:	8b 10                	mov    (%eax),%edx
 80488a5:	89 f1                	mov    %esi,%ecx
 80488a7:	88 0a                	mov    %cl,(%edx)
 80488a9:	83 c2 01             	add    $0x1,%edx
 80488ac:	89 10                	mov    %edx,(%eax)
}
 80488ae:	8b 1c 24             	mov    (%esp),%ebx
 80488b1:	8b 74 24 04          	mov    0x4(%esp),%esi
 80488b5:	83 c4 08             	add    $0x8,%esp
 80488b8:	c3                   	ret    

080488b9 <output_dup>:
}

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
 80488b9:	83 ec 2c             	sub    $0x2c,%esp
 80488bc:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
 80488c0:	89 74 24 20          	mov    %esi,0x20(%esp)
 80488c4:	89 7c 24 24          	mov    %edi,0x24(%esp)
 80488c8:	89 6c 24 28          	mov    %ebp,0x28(%esp)
 80488cc:	89 d3                	mov    %edx,%ebx
 80488ce:	89 cd                	mov    %ecx,%ebp
 80488d0:	8b 7c 24 30          	mov    0x30(%esp),%edi
  while (cnt-- > 0)
 80488d4:	85 d2                	test   %edx,%edx
 80488d6:	74 11                	je     80488e9 <output_dup+0x30>
    output (ch, aux);
 80488d8:	0f be f0             	movsbl %al,%esi
 80488db:	89 7c 24 04          	mov    %edi,0x4(%esp)
 80488df:	89 34 24             	mov    %esi,(%esp)
 80488e2:	ff d5                	call   *%ebp

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
  while (cnt-- > 0)
 80488e4:	83 eb 01             	sub    $0x1,%ebx
 80488e7:	75 f2                	jne    80488db <output_dup+0x22>
    output (ch, aux);
}
 80488e9:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
 80488ed:	8b 74 24 20          	mov    0x20(%esp),%esi
 80488f1:	8b 7c 24 24          	mov    0x24(%esp),%edi
 80488f5:	8b 6c 24 28          	mov    0x28(%esp),%ebp
 80488f9:	83 c4 2c             	add    $0x2c,%esp
 80488fc:	c3                   	ret    

080488fd <format_integer>:
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
                const struct integer_base *b,
                const struct printf_conversion *c,
                void (*output) (char, void *), void *aux)
{
 80488fd:	55                   	push   %ebp
 80488fe:	57                   	push   %edi
 80488ff:	56                   	push   %esi
 8048900:	53                   	push   %ebx
 8048901:	83 ec 7c             	sub    $0x7c,%esp
 8048904:	89 c7                	mov    %eax,%edi
 8048906:	89 d6                	mov    %edx,%esi
 8048908:	0f b6 94 24 90 00 00 	movzbl 0x90(%esp),%edx
 804890f:	00 
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
 8048910:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
 8048917:	00 
  if (is_signed) 
 8048918:	85 c9                	test   %ecx,%ecx
 804891a:	74 41                	je     804895d <format_integer+0x60>
    {
      if (c->flags & PLUS)
 804891c:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
 8048923:	8b 01                	mov    (%ecx),%eax
 8048925:	a8 02                	test   $0x2,%al
 8048927:	74 11                	je     804893a <format_integer+0x3d>
        sign = negative ? '-' : '+';
 8048929:	80 fa 01             	cmp    $0x1,%dl
 804892c:	19 c0                	sbb    %eax,%eax
 804892e:	83 e0 fe             	and    $0xfffffffe,%eax
 8048931:	83 c0 2d             	add    $0x2d,%eax
 8048934:	89 44 24 28          	mov    %eax,0x28(%esp)
 8048938:	eb 23                	jmp    804895d <format_integer+0x60>
      else if (c->flags & SPACE)
 804893a:	a8 04                	test   $0x4,%al
 804893c:	74 11                	je     804894f <format_integer+0x52>
        sign = negative ? '-' : ' ';
 804893e:	80 fa 01             	cmp    $0x1,%dl
 8048941:	19 d2                	sbb    %edx,%edx
 8048943:	83 e2 f3             	and    $0xfffffff3,%edx
 8048946:	83 c2 2d             	add    $0x2d,%edx
 8048949:	89 54 24 28          	mov    %edx,0x28(%esp)
 804894d:	eb 0e                	jmp    804895d <format_integer+0x60>
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
 804894f:	80 fa 01             	cmp    $0x1,%dl
 8048952:	19 c9                	sbb    %ecx,%ecx
 8048954:	f7 d1                	not    %ecx
 8048956:	83 e1 2d             	and    $0x2d,%ecx
 8048959:	89 4c 24 28          	mov    %ecx,0x28(%esp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
 804895d:	89 f8                	mov    %edi,%eax
 804895f:	09 f0                	or     %esi,%eax
 8048961:	0f 95 c0             	setne  %al
 8048964:	8b 94 24 98 00 00 00 	mov    0x98(%esp),%edx
 804896b:	f6 02 08             	testb  $0x8,(%edx)
 804896e:	74 14                	je     8048984 <format_integer+0x87>
 8048970:	84 c0                	test   %al,%al
 8048972:	74 10                	je     8048984 <format_integer+0x87>
 8048974:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
 804897b:	8b 49 08             	mov    0x8(%ecx),%ecx
 804897e:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
 8048982:	eb 08                	jmp    804898c <format_integer+0x8f>
 8048984:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
 804898b:	00 

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
 804898c:	8d 5c 24 30          	lea    0x30(%esp),%ebx
  digit_cnt = 0;
  while (value > 0) 
 8048990:	84 c0                	test   %al,%al
 8048992:	0f 84 ba 00 00 00    	je     8048a52 <format_integer+0x155>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
        *cp++ = ',';
      *cp++ = b->digits[value % b->base];
 8048998:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
 804899f:	8b 40 04             	mov    0x4(%eax),%eax
 80489a2:	89 44 24 24          	mov    %eax,0x24(%esp)
 80489a6:	8b 94 24 94 00 00 00 	mov    0x94(%esp),%edx
 80489ad:	8b 02                	mov    (%edx),%eax
 80489af:	89 44 24 18          	mov    %eax,0x18(%esp)
 80489b3:	89 c1                	mov    %eax,%ecx
 80489b5:	c1 f9 1f             	sar    $0x1f,%ecx
 80489b8:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
 80489bc:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
 80489c3:	00 
  x = (c->flags & POUND) && value ? b->x : 0;

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
 80489c4:	89 dd                	mov    %ebx,%ebp
 80489c6:	eb 38                	jmp    8048a00 <format_integer+0x103>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
        *cp++ = ',';
      *cp++ = b->digits[value % b->base];
      value /= b->base;
      digit_cnt++;
 80489c8:	83 44 24 20 01       	addl   $0x1,0x20(%esp)
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
 80489cd:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
 80489d4:	f6 00 20             	testb  $0x20,(%eax)
 80489d7:	74 25                	je     80489fe <format_integer+0x101>
 80489d9:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
 80489de:	7e 1e                	jle    80489fe <format_integer+0x101>
 80489e0:	8b 44 24 20          	mov    0x20(%esp),%eax
 80489e4:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
 80489eb:	89 c2                	mov    %eax,%edx
 80489ed:	c1 fa 1f             	sar    $0x1f,%edx
 80489f0:	f7 79 0c             	idivl  0xc(%ecx)
 80489f3:	85 d2                	test   %edx,%edx
 80489f5:	75 07                	jne    80489fe <format_integer+0x101>
        *cp++ = ',';
 80489f7:	c6 45 01 2c          	movb   $0x2c,0x1(%ebp)
 80489fb:	8d 5d 02             	lea    0x2(%ebp),%ebx
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
 80489fe:	89 dd                	mov    %ebx,%ebp
  digit_cnt = 0;
  while (value > 0) 
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
        *cp++ = ',';
      *cp++ = b->digits[value % b->base];
 8048a00:	8b 44 24 18          	mov    0x18(%esp),%eax
 8048a04:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 8048a08:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048a0c:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8048a10:	89 3c 24             	mov    %edi,(%esp)
 8048a13:	89 74 24 04          	mov    %esi,0x4(%esp)
 8048a17:	e8 61 18 00 00       	call   804a27d <__umoddi3>
 8048a1c:	8b 54 24 24          	mov    0x24(%esp),%edx
 8048a20:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
 8048a24:	88 45 00             	mov    %al,0x0(%ebp)
 8048a27:	8d 5d 01             	lea    0x1(%ebp),%ebx
      value /= b->base;
 8048a2a:	8b 44 24 18          	mov    0x18(%esp),%eax
 8048a2e:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 8048a32:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048a36:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8048a3a:	89 3c 24             	mov    %edi,(%esp)
 8048a3d:	89 74 24 04          	mov    %esi,0x4(%esp)
 8048a41:	e8 14 18 00 00       	call   804a25a <__udivdi3>
 8048a46:	89 c7                	mov    %eax,%edi
 8048a48:	89 d6                	mov    %edx,%esi
  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
 8048a4a:	09 fa                	or     %edi,%edx
 8048a4c:	0f 85 76 ff ff ff    	jne    80489c8 <format_integer+0xcb>
  /* Append enough zeros to match precision.
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
 8048a52:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
 8048a59:	8b 51 08             	mov    0x8(%ecx),%edx
 8048a5c:	85 d2                	test   %edx,%edx
 8048a5e:	b8 01 00 00 00       	mov    $0x1,%eax
 8048a63:	0f 48 d0             	cmovs  %eax,%edx
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
 8048a66:	8d 7c 24 30          	lea    0x30(%esp),%edi
 8048a6a:	89 d8                	mov    %ebx,%eax
 8048a6c:	29 f8                	sub    %edi,%eax
 8048a6e:	39 c2                	cmp    %eax,%edx
 8048a70:	7e 1e                	jle    8048a90 <format_integer+0x193>
 8048a72:	8d 44 24 6f          	lea    0x6f(%esp),%eax
 8048a76:	39 c3                	cmp    %eax,%ebx
 8048a78:	73 16                	jae    8048a90 <format_integer+0x193>
   NEGATIVE indicating a negative value; otherwise does an
   unsigned conversion and ignores NEGATIVE.  The output is done
   according to the provided base B.  Details of the conversion
   are in C. */
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
 8048a7a:	89 f9                	mov    %edi,%ecx
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
 8048a7c:	89 c6                	mov    %eax,%esi
    *cp++ = '0';
 8048a7e:	c6 03 30             	movb   $0x30,(%ebx)
 8048a81:	83 c3 01             	add    $0x1,%ebx
   NEGATIVE indicating a negative value; otherwise does an
   unsigned conversion and ignores NEGATIVE.  The output is done
   according to the provided base B.  Details of the conversion
   are in C. */
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
 8048a84:	89 d8                	mov    %ebx,%eax
 8048a86:	29 c8                	sub    %ecx,%eax
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
 8048a88:	39 d0                	cmp    %edx,%eax
 8048a8a:	7d 04                	jge    8048a90 <format_integer+0x193>
 8048a8c:	39 f3                	cmp    %esi,%ebx
 8048a8e:	72 ee                	jb     8048a7e <format_integer+0x181>
    *cp++ = '0';
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
 8048a90:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
 8048a97:	f6 00 08             	testb  $0x8,(%eax)
 8048a9a:	74 20                	je     8048abc <format_integer+0x1bf>
 8048a9c:	8b 94 24 94 00 00 00 	mov    0x94(%esp),%edx
 8048aa3:	83 3a 08             	cmpl   $0x8,(%edx)
 8048aa6:	75 14                	jne    8048abc <format_integer+0x1bf>
 8048aa8:	8d 44 24 30          	lea    0x30(%esp),%eax
 8048aac:	39 c3                	cmp    %eax,%ebx
 8048aae:	74 06                	je     8048ab6 <format_integer+0x1b9>
 8048ab0:	80 7b ff 30          	cmpb   $0x30,-0x1(%ebx)
 8048ab4:	74 06                	je     8048abc <format_integer+0x1bf>
    *cp++ = '0';
 8048ab6:	c6 03 30             	movb   $0x30,(%ebx)
 8048ab9:	83 c3 01             	add    $0x1,%ebx

  /* Calculate number of pad characters to fill field width. */
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
 8048abc:	29 df                	sub    %ebx,%edi
 8048abe:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
 8048ac5:	03 79 04             	add    0x4(%ecx),%edi
 8048ac8:	83 7c 24 2c 01       	cmpl   $0x1,0x2c(%esp)
 8048acd:	19 c0                	sbb    %eax,%eax
 8048acf:	f7 d0                	not    %eax
 8048ad1:	83 e0 02             	and    $0x2,%eax
 8048ad4:	29 c7                	sub    %eax,%edi
 8048ad6:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
 8048adb:	0f 95 c0             	setne  %al
 8048ade:	0f b6 c0             	movzbl %al,%eax
 8048ae1:	29 c7                	sub    %eax,%edi
 8048ae3:	b8 00 00 00 00       	mov    $0x0,%eax
 8048ae8:	0f 48 f8             	cmovs  %eax,%edi
  if (pad_cnt < 0)
    pad_cnt = 0;

  /* Do output. */
  if ((c->flags & (MINUS | ZERO)) == 0)
 8048aeb:	f6 01 11             	testb  $0x11,(%ecx)
 8048aee:	75 1d                	jne    8048b0d <format_integer+0x210>
    output_dup (' ', pad_cnt, output, aux);
 8048af0:	8b 84 24 a0 00 00 00 	mov    0xa0(%esp),%eax
 8048af7:	89 04 24             	mov    %eax,(%esp)
 8048afa:	8b 8c 24 9c 00 00 00 	mov    0x9c(%esp),%ecx
 8048b01:	89 fa                	mov    %edi,%edx
 8048b03:	b8 20 00 00 00       	mov    $0x20,%eax
 8048b08:	e8 ac fd ff ff       	call   80488b9 <output_dup>
  if (sign)
 8048b0d:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
 8048b12:	74 19                	je     8048b2d <format_integer+0x230>
    output (sign, aux);
 8048b14:	8b 94 24 a0 00 00 00 	mov    0xa0(%esp),%edx
 8048b1b:	89 54 24 04          	mov    %edx,0x4(%esp)
 8048b1f:	8b 4c 24 28          	mov    0x28(%esp),%ecx
 8048b23:	89 0c 24             	mov    %ecx,(%esp)
 8048b26:	ff 94 24 9c 00 00 00 	call   *0x9c(%esp)
  if (x) 
 8048b2d:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
 8048b32:	74 33                	je     8048b67 <format_integer+0x26a>
    {
      output ('0', aux);
 8048b34:	8b 84 24 a0 00 00 00 	mov    0xa0(%esp),%eax
 8048b3b:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048b3f:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
 8048b46:	ff 94 24 9c 00 00 00 	call   *0x9c(%esp)
      output (x, aux); 
 8048b4d:	8b 94 24 a0 00 00 00 	mov    0xa0(%esp),%edx
 8048b54:	89 54 24 04          	mov    %edx,0x4(%esp)
 8048b58:	0f be 44 24 2c       	movsbl 0x2c(%esp),%eax
 8048b5d:	89 04 24             	mov    %eax,(%esp)
 8048b60:	ff 94 24 9c 00 00 00 	call   *0x9c(%esp)
    }
  if (c->flags & ZERO)
 8048b67:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
 8048b6e:	f6 01 10             	testb  $0x10,(%ecx)
 8048b71:	74 1d                	je     8048b90 <format_integer+0x293>
    output_dup ('0', pad_cnt, output, aux);
 8048b73:	8b 84 24 a0 00 00 00 	mov    0xa0(%esp),%eax
 8048b7a:	89 04 24             	mov    %eax,(%esp)
 8048b7d:	8b 8c 24 9c 00 00 00 	mov    0x9c(%esp),%ecx
 8048b84:	89 fa                	mov    %edi,%edx
 8048b86:	b8 30 00 00 00       	mov    $0x30,%eax
 8048b8b:	e8 29 fd ff ff       	call   80488b9 <output_dup>
  while (cp > buf)
 8048b90:	8d 44 24 30          	lea    0x30(%esp),%eax
 8048b94:	39 c3                	cmp    %eax,%ebx
 8048b96:	76 2b                	jbe    8048bc3 <format_integer+0x2c6>
 8048b98:	89 c6                	mov    %eax,%esi
 8048b9a:	89 7c 24 20          	mov    %edi,0x20(%esp)
 8048b9e:	8b ac 24 9c 00 00 00 	mov    0x9c(%esp),%ebp
 8048ba5:	8b bc 24 a0 00 00 00 	mov    0xa0(%esp),%edi
    output (*--cp, aux);
 8048bac:	83 eb 01             	sub    $0x1,%ebx
 8048baf:	89 7c 24 04          	mov    %edi,0x4(%esp)
 8048bb3:	0f be 03             	movsbl (%ebx),%eax
 8048bb6:	89 04 24             	mov    %eax,(%esp)
 8048bb9:	ff d5                	call   *%ebp
      output ('0', aux);
      output (x, aux); 
    }
  if (c->flags & ZERO)
    output_dup ('0', pad_cnt, output, aux);
  while (cp > buf)
 8048bbb:	39 f3                	cmp    %esi,%ebx
 8048bbd:	75 ed                	jne    8048bac <format_integer+0x2af>
 8048bbf:	8b 7c 24 20          	mov    0x20(%esp),%edi
    output (*--cp, aux);
  if (c->flags & MINUS)
 8048bc3:	8b 94 24 98 00 00 00 	mov    0x98(%esp),%edx
 8048bca:	f6 02 01             	testb  $0x1,(%edx)
 8048bcd:	74 1d                	je     8048bec <format_integer+0x2ef>
    output_dup (' ', pad_cnt, output, aux);
 8048bcf:	8b 8c 24 a0 00 00 00 	mov    0xa0(%esp),%ecx
 8048bd6:	89 0c 24             	mov    %ecx,(%esp)
 8048bd9:	8b 8c 24 9c 00 00 00 	mov    0x9c(%esp),%ecx
 8048be0:	89 fa                	mov    %edi,%edx
 8048be2:	b8 20 00 00 00       	mov    $0x20,%eax
 8048be7:	e8 cd fc ff ff       	call   80488b9 <output_dup>
}
 8048bec:	83 c4 7c             	add    $0x7c,%esp
 8048bef:	5b                   	pop    %ebx
 8048bf0:	5e                   	pop    %esi
 8048bf1:	5f                   	pop    %edi
 8048bf2:	5d                   	pop    %ebp
 8048bf3:	c3                   	ret    

08048bf4 <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
 8048bf4:	55                   	push   %ebp
 8048bf5:	57                   	push   %edi
 8048bf6:	56                   	push   %esi
 8048bf7:	53                   	push   %ebx
 8048bf8:	83 ec 2c             	sub    $0x2c,%esp
 8048bfb:	89 c7                	mov    %eax,%edi
 8048bfd:	89 d6                	mov    %edx,%esi
 8048bff:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 8048c03:	8b 6c 24 44          	mov    0x44(%esp),%ebp
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
 8048c07:	8b 51 04             	mov    0x4(%ecx),%edx
 8048c0a:	39 f2                	cmp    %esi,%edx
 8048c0c:	7e 18                	jle    8048c26 <format_string+0x32>
 8048c0e:	f6 01 01             	testb  $0x1,(%ecx)
 8048c11:	75 13                	jne    8048c26 <format_string+0x32>
    output_dup (' ', c->width - length, output, aux);
 8048c13:	29 f2                	sub    %esi,%edx
 8048c15:	89 2c 24             	mov    %ebp,(%esp)
 8048c18:	8b 4c 24 40          	mov    0x40(%esp),%ecx
 8048c1c:	b8 20 00 00 00       	mov    $0x20,%eax
 8048c21:	e8 93 fc ff ff       	call   80488b9 <output_dup>
  for (i = 0; i < length; i++)
 8048c26:	85 f6                	test   %esi,%esi
 8048c28:	7e 1b                	jle    8048c45 <format_string+0x51>
 8048c2a:	bb 00 00 00 00       	mov    $0x0,%ebx
    output (string[i], aux);
 8048c2f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
 8048c33:	0f be 04 1f          	movsbl (%edi,%ebx,1),%eax
 8048c37:	89 04 24             	mov    %eax,(%esp)
 8048c3a:	ff 54 24 40          	call   *0x40(%esp)
               void (*output) (char, void *), void *aux) 
{
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
 8048c3e:	83 c3 01             	add    $0x1,%ebx
 8048c41:	39 f3                	cmp    %esi,%ebx
 8048c43:	75 ea                	jne    8048c2f <format_string+0x3b>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
 8048c45:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8048c49:	8b 50 04             	mov    0x4(%eax),%edx
 8048c4c:	39 d6                	cmp    %edx,%esi
 8048c4e:	7d 18                	jge    8048c68 <format_string+0x74>
 8048c50:	f6 00 01             	testb  $0x1,(%eax)
 8048c53:	74 13                	je     8048c68 <format_string+0x74>
    output_dup (' ', c->width - length, output, aux);
 8048c55:	29 f2                	sub    %esi,%edx
 8048c57:	89 2c 24             	mov    %ebp,(%esp)
 8048c5a:	8b 4c 24 40          	mov    0x40(%esp),%ecx
 8048c5e:	b8 20 00 00 00       	mov    $0x20,%eax
 8048c63:	e8 51 fc ff ff       	call   80488b9 <output_dup>
}
 8048c68:	83 c4 2c             	add    $0x2c,%esp
 8048c6b:	5b                   	pop    %ebx
 8048c6c:	5e                   	pop    %esi
 8048c6d:	5f                   	pop    %edi
 8048c6e:	5d                   	pop    %ebp
 8048c6f:	c3                   	ret    

08048c70 <printf>:
   In the kernel, the console is both the video display and first
   serial port.
   In userspace, the console is file descriptor 1. */
int
printf (const char *format, ...) 
{
 8048c70:	83 ec 1c             	sub    $0x1c,%esp
  va_list args;
  int retval;

  va_start (args, format);
 8048c73:	8d 44 24 24          	lea    0x24(%esp),%eax
  retval = vprintf (format, args);
 8048c77:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048c7b:	8b 44 24 20          	mov    0x20(%esp),%eax
 8048c7f:	89 04 24             	mov    %eax,(%esp)
 8048c82:	e8 44 19 00 00       	call   804a5cb <vprintf>
  va_end (args);

  return retval;
}
 8048c87:	83 c4 1c             	add    $0x1c,%esp
 8048c8a:	c3                   	ret    

08048c8b <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
 8048c8b:	83 ec 1c             	sub    $0x1c,%esp
  va_list args;

  va_start (args, aux);
 8048c8e:	8d 44 24 2c          	lea    0x2c(%esp),%eax
  __vprintf (format, args, output, aux);
 8048c92:	8b 54 24 28          	mov    0x28(%esp),%edx
 8048c96:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8048c9a:	8b 54 24 24          	mov    0x24(%esp),%edx
 8048c9e:	89 54 24 08          	mov    %edx,0x8(%esp)
 8048ca2:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048ca6:	8b 44 24 20          	mov    0x20(%esp),%eax
 8048caa:	89 04 24             	mov    %eax,(%esp)
 8048cad:	e8 04 00 00 00       	call   8048cb6 <__vprintf>
  va_end (args);
}
 8048cb2:	83 c4 1c             	add    $0x1c,%esp
 8048cb5:	c3                   	ret    

08048cb6 <__vprintf>:
                           void (*output) (char, void *), void *aux);

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
 8048cb6:	55                   	push   %ebp
 8048cb7:	57                   	push   %edi
 8048cb8:	56                   	push   %esi
 8048cb9:	53                   	push   %ebx
 8048cba:	83 ec 6c             	sub    $0x6c,%esp
 8048cbd:	8b ac 24 80 00 00 00 	mov    0x80(%esp),%ebp
  for (; *format != '\0'; format++)
 8048cc4:	0f b6 45 00          	movzbl 0x0(%ebp),%eax
 8048cc8:	84 c0                	test   %al,%al
 8048cca:	0f 84 6d 07 00 00    	je     804943d <__vprintf+0x787>
    {
      struct printf_conversion c;

      /* Literally copy non-conversions to output. */
      if (*format != '%') 
 8048cd0:	3c 25                	cmp    $0x25,%al
 8048cd2:	74 21                	je     8048cf5 <__vprintf+0x3f>
        {
          output (*format, aux);
 8048cd4:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 8048cdb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8048cdf:	0f be c0             	movsbl %al,%eax
 8048ce2:	89 04 24             	mov    %eax,(%esp)
 8048ce5:	ff 94 24 88 00 00 00 	call   *0x88(%esp)
          continue;
 8048cec:	89 6c 24 2c          	mov    %ebp,0x2c(%esp)
 8048cf0:	e9 25 07 00 00       	jmp    804941a <__vprintf+0x764>
        }
      format++;
 8048cf5:	8d 5d 01             	lea    0x1(%ebp),%ebx
 8048cf8:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)

      /* %% => %. */
      if (*format == '%') 
 8048cfc:	b9 00 00 00 00       	mov    $0x0,%ecx
 8048d01:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8048d05:	80 7d 01 25          	cmpb   $0x25,0x1(%ebp)
 8048d09:	75 20                	jne    8048d2b <__vprintf+0x75>
        {
          output ('%', aux);
 8048d0b:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 8048d12:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8048d16:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
 8048d1d:	ff 94 24 88 00 00 00 	call   *0x88(%esp)
          continue;
 8048d24:	e9 f1 06 00 00       	jmp    804941a <__vprintf+0x764>
{
  /* Parse flag characters. */
  c->flags = 0;
  for (;;) 
    {
      switch (*format++) 
 8048d29:	89 eb                	mov    %ebp,%ebx
 8048d2b:	0f b6 13             	movzbl (%ebx),%edx
 8048d2e:	8d 6b 01             	lea    0x1(%ebx),%ebp
 8048d31:	8d 42 e0             	lea    -0x20(%edx),%eax
 8048d34:	3c 10                	cmp    $0x10,%al
 8048d36:	77 2a                	ja     8048d62 <__vprintf+0xac>
 8048d38:	0f b6 c0             	movzbl %al,%eax
 8048d3b:	ff 24 85 6c a6 04 08 	jmp    *0x804a66c(,%eax,4)
        {
        case '-':
          c->flags |= MINUS;
 8048d42:	83 c9 01             	or     $0x1,%ecx
 8048d45:	eb e2                	jmp    8048d29 <__vprintf+0x73>
          break;
        case '+':
          c->flags |= PLUS;
 8048d47:	83 c9 02             	or     $0x2,%ecx
 8048d4a:	eb dd                	jmp    8048d29 <__vprintf+0x73>
          break;
        case ' ':
          c->flags |= SPACE;
 8048d4c:	83 c9 04             	or     $0x4,%ecx
 8048d4f:	90                   	nop
 8048d50:	eb d7                	jmp    8048d29 <__vprintf+0x73>
          break;
        case '#':
          c->flags |= POUND;
 8048d52:	83 c9 08             	or     $0x8,%ecx
 8048d55:	eb d2                	jmp    8048d29 <__vprintf+0x73>
          break;
        case '0':
          c->flags |= ZERO;
 8048d57:	83 c9 10             	or     $0x10,%ecx
 8048d5a:	eb cd                	jmp    8048d29 <__vprintf+0x73>
          break;
        case '\'':
          c->flags |= GROUP;
 8048d5c:	83 c9 20             	or     $0x20,%ecx
 8048d5f:	90                   	nop
 8048d60:	eb c7                	jmp    8048d29 <__vprintf+0x73>
 8048d62:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
 8048d66:	89 4c 24 4c          	mov    %ecx,0x4c(%esp)
          format--;
          goto not_a_flag;
        }
    }
 not_a_flag:
  if (c->flags & MINUS)
 8048d6a:	f6 c1 01             	test   $0x1,%cl
 8048d6d:	74 07                	je     8048d76 <__vprintf+0xc0>
    c->flags &= ~ZERO;
 8048d6f:	83 e1 ef             	and    $0xffffffef,%ecx
 8048d72:	89 4c 24 4c          	mov    %ecx,0x4c(%esp)
  if (c->flags & PLUS)
 8048d76:	8b 44 24 4c          	mov    0x4c(%esp),%eax
 8048d7a:	a8 02                	test   $0x2,%al
 8048d7c:	74 07                	je     8048d85 <__vprintf+0xcf>
    c->flags &= ~SPACE;
 8048d7e:	83 e0 fb             	and    $0xfffffffb,%eax
 8048d81:	89 44 24 4c          	mov    %eax,0x4c(%esp)

  /* Parse field width. */
  c->width = 0;
 8048d85:	c7 44 24 50 00 00 00 	movl   $0x0,0x50(%esp)
 8048d8c:	00 
  if (*format == '*')
 8048d8d:	80 fa 2a             	cmp    $0x2a,%dl
 8048d90:	74 16                	je     8048da8 <__vprintf+0xf2>
      format++;
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
 8048d92:	0f be 13             	movsbl (%ebx),%edx
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
static inline int isalpha (int c) { return islower (c) || isupper (c); }
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
 8048d95:	8d 4a d0             	lea    -0x30(%edx),%ecx
 8048d98:	b8 00 00 00 00       	mov    $0x0,%eax
 8048d9d:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8048da1:	83 f9 09             	cmp    $0x9,%ecx
 8048da4:	76 1f                	jbe    8048dc5 <__vprintf+0x10f>
 8048da6:	eb 4d                	jmp    8048df5 <__vprintf+0x13f>
  /* Parse field width. */
  c->width = 0;
  if (*format == '*')
    {
      format++;
      c->width = va_arg (*args, int);
 8048da8:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048daf:	8b 03                	mov    (%ebx),%eax
 8048db1:	89 44 24 50          	mov    %eax,0x50(%esp)
 8048db5:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8048db8:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
{
  /* Parse flag characters. */
  c->flags = 0;
  for (;;) 
    {
      switch (*format++) 
 8048dbf:	89 6c 24 2c          	mov    %ebp,0x2c(%esp)
 8048dc3:	eb 1d                	jmp    8048de2 <__vprintf+0x12c>
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
        c->width = c->width * 10 + *format - '0';
 8048dc5:	8d 04 80             	lea    (%eax,%eax,4),%eax
 8048dc8:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
      format++;
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
 8048dcc:	83 c3 01             	add    $0x1,%ebx
 8048dcf:	0f be 13             	movsbl (%ebx),%edx
 8048dd2:	8d 4a d0             	lea    -0x30(%edx),%ecx
 8048dd5:	83 f9 09             	cmp    $0x9,%ecx
 8048dd8:	76 eb                	jbe    8048dc5 <__vprintf+0x10f>
 8048dda:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
 8048dde:	89 44 24 50          	mov    %eax,0x50(%esp)
        c->width = c->width * 10 + *format - '0';
    }
  if (c->width < 0) 
 8048de2:	8b 44 24 50          	mov    0x50(%esp),%eax
 8048de6:	85 c0                	test   %eax,%eax
 8048de8:	79 0b                	jns    8048df5 <__vprintf+0x13f>
    {
      c->width = -c->width;
 8048dea:	f7 d8                	neg    %eax
 8048dec:	89 44 24 50          	mov    %eax,0x50(%esp)
      c->flags |= MINUS;
 8048df0:	83 4c 24 4c 01       	orl    $0x1,0x4c(%esp)
    }
      
  /* Parse precision. */
  c->precision = -1;
 8048df5:	c7 44 24 54 ff ff ff 	movl   $0xffffffff,0x54(%esp)
 8048dfc:	ff 
  if (*format == '.') 
 8048dfd:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8048e01:	80 3b 2e             	cmpb   $0x2e,(%ebx)
 8048e04:	75 7c                	jne    8048e82 <__vprintf+0x1cc>
    {
      format++;
      if (*format == '*') 
 8048e06:	80 7b 01 2a          	cmpb   $0x2a,0x1(%ebx)
 8048e0a:	75 1e                	jne    8048e2a <__vprintf+0x174>
        {
          format++;
 8048e0c:	89 da                	mov    %ebx,%edx
 8048e0e:	83 c2 02             	add    $0x2,%edx
          c->precision = va_arg (*args, int);
 8048e11:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048e18:	8b 03                	mov    (%ebx),%eax
 8048e1a:	89 44 24 54          	mov    %eax,0x54(%esp)
 8048e1e:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8048e21:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
 8048e28:	eb 41                	jmp    8048e6b <__vprintf+0x1b5>
      
  /* Parse precision. */
  c->precision = -1;
  if (*format == '.') 
    {
      format++;
 8048e2a:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 8048e2e:	83 c2 01             	add    $0x1,%edx
          format++;
          c->precision = va_arg (*args, int);
        }
      else 
        {
          c->precision = 0;
 8048e31:	c7 44 24 54 00 00 00 	movl   $0x0,0x54(%esp)
 8048e38:	00 
          for (; isdigit (*format); format++)
 8048e39:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8048e3d:	0f be 4b 01          	movsbl 0x1(%ebx),%ecx
 8048e41:	8d 41 d0             	lea    -0x30(%ecx),%eax
 8048e44:	83 f8 09             	cmp    $0x9,%eax
 8048e47:	0f 87 e6 05 00 00    	ja     8049433 <__vprintf+0x77d>
 8048e4d:	b8 00 00 00 00       	mov    $0x0,%eax
            c->precision = c->precision * 10 + *format - '0';
 8048e52:	8d 04 80             	lea    (%eax,%eax,4),%eax
 8048e55:	8d 44 41 d0          	lea    -0x30(%ecx,%eax,2),%eax
          c->precision = va_arg (*args, int);
        }
      else 
        {
          c->precision = 0;
          for (; isdigit (*format); format++)
 8048e59:	83 c2 01             	add    $0x1,%edx
 8048e5c:	0f be 0a             	movsbl (%edx),%ecx
 8048e5f:	8d 59 d0             	lea    -0x30(%ecx),%ebx
 8048e62:	83 fb 09             	cmp    $0x9,%ebx
 8048e65:	76 eb                	jbe    8048e52 <__vprintf+0x19c>
 8048e67:	89 44 24 54          	mov    %eax,0x54(%esp)
            c->precision = c->precision * 10 + *format - '0';
        }
      if (c->precision < 0) 
 8048e6b:	83 7c 24 54 00       	cmpl   $0x0,0x54(%esp)
 8048e70:	0f 89 bd 05 00 00    	jns    8049433 <__vprintf+0x77d>
        c->precision = -1;
 8048e76:	c7 44 24 54 ff ff ff 	movl   $0xffffffff,0x54(%esp)
 8048e7d:	ff 
 8048e7e:	89 54 24 2c          	mov    %edx,0x2c(%esp)
 8048e82:	8b 54 24 2c          	mov    0x2c(%esp),%edx
    }
  if (c->precision >= 0)
    c->flags &= ~ZERO;

  /* Parse type. */
  c->type = INT;
 8048e86:	c7 44 24 58 03 00 00 	movl   $0x3,0x58(%esp)
 8048e8d:	00 
  switch (*format++) 
 8048e8e:	8d 5a 01             	lea    0x1(%edx),%ebx
 8048e91:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
 8048e95:	0f b6 02             	movzbl (%edx),%eax
 8048e98:	83 e8 68             	sub    $0x68,%eax
 8048e9b:	3c 12                	cmp    $0x12,%al
 8048e9d:	77 6a                	ja     8048f09 <__vprintf+0x253>
 8048e9f:	0f b6 c0             	movzbl %al,%eax
 8048ea2:	ff 24 85 b0 a6 04 08 	jmp    *0x804a6b0(,%eax,4)
    {
    case 'h':
      if (*format == 'h') 
 8048ea9:	80 7a 01 68          	cmpb   $0x68,0x1(%edx)
 8048ead:	75 11                	jne    8048ec0 <__vprintf+0x20a>
        {
          format++;
 8048eaf:	83 c2 02             	add    $0x2,%edx
 8048eb2:	89 54 24 2c          	mov    %edx,0x2c(%esp)
          c->type = CHAR;
 8048eb6:	c7 44 24 58 01 00 00 	movl   $0x1,0x58(%esp)
 8048ebd:	00 
 8048ebe:	eb 4d                	jmp    8048f0d <__vprintf+0x257>
        }
      else
        c->type = SHORT;
 8048ec0:	c7 44 24 58 02 00 00 	movl   $0x2,0x58(%esp)
 8048ec7:	00 
 8048ec8:	eb 43                	jmp    8048f0d <__vprintf+0x257>
      break;
      
    case 'j':
      c->type = INTMAX;
 8048eca:	c7 44 24 58 04 00 00 	movl   $0x4,0x58(%esp)
 8048ed1:	00 
 8048ed2:	eb 39                	jmp    8048f0d <__vprintf+0x257>
      break;

    case 'l':
      if (*format == 'l')
 8048ed4:	80 7a 01 6c          	cmpb   $0x6c,0x1(%edx)
 8048ed8:	75 11                	jne    8048eeb <__vprintf+0x235>
        {
          format++;
 8048eda:	83 c2 02             	add    $0x2,%edx
 8048edd:	89 54 24 2c          	mov    %edx,0x2c(%esp)
          c->type = LONGLONG;
 8048ee1:	c7 44 24 58 06 00 00 	movl   $0x6,0x58(%esp)
 8048ee8:	00 
 8048ee9:	eb 22                	jmp    8048f0d <__vprintf+0x257>
        }
      else
        c->type = LONG;
 8048eeb:	c7 44 24 58 05 00 00 	movl   $0x5,0x58(%esp)
 8048ef2:	00 
 8048ef3:	eb 18                	jmp    8048f0d <__vprintf+0x257>
      break;

    case 't':
      c->type = PTRDIFFT;
 8048ef5:	c7 44 24 58 07 00 00 	movl   $0x7,0x58(%esp)
 8048efc:	00 
 8048efd:	eb 0e                	jmp    8048f0d <__vprintf+0x257>
      break;

    case 'z':
      c->type = SIZET;
 8048eff:	c7 44 24 58 08 00 00 	movl   $0x8,0x58(%esp)
 8048f06:	00 
 8048f07:	eb 04                	jmp    8048f0d <__vprintf+0x257>
  if (c->precision >= 0)
    c->flags &= ~ZERO;

  /* Parse type. */
  c->type = INT;
  switch (*format++) 
 8048f09:	89 54 24 2c          	mov    %edx,0x2c(%esp)

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8048f0d:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8048f11:	0f b6 13             	movzbl (%ebx),%edx
 8048f14:	8d 42 bb             	lea    -0x45(%edx),%eax
 8048f17:	3c 33                	cmp    $0x33,%al
 8048f19:	0f 87 d2 04 00 00    	ja     80493f1 <__vprintf+0x73b>
 8048f1f:	0f b6 c0             	movzbl %al,%eax
 8048f22:	ff 24 85 fc a6 04 08 	jmp    *0x804a6fc(,%eax,4)
        case 'i': 
          {
            /* Signed integer conversions. */
            intmax_t value;
            
            switch (c.type) 
 8048f29:	83 7c 24 58 08       	cmpl   $0x8,0x58(%esp)
 8048f2e:	0f 87 52 01 00 00    	ja     8049086 <__vprintf+0x3d0>
 8048f34:	8b 44 24 58          	mov    0x58(%esp),%eax
 8048f38:	ff 24 85 cc a7 04 08 	jmp    *0x804a7cc(,%eax,4)
              {
              case CHAR: 
                value = (signed char) va_arg (args, int);
 8048f3f:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048f46:	0f be 03             	movsbl (%ebx),%eax
 8048f49:	89 44 24 30          	mov    %eax,0x30(%esp)
 8048f4d:	89 c2                	mov    %eax,%edx
 8048f4f:	c1 fa 1f             	sar    $0x1f,%edx
 8048f52:	89 54 24 34          	mov    %edx,0x34(%esp)
 8048f56:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8048f59:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8048f60:	e9 45 01 00 00       	jmp    80490aa <__vprintf+0x3f4>
              case SHORT:
                value = (short) va_arg (args, int);
 8048f65:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048f6c:	0f bf 03             	movswl (%ebx),%eax
 8048f6f:	89 44 24 30          	mov    %eax,0x30(%esp)
 8048f73:	89 c2                	mov    %eax,%edx
 8048f75:	c1 fa 1f             	sar    $0x1f,%edx
 8048f78:	89 54 24 34          	mov    %edx,0x34(%esp)
 8048f7c:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8048f7f:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8048f86:	e9 1f 01 00 00       	jmp    80490aa <__vprintf+0x3f4>
              case INT:
                value = va_arg (args, int);
 8048f8b:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048f92:	8b 03                	mov    (%ebx),%eax
 8048f94:	89 44 24 30          	mov    %eax,0x30(%esp)
 8048f98:	89 c2                	mov    %eax,%edx
 8048f9a:	c1 fa 1f             	sar    $0x1f,%edx
 8048f9d:	89 54 24 34          	mov    %edx,0x34(%esp)
 8048fa1:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8048fa4:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8048fab:	e9 fa 00 00 00       	jmp    80490aa <__vprintf+0x3f4>
              case INTMAX:
                value = va_arg (args, intmax_t);
 8048fb0:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048fb7:	8b 0b                	mov    (%ebx),%ecx
 8048fb9:	8b 5b 04             	mov    0x4(%ebx),%ebx
 8048fbc:	89 4c 24 30          	mov    %ecx,0x30(%esp)
 8048fc0:	89 5c 24 34          	mov    %ebx,0x34(%esp)
 8048fc4:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048fcb:	8d 5b 08             	lea    0x8(%ebx),%ebx
 8048fce:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8048fd5:	e9 d0 00 00 00       	jmp    80490aa <__vprintf+0x3f4>
              case LONG:
                value = va_arg (args, long);
 8048fda:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048fe1:	8b 03                	mov    (%ebx),%eax
 8048fe3:	89 44 24 30          	mov    %eax,0x30(%esp)
 8048fe7:	89 c2                	mov    %eax,%edx
 8048fe9:	c1 fa 1f             	sar    $0x1f,%edx
 8048fec:	89 54 24 34          	mov    %edx,0x34(%esp)
 8048ff0:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8048ff3:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8048ffa:	e9 ab 00 00 00       	jmp    80490aa <__vprintf+0x3f4>
              case LONGLONG:
                value = va_arg (args, long long);
 8048fff:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8049006:	8b 0b                	mov    (%ebx),%ecx
 8049008:	8b 5b 04             	mov    0x4(%ebx),%ebx
 804900b:	89 4c 24 30          	mov    %ecx,0x30(%esp)
 804900f:	89 5c 24 34          	mov    %ebx,0x34(%esp)
 8049013:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 804901a:	8d 5b 08             	lea    0x8(%ebx),%ebx
 804901d:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8049024:	e9 81 00 00 00       	jmp    80490aa <__vprintf+0x3f4>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
 8049029:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8049030:	8b 03                	mov    (%ebx),%eax
 8049032:	89 44 24 30          	mov    %eax,0x30(%esp)
 8049036:	89 c2                	mov    %eax,%edx
 8049038:	c1 fa 1f             	sar    $0x1f,%edx
 804903b:	89 54 24 34          	mov    %edx,0x34(%esp)
 804903f:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8049042:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8049049:	eb 5f                	jmp    80490aa <__vprintf+0x3f4>
              case SIZET:
                value = va_arg (args, size_t);
 804904b:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
 8049052:	83 c0 04             	add    $0x4,%eax
 8049055:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 804905c:	8b 0b                	mov    (%ebx),%ecx
 804905e:	bb 00 00 00 00       	mov    $0x0,%ebx
 8049063:	89 4c 24 30          	mov    %ecx,0x30(%esp)
 8049067:	89 5c 24 34          	mov    %ebx,0x34(%esp)
 804906b:	89 84 24 84 00 00 00 	mov    %eax,0x84(%esp)
                if (value > SIZE_MAX / 2)
 8049072:	81 f9 ff ff ff 7f    	cmp    $0x7fffffff,%ecx
 8049078:	76 30                	jbe    80490aa <__vprintf+0x3f4>
                  value = value - SIZE_MAX - 1;
 804907a:	83 44 24 30 00       	addl   $0x0,0x30(%esp)
 804907f:	83 54 24 34 ff       	adcl   $0xffffffff,0x34(%esp)
 8049084:	eb 24                	jmp    80490aa <__vprintf+0x3f4>
                break;
              default:
                NOT_REACHED ();
 8049086:	c7 44 24 0c 94 ac 04 	movl   $0x804ac94,0xc(%esp)
 804908d:	08 
 804908e:	c7 44 24 08 14 a8 04 	movl   $0x804a814,0x8(%esp)
 8049095:	08 
 8049096:	c7 44 24 04 dc 00 00 	movl   $0xdc,0x4(%esp)
 804909d:	00 
 804909e:	c7 04 24 6e a9 04 08 	movl   $0x804a96e,(%esp)
 80490a5:	e8 16 12 00 00       	call   804a2c0 <debug_panic>
              }

            format_integer (value < 0 ? -value : value,
 80490aa:	8b 54 24 34          	mov    0x34(%esp),%edx
 80490ae:	c1 fa 1f             	sar    $0x1f,%edx
 80490b1:	8b 4c 24 30          	mov    0x30(%esp),%ecx
 80490b5:	31 d1                	xor    %edx,%ecx
 80490b7:	89 4c 24 38          	mov    %ecx,0x38(%esp)
 80490bb:	8b 5c 24 34          	mov    0x34(%esp),%ebx
 80490bf:	31 d3                	xor    %edx,%ebx
 80490c1:	89 5c 24 3c          	mov    %ebx,0x3c(%esp)
 80490c5:	8b 4c 24 38          	mov    0x38(%esp),%ecx
 80490c9:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
 80490cd:	29 d1                	sub    %edx,%ecx
 80490cf:	19 d3                	sbb    %edx,%ebx
 80490d1:	89 c8                	mov    %ecx,%eax
 80490d3:	89 da                	mov    %ebx,%edx
 80490d5:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 80490dc:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 80490e0:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
 80490e7:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
                            true, value < 0, &base_d, &c, output, aux);
 80490eb:	8d 4c 24 4c          	lea    0x4c(%esp),%ecx
 80490ef:	89 4c 24 08          	mov    %ecx,0x8(%esp)
                break;
              default:
                NOT_REACHED ();
              }

            format_integer (value < 0 ? -value : value,
 80490f3:	c7 44 24 04 20 a8 04 	movl   $0x804a820,0x4(%esp)
 80490fa:	08 
 80490fb:	8b 4c 24 34          	mov    0x34(%esp),%ecx
 80490ff:	c1 e9 1f             	shr    $0x1f,%ecx
 8049102:	89 0c 24             	mov    %ecx,(%esp)
 8049105:	b9 01 00 00 00       	mov    $0x1,%ecx
 804910a:	e8 ee f7 ff ff       	call   80488fd <format_integer>
                            true, value < 0, &base_d, &c, output, aux);
          }
          break;
 804910f:	e9 06 03 00 00       	jmp    804941a <__vprintf+0x764>
          {
            /* Unsigned integer conversions. */
            uintmax_t value;
            const struct integer_base *b;

            switch (c.type) 
 8049114:	83 7c 24 58 08       	cmpl   $0x8,0x58(%esp)
 8049119:	0f 87 e5 00 00 00    	ja     8049204 <__vprintf+0x54e>
 804911f:	8b 44 24 58          	mov    0x58(%esp),%eax
 8049123:	ff 24 85 f0 a7 04 08 	jmp    *0x804a7f0(,%eax,4)
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
 804912a:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8049131:	0f b6 33             	movzbl (%ebx),%esi
 8049134:	bf 00 00 00 00       	mov    $0x0,%edi
 8049139:	8d 5b 04             	lea    0x4(%ebx),%ebx
 804913c:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8049143:	e9 e0 00 00 00       	jmp    8049228 <__vprintf+0x572>
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
 8049148:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 804914f:	0f b7 33             	movzwl (%ebx),%esi
 8049152:	bf 00 00 00 00       	mov    $0x0,%edi
 8049157:	8d 5b 04             	lea    0x4(%ebx),%ebx
 804915a:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8049161:	e9 c2 00 00 00       	jmp    8049228 <__vprintf+0x572>
              case INT:
                value = va_arg (args, unsigned);
 8049166:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 804916d:	8b 33                	mov    (%ebx),%esi
 804916f:	bf 00 00 00 00       	mov    $0x0,%edi
 8049174:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8049177:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 804917e:	e9 a5 00 00 00       	jmp    8049228 <__vprintf+0x572>
              case INTMAX:
                value = va_arg (args, uintmax_t);
 8049183:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 804918a:	8b 33                	mov    (%ebx),%esi
 804918c:	8b 7b 04             	mov    0x4(%ebx),%edi
 804918f:	8d 5b 08             	lea    0x8(%ebx),%ebx
 8049192:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8049199:	e9 8a 00 00 00       	jmp    8049228 <__vprintf+0x572>
              case LONG:
                value = va_arg (args, unsigned long);
 804919e:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 80491a5:	8b 33                	mov    (%ebx),%esi
 80491a7:	bf 00 00 00 00       	mov    $0x0,%edi
 80491ac:	8d 5b 04             	lea    0x4(%ebx),%ebx
 80491af:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 80491b6:	eb 70                	jmp    8049228 <__vprintf+0x572>
              case LONGLONG:
                value = va_arg (args, unsigned long long);
 80491b8:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 80491bf:	8b 33                	mov    (%ebx),%esi
 80491c1:	8b 7b 04             	mov    0x4(%ebx),%edi
 80491c4:	8d 5b 08             	lea    0x8(%ebx),%ebx
 80491c7:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 80491ce:	eb 58                	jmp    8049228 <__vprintf+0x572>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
 80491d0:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 80491d7:	8b 33                	mov    (%ebx),%esi
 80491d9:	bf 00 00 00 00       	mov    $0x0,%edi
                break;
              case LONGLONG:
                value = va_arg (args, unsigned long long);
                break;
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
 80491de:	8d 5b 04             	lea    0x4(%ebx),%ebx
 80491e1:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
#endif
                break;
 80491e8:	eb 3e                	jmp    8049228 <__vprintf+0x572>
              case SIZET:
                value = va_arg (args, size_t);
 80491ea:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 80491f1:	8b 33                	mov    (%ebx),%esi
 80491f3:	bf 00 00 00 00       	mov    $0x0,%edi
 80491f8:	8d 5b 04             	lea    0x4(%ebx),%ebx
 80491fb:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8049202:	eb 24                	jmp    8049228 <__vprintf+0x572>
              default:
                NOT_REACHED ();
 8049204:	c7 44 24 0c 94 ac 04 	movl   $0x804ac94,0xc(%esp)
 804920b:	08 
 804920c:	c7 44 24 08 14 a8 04 	movl   $0x804a814,0x8(%esp)
 8049213:	08 
 8049214:	c7 44 24 04 0b 01 00 	movl   $0x10b,0x4(%esp)
 804921b:	00 
 804921c:	c7 04 24 6e a9 04 08 	movl   $0x804a96e,(%esp)
 8049223:	e8 98 10 00 00       	call   804a2c0 <debug_panic>
              }

            switch (*format) 
 8049228:	80 fa 6f             	cmp    $0x6f,%dl
 804922b:	74 4c                	je     8049279 <__vprintf+0x5c3>
 804922d:	80 fa 6f             	cmp    $0x6f,%dl
 8049230:	7f 07                	jg     8049239 <__vprintf+0x583>
 8049232:	80 fa 58             	cmp    $0x58,%dl
 8049235:	75 1e                	jne    8049255 <__vprintf+0x59f>
 8049237:	eb 15                	jmp    804924e <__vprintf+0x598>
 8049239:	80 fa 75             	cmp    $0x75,%dl
 804923c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049240:	74 3e                	je     8049280 <__vprintf+0x5ca>
 8049242:	80 fa 78             	cmp    $0x78,%dl
 8049245:	75 0e                	jne    8049255 <__vprintf+0x59f>
              {
              case 'o': b = &base_o; break;
              case 'u': b = &base_d; break;
              case 'x': b = &base_x; break;
 8049247:	b8 40 a8 04 08       	mov    $0x804a840,%eax
 804924c:	eb 37                	jmp    8049285 <__vprintf+0x5cf>
              case 'X': b = &base_X; break;
 804924e:	b8 50 a8 04 08       	mov    $0x804a850,%eax
 8049253:	eb 30                	jmp    8049285 <__vprintf+0x5cf>
              default: NOT_REACHED ();
 8049255:	c7 44 24 0c 94 ac 04 	movl   $0x804ac94,0xc(%esp)
 804925c:	08 
 804925d:	c7 44 24 08 14 a8 04 	movl   $0x804a814,0x8(%esp)
 8049264:	08 
 8049265:	c7 44 24 04 14 01 00 	movl   $0x114,0x4(%esp)
 804926c:	00 
 804926d:	c7 04 24 6e a9 04 08 	movl   $0x804a96e,(%esp)
 8049274:	e8 47 10 00 00       	call   804a2c0 <debug_panic>
                NOT_REACHED ();
              }

            switch (*format) 
              {
              case 'o': b = &base_o; break;
 8049279:	b8 30 a8 04 08       	mov    $0x804a830,%eax
 804927e:	eb 05                	jmp    8049285 <__vprintf+0x5cf>
              case 'u': b = &base_d; break;
 8049280:	b8 20 a8 04 08       	mov    $0x804a820,%eax
              case 'x': b = &base_x; break;
              case 'X': b = &base_X; break;
              default: NOT_REACHED ();
              }

            format_integer (value, false, false, b, &c, output, aux);
 8049285:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 804928c:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 8049290:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
 8049297:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 804929b:	8d 54 24 4c          	lea    0x4c(%esp),%edx
 804929f:	89 54 24 08          	mov    %edx,0x8(%esp)
 80492a3:	89 44 24 04          	mov    %eax,0x4(%esp)
 80492a7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80492ae:	b9 00 00 00 00       	mov    $0x0,%ecx
 80492b3:	89 f0                	mov    %esi,%eax
 80492b5:	89 fa                	mov    %edi,%edx
 80492b7:	e8 41 f6 ff ff       	call   80488fd <format_integer>
          }
          break;
 80492bc:	e9 59 01 00 00       	jmp    804941a <__vprintf+0x764>

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
 80492c1:	8b ac 24 84 00 00 00 	mov    0x84(%esp),%ebp
 80492c8:	83 c5 04             	add    $0x4,%ebp
 80492cb:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 80492d2:	8b 03                	mov    (%ebx),%eax
 80492d4:	88 44 24 5f          	mov    %al,0x5f(%esp)
            format_string (&ch, 1, &c, output, aux);
 80492d8:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 80492df:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 80492e3:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
 80492ea:	89 1c 24             	mov    %ebx,(%esp)
 80492ed:	8d 4c 24 4c          	lea    0x4c(%esp),%ecx
 80492f1:	ba 01 00 00 00       	mov    $0x1,%edx
 80492f6:	8d 44 24 5f          	lea    0x5f(%esp),%eax
 80492fa:	e8 f5 f8 ff ff       	call   8048bf4 <format_string>
          break;

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
 80492ff:	89 ac 24 84 00 00 00 	mov    %ebp,0x84(%esp)
            format_string (&ch, 1, &c, output, aux);
          }
          break;
 8049306:	e9 0f 01 00 00       	jmp    804941a <__vprintf+0x764>

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
 804930b:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8049312:	83 c3 04             	add    $0x4,%ebx
 8049315:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
 804931c:	8b 28                	mov    (%eax),%ebp
            if (s == NULL)
              s = "(null)";
 804931e:	85 ed                	test   %ebp,%ebp
 8049320:	b8 67 a9 04 08       	mov    $0x804a967,%eax
 8049325:	0f 44 e8             	cmove  %eax,%ebp

            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
 8049328:	8b 44 24 54          	mov    0x54(%esp),%eax
 804932c:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049330:	89 2c 24             	mov    %ebp,(%esp)
 8049333:	e8 bb 0a 00 00       	call   8049df3 <strnlen>
 8049338:	8b 94 24 8c 00 00 00 	mov    0x8c(%esp),%edx
 804933f:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049343:	8b 8c 24 88 00 00 00 	mov    0x88(%esp),%ecx
 804934a:	89 0c 24             	mov    %ecx,(%esp)
 804934d:	8d 4c 24 4c          	lea    0x4c(%esp),%ecx
 8049351:	89 c2                	mov    %eax,%edx
 8049353:	89 e8                	mov    %ebp,%eax
 8049355:	e8 9a f8 ff ff       	call   8048bf4 <format_string>
          break;

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
 804935a:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
          }
          break;
 8049361:	e9 b4 00 00 00       	jmp    804941a <__vprintf+0x764>
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
 8049366:	8b ac 24 84 00 00 00 	mov    0x84(%esp),%ebp
 804936d:	83 c5 04             	add    $0x4,%ebp
 8049370:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8049377:	8b 03                	mov    (%ebx),%eax

            c.flags = POUND;
 8049379:	c7 44 24 4c 08 00 00 	movl   $0x8,0x4c(%esp)
 8049380:	00 
            format_integer ((uintptr_t) p, false, false,
 8049381:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 8049388:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 804938c:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
 8049393:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
                            &base_x, &c, output, aux);
 8049397:	8d 54 24 4c          	lea    0x4c(%esp),%edx
 804939b:	89 54 24 08          	mov    %edx,0x8(%esp)
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);

            c.flags = POUND;
            format_integer ((uintptr_t) p, false, false,
 804939f:	c7 44 24 04 40 a8 04 	movl   $0x804a840,0x4(%esp)
 80493a6:	08 
 80493a7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80493ae:	b9 00 00 00 00       	mov    $0x0,%ecx
 80493b3:	ba 00 00 00 00       	mov    $0x0,%edx
 80493b8:	e8 40 f5 ff ff       	call   80488fd <format_integer>
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
 80493bd:	89 ac 24 84 00 00 00 	mov    %ebp,0x84(%esp)

            c.flags = POUND;
            format_integer ((uintptr_t) p, false, false,
                            &base_x, &c, output, aux);
          }
          break;
 80493c4:	eb 54                	jmp    804941a <__vprintf+0x764>
        case 'g':
        case 'G':
        case 'n':
          /* We don't support floating-point arithmetic,
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
 80493c6:	0f be c2             	movsbl %dl,%eax
 80493c9:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80493cd:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 80493d4:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 80493d8:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
 80493df:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 80493e3:	c7 04 24 80 a9 04 08 	movl   $0x804a980,(%esp)
 80493ea:	e8 9c f8 ff ff       	call   8048c8b <__printf>
          break;
 80493ef:	eb 29                	jmp    804941a <__vprintf+0x764>

        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
 80493f1:	0f be c2             	movsbl %dl,%eax
 80493f4:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80493f8:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 80493ff:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 8049403:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
 804940a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804940e:	c7 04 24 96 a9 04 08 	movl   $0x804a996,(%esp)
 8049415:	e8 71 f8 ff ff       	call   8048c8b <__printf>

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
  for (; *format != '\0'; format++)
 804941a:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
 804941e:	83 c5 01             	add    $0x1,%ebp
 8049421:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8049425:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 8049429:	84 c0                	test   %al,%al
 804942b:	0f 85 9f f8 ff ff    	jne    8048cd0 <__vprintf+0x1a>
 8049431:	eb 0a                	jmp    804943d <__vprintf+0x787>
        }
      if (c->precision < 0) 
        c->precision = -1;
    }
  if (c->precision >= 0)
    c->flags &= ~ZERO;
 8049433:	83 64 24 4c ef       	andl   $0xffffffef,0x4c(%esp)
 8049438:	e9 49 fa ff ff       	jmp    8048e86 <__vprintf+0x1d0>
        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
          break;
        }
    }
}
 804943d:	83 c4 6c             	add    $0x6c,%esp
 8049440:	5b                   	pop    %ebx
 8049441:	5e                   	pop    %esi
 8049442:	5f                   	pop    %edi
 8049443:	5d                   	pop    %ebp
 8049444:	c3                   	ret    

08049445 <vsnprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) 
{
 8049445:	53                   	push   %ebx
 8049446:	83 ec 28             	sub    $0x28,%esp
 8049449:	8b 44 24 34          	mov    0x34(%esp),%eax
 804944d:	8b 54 24 38          	mov    0x38(%esp),%edx
 8049451:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
 8049455:	8b 5c 24 30          	mov    0x30(%esp),%ebx
 8049459:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  aux.length = 0;
 804945d:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
 8049464:	00 
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
 8049465:	85 c0                	test   %eax,%eax
 8049467:	74 33                	je     804949c <vsnprintf+0x57>
 8049469:	83 e8 01             	sub    $0x1,%eax
 804946c:	89 44 24 1c          	mov    %eax,0x1c(%esp)

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
 8049470:	8d 44 24 14          	lea    0x14(%esp),%eax
 8049474:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8049478:	c7 44 24 08 80 88 04 	movl   $0x8048880,0x8(%esp)
 804947f:	08 
 8049480:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 8049484:	89 14 24             	mov    %edx,(%esp)
 8049487:	e8 2a f8 ff ff       	call   8048cb6 <__vprintf>

  /* Add null terminator. */
  if (buf_size > 0)
    *aux.p = '\0';
 804948c:	8b 44 24 14          	mov    0x14(%esp),%eax
 8049490:	c6 00 00             	movb   $0x0,(%eax)

  return aux.length;
}
 8049493:	8b 44 24 18          	mov    0x18(%esp),%eax
 8049497:	83 c4 28             	add    $0x28,%esp
 804949a:	5b                   	pop    %ebx
 804949b:	c3                   	ret    
{
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
  aux.length = 0;
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
 804949c:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 80494a3:	00 

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
 80494a4:	8d 44 24 14          	lea    0x14(%esp),%eax
 80494a8:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80494ac:	c7 44 24 08 80 88 04 	movl   $0x8048880,0x8(%esp)
 80494b3:	08 
 80494b4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 80494b8:	89 14 24             	mov    %edx,(%esp)
 80494bb:	e8 f6 f7 ff ff       	call   8048cb6 <__vprintf>
 80494c0:	eb d1                	jmp    8049493 <vsnprintf+0x4e>

080494c2 <snprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
snprintf (char *buffer, size_t buf_size, const char *format, ...) 
{
 80494c2:	83 ec 1c             	sub    $0x1c,%esp
  va_list args;
  int retval;

  va_start (args, format);
 80494c5:	8d 44 24 2c          	lea    0x2c(%esp),%eax
  retval = vsnprintf (buffer, buf_size, format, args);
 80494c9:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80494cd:	8b 44 24 28          	mov    0x28(%esp),%eax
 80494d1:	89 44 24 08          	mov    %eax,0x8(%esp)
 80494d5:	8b 44 24 24          	mov    0x24(%esp),%eax
 80494d9:	89 44 24 04          	mov    %eax,0x4(%esp)
 80494dd:	8b 44 24 20          	mov    0x20(%esp),%eax
 80494e1:	89 04 24             	mov    %eax,(%esp)
 80494e4:	e8 5c ff ff ff       	call   8049445 <vsnprintf>
  va_end (args);

  return retval;
}
 80494e9:	83 c4 1c             	add    $0x1c,%esp
 80494ec:	c3                   	ret    

080494ed <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
 80494ed:	55                   	push   %ebp
 80494ee:	57                   	push   %edi
 80494ef:	56                   	push   %esi
 80494f0:	53                   	push   %ebx
 80494f1:	83 ec 3c             	sub    $0x3c,%esp
 80494f4:	0f b6 44 24 5c       	movzbl 0x5c(%esp),%eax
 80494f9:	88 44 24 2f          	mov    %al,0x2f(%esp)
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
 80494fd:	83 7c 24 58 00       	cmpl   $0x0,0x58(%esp)
 8049502:	0f 84 6e 01 00 00    	je     8049676 <hex_dump+0x189>
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
  const uint8_t *buf = buf_;
 8049508:	8b 54 24 54          	mov    0x54(%esp),%edx
 804950c:	89 54 24 20          	mov    %edx,0x20(%esp)
      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
 8049510:	bf 20 00 00 00       	mov    $0x20,%edi
    {
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
 8049515:	8b 74 24 50          	mov    0x50(%esp),%esi
 8049519:	83 e6 0f             	and    $0xf,%esi
      end = per_line;
      if (end - start > size)
 804951c:	b8 10 00 00 00       	mov    $0x10,%eax
 8049521:	29 f0                	sub    %esi,%eax
        end = start + size;
 8049523:	8b 6c 24 58          	mov    0x58(%esp),%ebp
 8049527:	01 f5                	add    %esi,%ebp
 8049529:	3b 44 24 58          	cmp    0x58(%esp),%eax
 804952d:	b8 10 00 00 00       	mov    $0x10,%eax
 8049532:	0f 46 e8             	cmovbe %eax,%ebp
      n = end - start;
 8049535:	89 ea                	mov    %ebp,%edx
 8049537:	29 f2                	sub    %esi,%edx
 8049539:	89 54 24 1c          	mov    %edx,0x1c(%esp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
 804953d:	8b 44 24 50          	mov    0x50(%esp),%eax
 8049541:	83 e0 f0             	and    $0xfffffff0,%eax
 8049544:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049548:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804954f:	00 
 8049550:	c7 04 24 ad a9 04 08 	movl   $0x804a9ad,(%esp)
 8049557:	e8 14 f7 ff ff       	call   8048c70 <printf>
      for (i = 0; i < start; i++)
 804955c:	bb 00 00 00 00       	mov    $0x0,%ebx
 8049561:	85 f6                	test   %esi,%esi
 8049563:	74 15                	je     804957a <hex_dump+0x8d>
        printf ("   ");
 8049565:	c7 04 24 b5 a9 04 08 	movl   $0x804a9b5,(%esp)
 804956c:	e8 ff f6 ff ff       	call   8048c70 <printf>
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
 8049571:	83 c3 01             	add    $0x1,%ebx
 8049574:	39 f3                	cmp    %esi,%ebx
 8049576:	75 ed                	jne    8049565 <hex_dump+0x78>
 8049578:	89 f3                	mov    %esi,%ebx
        printf ("   ");
      for (; i < end; i++) 
 804957a:	39 dd                	cmp    %ebx,%ebp
 804957c:	76 3c                	jbe    80495ba <hex_dump+0xcd>
   arranged 16 per line.  Numeric offsets are also included,
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
 804957e:	8b 44 24 20          	mov    0x20(%esp),%eax
 8049582:	29 f0                	sub    %esi,%eax
 8049584:	89 74 24 28          	mov    %esi,0x28(%esp)
 8049588:	89 c6                	mov    %eax,%esi
      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
 804958a:	83 fb 07             	cmp    $0x7,%ebx
 804958d:	b8 2d 00 00 00       	mov    $0x2d,%eax
 8049592:	0f 45 c7             	cmovne %edi,%eax
 8049595:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049599:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
 804959d:	89 44 24 04          	mov    %eax,0x4(%esp)
 80495a1:	c7 04 24 b9 a9 04 08 	movl   $0x804a9b9,(%esp)
 80495a8:	e8 c3 f6 ff ff       	call   8048c70 <printf>

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
 80495ad:	83 c3 01             	add    $0x1,%ebx
 80495b0:	39 dd                	cmp    %ebx,%ebp
 80495b2:	77 d6                	ja     804958a <hex_dump+0x9d>
 80495b4:	8b 74 24 28          	mov    0x28(%esp),%esi
 80495b8:	89 eb                	mov    %ebp,%ebx
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
 80495ba:	80 7c 24 2f 00       	cmpb   $0x0,0x2f(%esp)
 80495bf:	0f 84 8f 00 00 00    	je     8049654 <hex_dump+0x167>
        {
          for (; i < per_line; i++)
 80495c5:	83 fb 0f             	cmp    $0xf,%ebx
 80495c8:	77 14                	ja     80495de <hex_dump+0xf1>
            printf ("   ");
 80495ca:	c7 04 24 b5 a9 04 08 	movl   $0x804a9b5,(%esp)
 80495d1:	e8 9a f6 ff ff       	call   8048c70 <printf>
      for (; i < end; i++) 
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
        {
          for (; i < per_line; i++)
 80495d6:	83 c3 01             	add    $0x1,%ebx
 80495d9:	83 fb 10             	cmp    $0x10,%ebx
 80495dc:	75 ec                	jne    80495ca <hex_dump+0xdd>
            printf ("   ");
          printf ("|");
 80495de:	c7 04 24 7c 00 00 00 	movl   $0x7c,(%esp)
 80495e5:	e8 fe 0e 00 00       	call   804a4e8 <putchar>
          for (i = 0; i < start; i++)
 80495ea:	bb 00 00 00 00       	mov    $0x0,%ebx
 80495ef:	85 f6                	test   %esi,%esi
 80495f1:	74 11                	je     8049604 <hex_dump+0x117>
            printf (" ");
 80495f3:	89 3c 24             	mov    %edi,(%esp)
 80495f6:	e8 ed 0e 00 00       	call   804a4e8 <putchar>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
 80495fb:	83 c3 01             	add    $0x1,%ebx
 80495fe:	39 f3                	cmp    %esi,%ebx
 8049600:	75 f1                	jne    80495f3 <hex_dump+0x106>
 8049602:	89 f3                	mov    %esi,%ebx
            printf (" ");
          for (; i < end; i++)
 8049604:	39 dd                	cmp    %ebx,%ebp
 8049606:	76 2b                	jbe    8049633 <hex_dump+0x146>
   arranged 16 per line.  Numeric offsets are also included,
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
 8049608:	8b 54 24 20          	mov    0x20(%esp),%edx
 804960c:	29 f2                	sub    %esi,%edx
 804960e:	89 d6                	mov    %edx,%esi
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
 8049610:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
  return (c == ' ' || c == '\f' || c == '\n'
          || c == '\r' || c == '\t' || c == '\v');
}
static inline int isblank (int c) { return c == ' ' || c == '\t'; }
static inline int isgraph (int c) { return c > 32 && c < 127; }
static inline int isprint (int c) { return c >= 32 && c < 127; }
 8049614:	8d 50 e0             	lea    -0x20(%eax),%edx
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
 8049617:	83 fa 5f             	cmp    $0x5f,%edx
 804961a:	ba 2e 00 00 00       	mov    $0x2e,%edx
 804961f:	0f 43 c2             	cmovae %edx,%eax
 8049622:	89 04 24             	mov    %eax,(%esp)
 8049625:	e8 be 0e 00 00       	call   804a4e8 <putchar>
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
 804962a:	83 c3 01             	add    $0x1,%ebx
 804962d:	39 dd                	cmp    %ebx,%ebp
 804962f:	77 df                	ja     8049610 <hex_dump+0x123>
 8049631:	89 eb                	mov    %ebp,%ebx
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
 8049633:	83 fb 0f             	cmp    $0xf,%ebx
 8049636:	77 10                	ja     8049648 <hex_dump+0x15b>
            printf (" ");
 8049638:	89 3c 24             	mov    %edi,(%esp)
 804963b:	e8 a8 0e 00 00       	call   804a4e8 <putchar>
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
 8049640:	83 c3 01             	add    $0x1,%ebx
 8049643:	83 fb 10             	cmp    $0x10,%ebx
 8049646:	75 f0                	jne    8049638 <hex_dump+0x14b>
            printf (" ");
          printf ("|");
 8049648:	c7 04 24 7c 00 00 00 	movl   $0x7c,(%esp)
 804964f:	e8 94 0e 00 00       	call   804a4e8 <putchar>
        }
      printf ("\n");
 8049654:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 804965b:	e8 88 0e 00 00       	call   804a4e8 <putchar>

      ofs += n;
 8049660:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8049664:	01 44 24 50          	add    %eax,0x50(%esp)
      buf += n;
 8049668:	01 44 24 20          	add    %eax,0x20(%esp)
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
 804966c:	29 44 24 58          	sub    %eax,0x58(%esp)
 8049670:	0f 85 9f fe ff ff    	jne    8049515 <hex_dump+0x28>

      ofs += n;
      buf += n;
      size -= n;
    }
}
 8049676:	83 c4 3c             	add    $0x3c,%esp
 8049679:	5b                   	pop    %ebx
 804967a:	5e                   	pop    %esi
 804967b:	5f                   	pop    %edi
 804967c:	5d                   	pop    %ebp
 804967d:	c3                   	ret    

0804967e <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
 804967e:	57                   	push   %edi
 804967f:	56                   	push   %esi
 8049680:	83 ec 14             	sub    $0x14,%esp
 8049683:	8b 74 24 20          	mov    0x20(%esp),%esi
 8049687:	8b 7c 24 24          	mov    0x24(%esp),%edi
  if (size == 1)
 804968b:	89 f0                	mov    %esi,%eax
 804968d:	83 f0 01             	xor    $0x1,%eax
 8049690:	09 f8                	or     %edi,%eax
 8049692:	74 22                	je     80496b6 <print_human_readable_size+0x38>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
 8049694:	83 ff 00             	cmp    $0x0,%edi
 8049697:	77 0d                	ja     80496a6 <print_human_readable_size+0x28>
 8049699:	b9 70 be 04 08       	mov    $0x804be70,%ecx
 804969e:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
 80496a4:	76 42                	jbe    80496e8 <print_human_readable_size+0x6a>
 80496a6:	b9 70 be 04 08       	mov    $0x804be70,%ecx
 80496ab:	83 3d 74 be 04 08 00 	cmpl   $0x0,0x804be74
 80496b2:	75 10                	jne    80496c4 <print_human_readable_size+0x46>
 80496b4:	eb 32                	jmp    80496e8 <print_human_readable_size+0x6a>
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
  if (size == 1)
    printf ("1 byte");
 80496b6:	c7 04 24 c2 a9 04 08 	movl   $0x804a9c2,(%esp)
 80496bd:	e8 ae f5 ff ff       	call   8048c70 <printf>
 80496c2:	eb 3e                	jmp    8049702 <print_human_readable_size+0x84>
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
        size /= 1024;
 80496c4:	89 f0                	mov    %esi,%eax
 80496c6:	89 fa                	mov    %edi,%edx
 80496c8:	0f ac f8 0a          	shrd   $0xa,%edi,%eax
 80496cc:	c1 ea 0a             	shr    $0xa,%edx
 80496cf:	89 c6                	mov    %eax,%esi
 80496d1:	89 d7                	mov    %edx,%edi
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
 80496d3:	83 c1 04             	add    $0x4,%ecx
 80496d6:	83 fa 00             	cmp    $0x0,%edx
 80496d9:	77 07                	ja     80496e2 <print_human_readable_size+0x64>
 80496db:	3d ff 03 00 00       	cmp    $0x3ff,%eax
 80496e0:	76 06                	jbe    80496e8 <print_human_readable_size+0x6a>
 80496e2:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
 80496e6:	75 dc                	jne    80496c4 <print_human_readable_size+0x46>
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
 80496e8:	8b 01                	mov    (%ecx),%eax
 80496ea:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80496ee:	89 74 24 04          	mov    %esi,0x4(%esp)
 80496f2:	89 7c 24 08          	mov    %edi,0x8(%esp)
 80496f6:	c7 04 24 c9 a9 04 08 	movl   $0x804a9c9,(%esp)
 80496fd:	e8 6e f5 ff ff       	call   8048c70 <printf>
    }
}
 8049702:	83 c4 14             	add    $0x14,%esp
 8049705:	5e                   	pop    %esi
 8049706:	5f                   	pop    %edi
 8049707:	c3                   	ret    
 8049708:	90                   	nop
 8049709:	90                   	nop
 804970a:	90                   	nop
 804970b:	90                   	nop
 804970c:	90                   	nop
 804970d:	90                   	nop
 804970e:	90                   	nop
 804970f:	90                   	nop

08049710 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
 8049710:	56                   	push   %esi
 8049711:	53                   	push   %ebx
 8049712:	83 ec 24             	sub    $0x24,%esp
 8049715:	8b 44 24 30          	mov    0x30(%esp),%eax
 8049719:	8b 74 24 34          	mov    0x34(%esp),%esi
 804971d:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
 8049721:	85 db                	test   %ebx,%ebx
 8049723:	0f 94 c2             	sete   %dl
 8049726:	85 c0                	test   %eax,%eax
 8049728:	75 30                	jne    804975a <memcpy+0x4a>
 804972a:	84 d2                	test   %dl,%dl
 804972c:	75 2c                	jne    804975a <memcpy+0x4a>
 804972e:	c7 44 24 10 19 aa 04 	movl   $0x804aa19,0x10(%esp)
 8049735:	08 
 8049736:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 804973d:	08 
 804973e:	c7 44 24 08 60 a8 04 	movl   $0x804a860,0x8(%esp)
 8049745:	08 
 8049746:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
 804974d:	00 
 804974e:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049755:	e8 66 0b 00 00       	call   804a2c0 <debug_panic>
  ASSERT (src != NULL || size == 0);
 804975a:	84 d2                	test   %dl,%dl
 804975c:	75 04                	jne    8049762 <memcpy+0x52>
 804975e:	85 f6                	test   %esi,%esi
 8049760:	74 0b                	je     804976d <memcpy+0x5d>

  while (size-- > 0)
 8049762:	ba 00 00 00 00       	mov    $0x0,%edx
 8049767:	85 db                	test   %ebx,%ebx
 8049769:	75 2e                	jne    8049799 <memcpy+0x89>
 804976b:	eb 3a                	jmp    80497a7 <memcpy+0x97>
{
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);
 804976d:	c7 44 24 10 5c aa 04 	movl   $0x804aa5c,0x10(%esp)
 8049774:	08 
 8049775:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 804977c:	08 
 804977d:	c7 44 24 08 60 a8 04 	movl   $0x804a860,0x8(%esp)
 8049784:	08 
 8049785:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp)
 804978c:	00 
 804978d:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049794:	e8 27 0b 00 00       	call   804a2c0 <debug_panic>

  while (size-- > 0)
    *dst++ = *src++;
 8049799:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
 804979d:	88 0c 10             	mov    %cl,(%eax,%edx,1)
 80497a0:	83 c2 01             	add    $0x1,%edx
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
 80497a3:	39 da                	cmp    %ebx,%edx
 80497a5:	75 f2                	jne    8049799 <memcpy+0x89>
    *dst++ = *src++;

  return dst_;
}
 80497a7:	83 c4 24             	add    $0x24,%esp
 80497aa:	5b                   	pop    %ebx
 80497ab:	5e                   	pop    %esi
 80497ac:	c3                   	ret    

080497ad <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
 80497ad:	55                   	push   %ebp
 80497ae:	57                   	push   %edi
 80497af:	56                   	push   %esi
 80497b0:	53                   	push   %ebx
 80497b1:	83 ec 2c             	sub    $0x2c,%esp
 80497b4:	8b 5c 24 40          	mov    0x40(%esp),%ebx
 80497b8:	8b 74 24 44          	mov    0x44(%esp),%esi
 80497bc:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
 80497c0:	85 c9                	test   %ecx,%ecx
 80497c2:	0f 94 c0             	sete   %al
 80497c5:	85 db                	test   %ebx,%ebx
 80497c7:	75 30                	jne    80497f9 <memmove+0x4c>
 80497c9:	84 c0                	test   %al,%al
 80497cb:	75 2c                	jne    80497f9 <memmove+0x4c>
 80497cd:	c7 44 24 10 19 aa 04 	movl   $0x804aa19,0x10(%esp)
 80497d4:	08 
 80497d5:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 80497dc:	08 
 80497dd:	c7 44 24 08 67 a8 04 	movl   $0x804a867,0x8(%esp)
 80497e4:	08 
 80497e5:	c7 44 24 04 1d 00 00 	movl   $0x1d,0x4(%esp)
 80497ec:	00 
 80497ed:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 80497f4:	e8 c7 0a 00 00       	call   804a2c0 <debug_panic>
  ASSERT (src != NULL || size == 0);
 80497f9:	84 c0                	test   %al,%al
 80497fb:	75 30                	jne    804982d <memmove+0x80>
 80497fd:	85 f6                	test   %esi,%esi
 80497ff:	75 2c                	jne    804982d <memmove+0x80>
 8049801:	c7 44 24 10 5c aa 04 	movl   $0x804aa5c,0x10(%esp)
 8049808:	08 
 8049809:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 8049810:	08 
 8049811:	c7 44 24 08 67 a8 04 	movl   $0x804a867,0x8(%esp)
 8049818:	08 
 8049819:	c7 44 24 04 1e 00 00 	movl   $0x1e,0x4(%esp)
 8049820:	00 
 8049821:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049828:	e8 93 0a 00 00       	call   804a2c0 <debug_panic>

  if (dst < src) 
 804982d:	39 f3                	cmp    %esi,%ebx
 804982f:	73 1e                	jae    804984f <memmove+0xa2>
    {
      while (size-- > 0)
 8049831:	89 d8                	mov    %ebx,%eax
 8049833:	85 c9                	test   %ecx,%ecx
 8049835:	74 38                	je     804986f <memmove+0xc2>
 8049837:	b8 00 00 00 00       	mov    $0x0,%eax
        *dst++ = *src++;
 804983c:	0f b6 14 06          	movzbl (%esi,%eax,1),%edx
 8049840:	88 14 03             	mov    %dl,(%ebx,%eax,1)
 8049843:	83 c0 01             	add    $0x1,%eax
  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
    {
      while (size-- > 0)
 8049846:	39 c1                	cmp    %eax,%ecx
 8049848:	75 f2                	jne    804983c <memmove+0x8f>
 804984a:	8d 04 0b             	lea    (%ebx,%ecx,1),%eax
 804984d:	eb 20                	jmp    804986f <memmove+0xc2>
        *dst++ = *src++;
    }
  else 
    {
      dst += size;
 804984f:	8d 04 0b             	lea    (%ebx,%ecx,1),%eax
      src += size;
      while (size-- > 0)
 8049852:	85 c9                	test   %ecx,%ecx
 8049854:	74 19                	je     804986f <memmove+0xc2>
        *dst++ = *src++;
    }
  else 
    {
      dst += size;
      src += size;
 8049856:	89 ca                	mov    %ecx,%edx
}

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
 8049858:	89 cb                	mov    %ecx,%ebx
 804985a:	f7 db                	neg    %ebx
 804985c:	8d 2c 18             	lea    (%eax,%ebx,1),%ebp
  else 
    {
      dst += size;
      src += size;
      while (size-- > 0)
        *--dst = *--src;
 804985f:	0f b6 4c 16 ff       	movzbl -0x1(%esi,%edx,1),%ecx
 8049864:	88 4c 15 ff          	mov    %cl,-0x1(%ebp,%edx,1)
    }
  else 
    {
      dst += size;
      src += size;
      while (size-- > 0)
 8049868:	83 ea 01             	sub    $0x1,%edx
 804986b:	75 f2                	jne    804985f <memmove+0xb2>
 804986d:	01 d8                	add    %ebx,%eax
        *--dst = *--src;
    }

  return dst;
}
 804986f:	83 c4 2c             	add    $0x2c,%esp
 8049872:	5b                   	pop    %ebx
 8049873:	5e                   	pop    %esi
 8049874:	5f                   	pop    %edi
 8049875:	5d                   	pop    %ebp
 8049876:	c3                   	ret    

08049877 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
 8049877:	57                   	push   %edi
 8049878:	56                   	push   %esi
 8049879:	53                   	push   %ebx
 804987a:	83 ec 20             	sub    $0x20,%esp
 804987d:	8b 5c 24 30          	mov    0x30(%esp),%ebx
 8049881:	8b 74 24 34          	mov    0x34(%esp),%esi
 8049885:	8b 7c 24 38          	mov    0x38(%esp),%edi
  const unsigned char *a = a_;
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
 8049889:	85 ff                	test   %edi,%edi
 804988b:	0f 94 c0             	sete   %al
 804988e:	85 db                	test   %ebx,%ebx
 8049890:	75 30                	jne    80498c2 <memcmp+0x4b>
 8049892:	84 c0                	test   %al,%al
 8049894:	75 2c                	jne    80498c2 <memcmp+0x4b>
 8049896:	c7 44 24 10 75 aa 04 	movl   $0x804aa75,0x10(%esp)
 804989d:	08 
 804989e:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 80498a5:	08 
 80498a6:	c7 44 24 08 6f a8 04 	movl   $0x804a86f,0x8(%esp)
 80498ad:	08 
 80498ae:	c7 44 24 04 3a 00 00 	movl   $0x3a,0x4(%esp)
 80498b5:	00 
 80498b6:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 80498bd:	e8 fe 09 00 00       	call   804a2c0 <debug_panic>
  ASSERT (b != NULL || size == 0);
 80498c2:	84 c0                	test   %al,%al
 80498c4:	75 04                	jne    80498ca <memcmp+0x53>
 80498c6:	85 f6                	test   %esi,%esi
 80498c8:	74 1d                	je     80498e7 <memcmp+0x70>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
      return *a > *b ? +1 : -1;
  return 0;
 80498ca:	b8 00 00 00 00       	mov    $0x0,%eax
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
 80498cf:	85 ff                	test   %edi,%edi
 80498d1:	74 65                	je     8049938 <memcmp+0xc1>
    if (*a != *b)
 80498d3:	0f b6 13             	movzbl (%ebx),%edx
 80498d6:	0f b6 0e             	movzbl (%esi),%ecx
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
 80498d9:	83 ef 01             	sub    $0x1,%edi
 80498dc:	b8 00 00 00 00       	mov    $0x0,%eax
    if (*a != *b)
 80498e1:	38 ca                	cmp    %cl,%dl
 80498e3:	74 4a                	je     804992f <memcmp+0xb8>
 80498e5:	eb 3c                	jmp    8049923 <memcmp+0xac>
{
  const unsigned char *a = a_;
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);
 80498e7:	c7 44 24 10 8c aa 04 	movl   $0x804aa8c,0x10(%esp)
 80498ee:	08 
 80498ef:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 80498f6:	08 
 80498f7:	c7 44 24 08 6f a8 04 	movl   $0x804a86f,0x8(%esp)
 80498fe:	08 
 80498ff:	c7 44 24 04 3b 00 00 	movl   $0x3b,0x4(%esp)
 8049906:	00 
 8049907:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 804990e:	e8 ad 09 00 00       	call   804a2c0 <debug_panic>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
 8049913:	0f b6 54 03 01       	movzbl 0x1(%ebx,%eax,1),%edx
 8049918:	83 c0 01             	add    $0x1,%eax
 804991b:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
 804991f:	38 ca                	cmp    %cl,%dl
 8049921:	74 0c                	je     804992f <memcmp+0xb8>
      return *a > *b ? +1 : -1;
 8049923:	38 d1                	cmp    %dl,%cl
 8049925:	19 c0                	sbb    %eax,%eax
 8049927:	83 e0 02             	and    $0x2,%eax
 804992a:	83 e8 01             	sub    $0x1,%eax
 804992d:	eb 09                	jmp    8049938 <memcmp+0xc1>
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
 804992f:	39 f8                	cmp    %edi,%eax
 8049931:	75 e0                	jne    8049913 <memcmp+0x9c>
    if (*a != *b)
      return *a > *b ? +1 : -1;
  return 0;
 8049933:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049938:	83 c4 20             	add    $0x20,%esp
 804993b:	5b                   	pop    %ebx
 804993c:	5e                   	pop    %esi
 804993d:	5f                   	pop    %edi
 804993e:	c3                   	ret    

0804993f <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
 804993f:	53                   	push   %ebx
 8049940:	83 ec 28             	sub    $0x28,%esp
 8049943:	8b 4c 24 30          	mov    0x30(%esp),%ecx
 8049947:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  const unsigned char *a = (const unsigned char *) a_;
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
 804994b:	85 c9                	test   %ecx,%ecx
 804994d:	75 2c                	jne    804997b <strcmp+0x3c>
 804994f:	c7 44 24 10 a3 aa 04 	movl   $0x804aaa3,0x10(%esp)
 8049956:	08 
 8049957:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 804995e:	08 
 804995f:	c7 44 24 08 76 a8 04 	movl   $0x804a876,0x8(%esp)
 8049966:	08 
 8049967:	c7 44 24 04 4e 00 00 	movl   $0x4e,0x4(%esp)
 804996e:	00 
 804996f:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049976:	e8 45 09 00 00       	call   804a2c0 <debug_panic>
  ASSERT (b != NULL);
 804997b:	85 db                	test   %ebx,%ebx
 804997d:	74 0f                	je     804998e <strcmp+0x4f>

  while (*a != '\0' && *a == *b) 
 804997f:	0f b6 11             	movzbl (%ecx),%edx
 8049982:	89 d8                	mov    %ebx,%eax
 8049984:	84 d2                	test   %dl,%dl
 8049986:	74 44                	je     80499cc <strcmp+0x8d>
 8049988:	3a 13                	cmp    (%ebx),%dl
 804998a:	74 2e                	je     80499ba <strcmp+0x7b>
 804998c:	eb 3e                	jmp    80499cc <strcmp+0x8d>
{
  const unsigned char *a = (const unsigned char *) a_;
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);
 804998e:	c7 44 24 10 ad aa 04 	movl   $0x804aaad,0x10(%esp)
 8049995:	08 
 8049996:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 804999d:	08 
 804999e:	c7 44 24 08 76 a8 04 	movl   $0x804a876,0x8(%esp)
 80499a5:	08 
 80499a6:	c7 44 24 04 4f 00 00 	movl   $0x4f,0x4(%esp)
 80499ad:	00 
 80499ae:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 80499b5:	e8 06 09 00 00       	call   804a2c0 <debug_panic>

  while (*a != '\0' && *a == *b) 
    {
      a++;
      b++;
 80499ba:	83 c0 01             	add    $0x1,%eax
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
 80499bd:	0f b6 51 01          	movzbl 0x1(%ecx),%edx
 80499c1:	84 d2                	test   %dl,%dl
 80499c3:	74 07                	je     80499cc <strcmp+0x8d>
 80499c5:	83 c1 01             	add    $0x1,%ecx
 80499c8:	3a 10                	cmp    (%eax),%dl
 80499ca:	74 ee                	je     80499ba <strcmp+0x7b>
    {
      a++;
      b++;
    }

  return *a < *b ? -1 : *a > *b;
 80499cc:	0f b6 08             	movzbl (%eax),%ecx
 80499cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80499d4:	38 d1                	cmp    %dl,%cl
 80499d6:	77 06                	ja     80499de <strcmp+0x9f>
 80499d8:	0f 92 c0             	setb   %al
 80499db:	0f b6 c0             	movzbl %al,%eax
}
 80499de:	83 c4 28             	add    $0x28,%esp
 80499e1:	5b                   	pop    %ebx
 80499e2:	c3                   	ret    

080499e3 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
 80499e3:	53                   	push   %ebx
 80499e4:	83 ec 28             	sub    $0x28,%esp
 80499e7:	8b 5c 24 30          	mov    0x30(%esp),%ebx
 80499eb:	8b 4c 24 38          	mov    0x38(%esp),%ecx
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);
 80499ef:	85 db                	test   %ebx,%ebx
 80499f1:	75 04                	jne    80499f7 <memchr+0x14>
 80499f3:	85 c9                	test   %ecx,%ecx
 80499f5:	75 1a                	jne    8049a11 <memchr+0x2e>

  for (; size-- > 0; block++)
    if (*block == ch)
      return (void *) block;

  return NULL;
 80499f7:	b8 00 00 00 00       	mov    $0x0,%eax
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
 80499fc:	85 c9                	test   %ecx,%ecx
 80499fe:	74 4d                	je     8049a4d <memchr+0x6a>
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
  const unsigned char *block = block_;
  unsigned char ch = ch_;
 8049a00:	0f b6 54 24 34       	movzbl 0x34(%esp),%edx

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
    if (*block == ch)
 8049a05:	89 d8                	mov    %ebx,%eax

/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
 8049a07:	8d 4c 0b ff          	lea    -0x1(%ebx,%ecx,1),%ecx
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
    if (*block == ch)
 8049a0b:	38 13                	cmp    %dl,(%ebx)
 8049a0d:	75 35                	jne    8049a44 <memchr+0x61>
 8049a0f:	eb 3c                	jmp    8049a4d <memchr+0x6a>
memchr (const void *block_, int ch_, size_t size) 
{
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);
 8049a11:	c7 44 24 10 b7 aa 04 	movl   $0x804aab7,0x10(%esp)
 8049a18:	08 
 8049a19:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 8049a20:	08 
 8049a21:	c7 44 24 08 7d a8 04 	movl   $0x804a87d,0x8(%esp)
 8049a28:	08 
 8049a29:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
 8049a30:	00 
 8049a31:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049a38:	e8 83 08 00 00       	call   804a2c0 <debug_panic>

  for (; size-- > 0; block++)
 8049a3d:	83 c0 01             	add    $0x1,%eax
    if (*block == ch)
 8049a40:	38 10                	cmp    %dl,(%eax)
 8049a42:	74 09                	je     8049a4d <memchr+0x6a>
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
 8049a44:	39 c8                	cmp    %ecx,%eax
 8049a46:	75 f5                	jne    8049a3d <memchr+0x5a>
    if (*block == ch)
      return (void *) block;

  return NULL;
 8049a48:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049a4d:	83 c4 28             	add    $0x28,%esp
 8049a50:	5b                   	pop    %ebx
 8049a51:	c3                   	ret    

08049a52 <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
 8049a52:	83 ec 2c             	sub    $0x2c,%esp
 8049a55:	8b 44 24 30          	mov    0x30(%esp),%eax
  char c = c_;

  ASSERT (string != NULL);
 8049a59:	85 c0                	test   %eax,%eax
 8049a5b:	74 0e                	je     8049a6b <strchr+0x19>
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
  char c = c_;
 8049a5d:	0f b6 4c 24 34       	movzbl 0x34(%esp),%ecx

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
 8049a62:	0f b6 10             	movzbl (%eax),%edx
 8049a65:	38 ca                	cmp    %cl,%dl
 8049a67:	75 2e                	jne    8049a97 <strchr+0x45>
 8049a69:	eb 4f                	jmp    8049aba <strchr+0x68>
char *
strchr (const char *string, int c_) 
{
  char c = c_;

  ASSERT (string != NULL);
 8049a6b:	c7 44 24 10 d2 aa 04 	movl   $0x804aad2,0x10(%esp)
 8049a72:	08 
 8049a73:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 8049a7a:	08 
 8049a7b:	c7 44 24 08 84 a8 04 	movl   $0x804a884,0x8(%esp)
 8049a82:	08 
 8049a83:	c7 44 24 04 75 00 00 	movl   $0x75,0x4(%esp)
 8049a8a:	00 
 8049a8b:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049a92:	e8 29 08 00 00       	call   804a2c0 <debug_panic>

  for (;;) 
    if (*string == c)
      return (char *) string;
    else if (*string == '\0')
 8049a97:	84 d2                	test   %dl,%dl
 8049a99:	75 07                	jne    8049aa2 <strchr+0x50>
 8049a9b:	eb 11                	jmp    8049aae <strchr+0x5c>
 8049a9d:	84 d2                	test   %dl,%dl
 8049a9f:	90                   	nop
 8049aa0:	74 13                	je     8049ab5 <strchr+0x63>
      return NULL;
    else
      string++;
 8049aa2:	83 c0 01             	add    $0x1,%eax
  char c = c_;

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
 8049aa5:	0f b6 10             	movzbl (%eax),%edx
 8049aa8:	38 ca                	cmp    %cl,%dl
 8049aaa:	75 f1                	jne    8049a9d <strchr+0x4b>
 8049aac:	eb 0c                	jmp    8049aba <strchr+0x68>
      return (char *) string;
    else if (*string == '\0')
      return NULL;
 8049aae:	b8 00 00 00 00       	mov    $0x0,%eax
 8049ab3:	eb 05                	jmp    8049aba <strchr+0x68>
 8049ab5:	b8 00 00 00 00       	mov    $0x0,%eax
    else
      string++;
}
 8049aba:	83 c4 2c             	add    $0x2c,%esp
 8049abd:	c3                   	ret    

08049abe <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
 8049abe:	57                   	push   %edi
 8049abf:	56                   	push   %esi
 8049ac0:	53                   	push   %ebx
 8049ac1:	83 ec 10             	sub    $0x10,%esp
 8049ac4:	8b 74 24 20          	mov    0x20(%esp),%esi
 8049ac8:	8b 7c 24 24          	mov    0x24(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
 8049acc:	0f b6 06             	movzbl (%esi),%eax
 8049acf:	bb 00 00 00 00       	mov    $0x0,%ebx
 8049ad4:	84 c0                	test   %al,%al
 8049ad6:	74 1e                	je     8049af6 <strcspn+0x38>
    if (strchr (stop, string[length]) != NULL)
 8049ad8:	0f be c0             	movsbl %al,%eax
 8049adb:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049adf:	89 3c 24             	mov    %edi,(%esp)
 8049ae2:	e8 6b ff ff ff       	call   8049a52 <strchr>
 8049ae7:	85 c0                	test   %eax,%eax
 8049ae9:	75 0b                	jne    8049af6 <strcspn+0x38>
size_t
strcspn (const char *string, const char *stop) 
{
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
 8049aeb:	83 c3 01             	add    $0x1,%ebx
 8049aee:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
 8049af2:	84 c0                	test   %al,%al
 8049af4:	75 e2                	jne    8049ad8 <strcspn+0x1a>
    if (strchr (stop, string[length]) != NULL)
      break;
  return length;
}
 8049af6:	89 d8                	mov    %ebx,%eax
 8049af8:	83 c4 10             	add    $0x10,%esp
 8049afb:	5b                   	pop    %ebx
 8049afc:	5e                   	pop    %esi
 8049afd:	5f                   	pop    %edi
 8049afe:	c3                   	ret    

08049aff <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
 8049aff:	56                   	push   %esi
 8049b00:	53                   	push   %ebx
 8049b01:	83 ec 14             	sub    $0x14,%esp
 8049b04:	8b 5c 24 20          	mov    0x20(%esp),%ebx
 8049b08:	8b 74 24 24          	mov    0x24(%esp),%esi
  for (; *string != '\0'; string++)
 8049b0c:	0f b6 03             	movzbl (%ebx),%eax
 8049b0f:	84 c0                	test   %al,%al
 8049b11:	74 24                	je     8049b37 <strpbrk+0x38>
    if (strchr (stop, *string) != NULL)
 8049b13:	0f be c0             	movsbl %al,%eax
 8049b16:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049b1a:	89 34 24             	mov    %esi,(%esp)
 8049b1d:	e8 30 ff ff ff       	call   8049a52 <strchr>
 8049b22:	85 c0                	test   %eax,%eax
 8049b24:	75 16                	jne    8049b3c <strpbrk+0x3d>
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
  for (; *string != '\0'; string++)
 8049b26:	83 c3 01             	add    $0x1,%ebx
 8049b29:	0f b6 03             	movzbl (%ebx),%eax
 8049b2c:	84 c0                	test   %al,%al
 8049b2e:	75 e3                	jne    8049b13 <strpbrk+0x14>
    if (strchr (stop, *string) != NULL)
      return (char *) string;
  return NULL;
 8049b30:	bb 00 00 00 00       	mov    $0x0,%ebx
 8049b35:	eb 05                	jmp    8049b3c <strpbrk+0x3d>
 8049b37:	bb 00 00 00 00       	mov    $0x0,%ebx
}
 8049b3c:	89 d8                	mov    %ebx,%eax
 8049b3e:	83 c4 14             	add    $0x14,%esp
 8049b41:	5b                   	pop    %ebx
 8049b42:	5e                   	pop    %esi
 8049b43:	c3                   	ret    

08049b44 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
 8049b44:	53                   	push   %ebx
 8049b45:	8b 54 24 08          	mov    0x8(%esp),%edx
  char c = c_;
 8049b49:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
  const char *p = NULL;

  for (; *string != '\0'; string++)
 8049b4e:	0f b6 0a             	movzbl (%edx),%ecx
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
  char c = c_;
  const char *p = NULL;
 8049b51:	b8 00 00 00 00       	mov    $0x0,%eax

  for (; *string != '\0'; string++)
 8049b56:	84 c9                	test   %cl,%cl
 8049b58:	74 0f                	je     8049b69 <strrchr+0x25>
    if (*string == c)
 8049b5a:	38 cb                	cmp    %cl,%bl
 8049b5c:	0f 44 c2             	cmove  %edx,%eax
strrchr (const char *string, int c_) 
{
  char c = c_;
  const char *p = NULL;

  for (; *string != '\0'; string++)
 8049b5f:	83 c2 01             	add    $0x1,%edx
 8049b62:	0f b6 0a             	movzbl (%edx),%ecx
 8049b65:	84 c9                	test   %cl,%cl
 8049b67:	75 f1                	jne    8049b5a <strrchr+0x16>
    if (*string == c)
      p = string;
  return (char *) p;
}
 8049b69:	5b                   	pop    %ebx
 8049b6a:	c3                   	ret    

08049b6b <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
 8049b6b:	57                   	push   %edi
 8049b6c:	56                   	push   %esi
 8049b6d:	53                   	push   %ebx
 8049b6e:	83 ec 10             	sub    $0x10,%esp
 8049b71:	8b 74 24 20          	mov    0x20(%esp),%esi
 8049b75:	8b 7c 24 24          	mov    0x24(%esp),%edi
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
 8049b79:	0f b6 06             	movzbl (%esi),%eax
 8049b7c:	bb 00 00 00 00       	mov    $0x0,%ebx
 8049b81:	84 c0                	test   %al,%al
 8049b83:	74 1e                	je     8049ba3 <strspn+0x38>
    if (strchr (skip, string[length]) == NULL)
 8049b85:	0f be c0             	movsbl %al,%eax
 8049b88:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049b8c:	89 3c 24             	mov    %edi,(%esp)
 8049b8f:	e8 be fe ff ff       	call   8049a52 <strchr>
 8049b94:	85 c0                	test   %eax,%eax
 8049b96:	74 0b                	je     8049ba3 <strspn+0x38>
size_t
strspn (const char *string, const char *skip) 
{
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
 8049b98:	83 c3 01             	add    $0x1,%ebx
 8049b9b:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
 8049b9f:	84 c0                	test   %al,%al
 8049ba1:	75 e2                	jne    8049b85 <strspn+0x1a>
    if (strchr (skip, string[length]) == NULL)
      break;
  return length;
}
 8049ba3:	89 d8                	mov    %ebx,%eax
 8049ba5:	83 c4 10             	add    $0x10,%esp
 8049ba8:	5b                   	pop    %ebx
 8049ba9:	5e                   	pop    %esi
 8049baa:	5f                   	pop    %edi
 8049bab:	c3                   	ret    

08049bac <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
 8049bac:	55                   	push   %ebp
 8049bad:	57                   	push   %edi
 8049bae:	56                   	push   %esi
 8049baf:	53                   	push   %ebx
 8049bb0:	83 ec 3c             	sub    $0x3c,%esp
 8049bb3:	8b 74 24 50          	mov    0x50(%esp),%esi
 8049bb7:	8b 7c 24 54          	mov    0x54(%esp),%edi
  char *token;
  
  ASSERT (delimiters != NULL);
 8049bbb:	85 ff                	test   %edi,%edi
 8049bbd:	75 2c                	jne    8049beb <strtok_r+0x3f>
 8049bbf:	c7 44 24 10 e1 aa 04 	movl   $0x804aae1,0x10(%esp)
 8049bc6:	08 
 8049bc7:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 8049bce:	08 
 8049bcf:	c7 44 24 08 8b a8 04 	movl   $0x804a88b,0x8(%esp)
 8049bd6:	08 
 8049bd7:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
 8049bde:	00 
 8049bdf:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049be6:	e8 d5 06 00 00       	call   804a2c0 <debug_panic>
  ASSERT (save_ptr != NULL);
 8049beb:	83 7c 24 58 00       	cmpl   $0x0,0x58(%esp)
 8049bf0:	75 2c                	jne    8049c1e <strtok_r+0x72>
 8049bf2:	c7 44 24 10 f4 aa 04 	movl   $0x804aaf4,0x10(%esp)
 8049bf9:	08 
 8049bfa:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 8049c01:	08 
 8049c02:	c7 44 24 08 8b a8 04 	movl   $0x804a88b,0x8(%esp)
 8049c09:	08 
 8049c0a:	c7 44 24 04 f0 00 00 	movl   $0xf0,0x4(%esp)
 8049c11:	00 
 8049c12:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049c19:	e8 a2 06 00 00       	call   804a2c0 <debug_panic>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
 8049c1e:	85 f6                	test   %esi,%esi
 8049c20:	75 4a                	jne    8049c6c <strtok_r+0xc0>
    s = *save_ptr;
 8049c22:	8b 44 24 58          	mov    0x58(%esp),%eax
 8049c26:	8b 30                	mov    (%eax),%esi
  ASSERT (s != NULL);
 8049c28:	85 f6                	test   %esi,%esi
 8049c2a:	75 40                	jne    8049c6c <strtok_r+0xc0>
 8049c2c:	c7 44 24 10 ea aa 04 	movl   $0x804aaea,0x10(%esp)
 8049c33:	08 
 8049c34:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 8049c3b:	08 
 8049c3c:	c7 44 24 08 8b a8 04 	movl   $0x804a88b,0x8(%esp)
 8049c43:	08 
 8049c44:	c7 44 24 04 f6 00 00 	movl   $0xf6,0x4(%esp)
 8049c4b:	00 
 8049c4c:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049c53:	e8 68 06 00 00       	call   804a2c0 <debug_panic>
  while (strchr (delimiters, *s) != NULL) 
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
 8049c58:	84 db                	test   %bl,%bl
 8049c5a:	75 0d                	jne    8049c69 <strtok_r+0xbd>
        {
          *save_ptr = s;
 8049c5c:	8b 54 24 58          	mov    0x58(%esp),%edx
 8049c60:	89 32                	mov    %esi,(%edx)
          return NULL;
 8049c62:	b8 00 00 00 00       	mov    $0x0,%eax
 8049c67:	eb 64                	jmp    8049ccd <strtok_r+0x121>
        }

      s++;
 8049c69:	83 c6 01             	add    $0x1,%esi
  if (s == NULL)
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
 8049c6c:	0f b6 1e             	movzbl (%esi),%ebx
 8049c6f:	0f be c3             	movsbl %bl,%eax
 8049c72:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049c76:	89 3c 24             	mov    %edi,(%esp)
 8049c79:	e8 d4 fd ff ff       	call   8049a52 <strchr>
 8049c7e:	85 c0                	test   %eax,%eax
 8049c80:	75 d6                	jne    8049c58 <strtok_r+0xac>
 8049c82:	89 f3                	mov    %esi,%ebx
 8049c84:	eb 04                	jmp    8049c8a <strtok_r+0xde>
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
  while (strchr (delimiters, *s) == NULL)
    s++;
 8049c86:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8049c8a:	8d 43 01             	lea    0x1(%ebx),%eax
 8049c8d:	89 44 24 2c          	mov    %eax,0x2c(%esp)
      s++;
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
  while (strchr (delimiters, *s) == NULL)
 8049c91:	0f b6 6b 01          	movzbl 0x1(%ebx),%ebp
 8049c95:	89 ea                	mov    %ebp,%edx
 8049c97:	0f be c2             	movsbl %dl,%eax
 8049c9a:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049c9e:	89 3c 24             	mov    %edi,(%esp)
 8049ca1:	e8 ac fd ff ff       	call   8049a52 <strchr>
 8049ca6:	85 c0                	test   %eax,%eax
 8049ca8:	74 dc                	je     8049c86 <strtok_r+0xda>
    s++;
  if (*s != '\0') 
 8049caa:	89 e8                	mov    %ebp,%eax
 8049cac:	84 c0                	test   %al,%al
 8049cae:	74 11                	je     8049cc1 <strtok_r+0x115>
    {
      *s = '\0';
 8049cb0:	c6 43 01 00          	movb   $0x0,0x1(%ebx)
      *save_ptr = s + 1;
 8049cb4:	83 c3 02             	add    $0x2,%ebx
 8049cb7:	8b 54 24 58          	mov    0x58(%esp),%edx
 8049cbb:	89 1a                	mov    %ebx,(%edx)
 8049cbd:	89 f0                	mov    %esi,%eax
 8049cbf:	eb 0c                	jmp    8049ccd <strtok_r+0x121>
    }
  else 
    *save_ptr = s;
 8049cc1:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 8049cc5:	8b 44 24 58          	mov    0x58(%esp),%eax
 8049cc9:	89 10                	mov    %edx,(%eax)
 8049ccb:	89 f0                	mov    %esi,%eax
  return token;
}
 8049ccd:	83 c4 3c             	add    $0x3c,%esp
 8049cd0:	5b                   	pop    %ebx
 8049cd1:	5e                   	pop    %esi
 8049cd2:	5f                   	pop    %edi
 8049cd3:	5d                   	pop    %ebp
 8049cd4:	c3                   	ret    

08049cd5 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
 8049cd5:	53                   	push   %ebx
 8049cd6:	83 ec 28             	sub    $0x28,%esp
 8049cd9:	8b 44 24 30          	mov    0x30(%esp),%eax
 8049cdd:	8b 5c 24 34          	mov    0x34(%esp),%ebx
 8049ce1:	8b 54 24 38          	mov    0x38(%esp),%edx
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
 8049ce5:	85 c0                	test   %eax,%eax
 8049ce7:	75 04                	jne    8049ced <memset+0x18>
 8049ce9:	85 d2                	test   %edx,%edx
 8049ceb:	75 08                	jne    8049cf5 <memset+0x20>
  
  while (size-- > 0)
 8049ced:	89 c1                	mov    %eax,%ecx
 8049cef:	85 d2                	test   %edx,%edx
 8049cf1:	75 2e                	jne    8049d21 <memset+0x4c>
 8049cf3:	eb 36                	jmp    8049d2b <memset+0x56>
void *
memset (void *dst_, int value, size_t size) 
{
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
 8049cf5:	c7 44 24 10 19 aa 04 	movl   $0x804aa19,0x10(%esp)
 8049cfc:	08 
 8049cfd:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 8049d04:	08 
 8049d05:	c7 44 24 08 94 a8 04 	movl   $0x804a894,0x8(%esp)
 8049d0c:	08 
 8049d0d:	c7 44 24 04 1b 01 00 	movl   $0x11b,0x4(%esp)
 8049d14:	00 
 8049d15:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049d1c:	e8 9f 05 00 00       	call   804a2c0 <debug_panic>
  
  while (size-- > 0)
    *dst++ = value;
 8049d21:	88 19                	mov    %bl,(%ecx)
 8049d23:	83 c1 01             	add    $0x1,%ecx
{
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
 8049d26:	83 ea 01             	sub    $0x1,%edx
 8049d29:	75 f6                	jne    8049d21 <memset+0x4c>
    *dst++ = value;

  return dst_;
}
 8049d2b:	83 c4 28             	add    $0x28,%esp
 8049d2e:	5b                   	pop    %ebx
 8049d2f:	c3                   	ret    

08049d30 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
 8049d30:	83 ec 2c             	sub    $0x2c,%esp
 8049d33:	8b 54 24 30          	mov    0x30(%esp),%edx
  const char *p;

  ASSERT (string != NULL);
 8049d37:	85 d2                	test   %edx,%edx
 8049d39:	74 09                	je     8049d44 <strlen+0x14>

  for (p = string; *p != '\0'; p++)
 8049d3b:	89 d0                	mov    %edx,%eax
 8049d3d:	80 3a 00             	cmpb   $0x0,(%edx)
 8049d40:	75 2e                	jne    8049d70 <strlen+0x40>
 8049d42:	eb 34                	jmp    8049d78 <strlen+0x48>
size_t
strlen (const char *string) 
{
  const char *p;

  ASSERT (string != NULL);
 8049d44:	c7 44 24 10 d2 aa 04 	movl   $0x804aad2,0x10(%esp)
 8049d4b:	08 
 8049d4c:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 8049d53:	08 
 8049d54:	c7 44 24 08 9b a8 04 	movl   $0x804a89b,0x8(%esp)
 8049d5b:	08 
 8049d5c:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
 8049d63:	00 
 8049d64:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049d6b:	e8 50 05 00 00       	call   804a2c0 <debug_panic>

  for (p = string; *p != '\0'; p++)
 8049d70:	83 c0 01             	add    $0x1,%eax
 8049d73:	80 38 00             	cmpb   $0x0,(%eax)
 8049d76:	75 f8                	jne    8049d70 <strlen+0x40>
    continue;
  return p - string;
 8049d78:	29 d0                	sub    %edx,%eax
}
 8049d7a:	83 c4 2c             	add    $0x2c,%esp
 8049d7d:	c3                   	ret    

08049d7e <strstr>:
/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
{
 8049d7e:	55                   	push   %ebp
 8049d7f:	57                   	push   %edi
 8049d80:	56                   	push   %esi
 8049d81:	53                   	push   %ebx
 8049d82:	83 ec 2c             	sub    $0x2c,%esp
 8049d85:	8b 6c 24 44          	mov    0x44(%esp),%ebp
  size_t haystack_len = strlen (haystack);
 8049d89:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 8049d8e:	8b 7c 24 40          	mov    0x40(%esp),%edi
 8049d92:	b8 00 00 00 00       	mov    $0x0,%eax
 8049d97:	89 d1                	mov    %edx,%ecx
 8049d99:	f2 ae                	repnz scas %es:(%edi),%al
 8049d9b:	f7 d1                	not    %ecx
 8049d9d:	8d 59 ff             	lea    -0x1(%ecx),%ebx
  size_t needle_len = strlen (needle);
 8049da0:	89 ef                	mov    %ebp,%edi
 8049da2:	89 d1                	mov    %edx,%ecx
 8049da4:	f2 ae                	repnz scas %es:(%edi),%al
 8049da6:	89 ca                	mov    %ecx,%edx
 8049da8:	f7 d2                	not    %edx
 8049daa:	8d 7a ff             	lea    -0x1(%edx),%edi
      for (i = 0; i <= haystack_len - needle_len; i++)
        if (!memcmp (haystack + i, needle, needle_len))
          return (char *) haystack + i;
    }

  return NULL;
 8049dad:	be 00 00 00 00       	mov    $0x0,%esi
strstr (const char *haystack, const char *needle) 
{
  size_t haystack_len = strlen (haystack);
  size_t needle_len = strlen (needle);

  if (haystack_len >= needle_len) 
 8049db2:	39 fb                	cmp    %edi,%ebx
 8049db4:	72 33                	jb     8049de9 <strstr+0x6b>
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
 8049db6:	29 fb                	sub    %edi,%ebx
 8049db8:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
 8049dbc:	bb 00 00 00 00       	mov    $0x0,%ebx

/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
 8049dc1:	8b 74 24 40          	mov    0x40(%esp),%esi
 8049dc5:	01 de                	add    %ebx,%esi
  if (haystack_len >= needle_len) 
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
        if (!memcmp (haystack + i, needle, needle_len))
 8049dc7:	89 7c 24 08          	mov    %edi,0x8(%esp)
 8049dcb:	89 6c 24 04          	mov    %ebp,0x4(%esp)
 8049dcf:	89 34 24             	mov    %esi,(%esp)
 8049dd2:	e8 a0 fa ff ff       	call   8049877 <memcmp>
 8049dd7:	85 c0                	test   %eax,%eax
 8049dd9:	74 0e                	je     8049de9 <strstr+0x6b>

  if (haystack_len >= needle_len) 
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
 8049ddb:	83 c3 01             	add    $0x1,%ebx
 8049dde:	3b 5c 24 1c          	cmp    0x1c(%esp),%ebx
 8049de2:	76 dd                	jbe    8049dc1 <strstr+0x43>
        if (!memcmp (haystack + i, needle, needle_len))
          return (char *) haystack + i;
    }

  return NULL;
 8049de4:	be 00 00 00 00       	mov    $0x0,%esi
}
 8049de9:	89 f0                	mov    %esi,%eax
 8049deb:	83 c4 2c             	add    $0x2c,%esp
 8049dee:	5b                   	pop    %ebx
 8049def:	5e                   	pop    %esi
 8049df0:	5f                   	pop    %edi
 8049df1:	5d                   	pop    %ebp
 8049df2:	c3                   	ret    

08049df3 <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
 8049df3:	8b 54 24 04          	mov    0x4(%esp),%edx
 8049df7:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
 8049dfb:	80 3a 00             	cmpb   $0x0,(%edx)
 8049dfe:	74 18                	je     8049e18 <strnlen+0x25>
 8049e00:	85 c9                	test   %ecx,%ecx
 8049e02:	74 14                	je     8049e18 <strnlen+0x25>
 8049e04:	b8 00 00 00 00       	mov    $0x0,%eax
 8049e09:	83 c0 01             	add    $0x1,%eax
 8049e0c:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
 8049e10:	74 0b                	je     8049e1d <strnlen+0x2a>
 8049e12:	39 c1                	cmp    %eax,%ecx
 8049e14:	77 f3                	ja     8049e09 <strnlen+0x16>
 8049e16:	f3 c3                	repz ret 
 8049e18:	b8 00 00 00 00       	mov    $0x0,%eax
 8049e1d:	8d 76 00             	lea    0x0(%esi),%esi
    continue;
  return length;
}
 8049e20:	f3 c3                	repz ret 

08049e22 <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
 8049e22:	83 ec 3c             	sub    $0x3c,%esp
 8049e25:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
 8049e29:	89 74 24 30          	mov    %esi,0x30(%esp)
 8049e2d:	89 7c 24 34          	mov    %edi,0x34(%esp)
 8049e31:	89 6c 24 38          	mov    %ebp,0x38(%esp)
 8049e35:	8b 6c 24 40          	mov    0x40(%esp),%ebp
 8049e39:	8b 54 24 44          	mov    0x44(%esp),%edx
 8049e3d:	8b 5c 24 48          	mov    0x48(%esp),%ebx
  size_t src_len;

  ASSERT (dst != NULL);
 8049e41:	85 ed                	test   %ebp,%ebp
 8049e43:	75 2c                	jne    8049e71 <strlcpy+0x4f>
 8049e45:	c7 44 24 10 05 ab 04 	movl   $0x804ab05,0x10(%esp)
 8049e4c:	08 
 8049e4d:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 8049e54:	08 
 8049e55:	c7 44 24 08 a2 a8 04 	movl   $0x804a8a2,0x8(%esp)
 8049e5c:	08 
 8049e5d:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
 8049e64:	00 
 8049e65:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049e6c:	e8 4f 04 00 00       	call   804a2c0 <debug_panic>
  ASSERT (src != NULL);
 8049e71:	85 d2                	test   %edx,%edx
 8049e73:	75 2c                	jne    8049ea1 <strlcpy+0x7f>
 8049e75:	c7 44 24 10 11 ab 04 	movl   $0x804ab11,0x10(%esp)
 8049e7c:	08 
 8049e7d:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 8049e84:	08 
 8049e85:	c7 44 24 08 a2 a8 04 	movl   $0x804a8a2,0x8(%esp)
 8049e8c:	08 
 8049e8d:	c7 44 24 04 4b 01 00 	movl   $0x14b,0x4(%esp)
 8049e94:	00 
 8049e95:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049e9c:	e8 1f 04 00 00       	call   804a2c0 <debug_panic>

  src_len = strlen (src);
 8049ea1:	89 d7                	mov    %edx,%edi
 8049ea3:	b8 00 00 00 00       	mov    $0x0,%eax
 8049ea8:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 8049ead:	f2 ae                	repnz scas %es:(%edi),%al
 8049eaf:	f7 d1                	not    %ecx
 8049eb1:	8d 71 ff             	lea    -0x1(%ecx),%esi
  if (size > 0) 
 8049eb4:	85 db                	test   %ebx,%ebx
 8049eb6:	74 1d                	je     8049ed5 <strlcpy+0xb3>
    {
      size_t dst_len = size - 1;
 8049eb8:	83 eb 01             	sub    $0x1,%ebx
 8049ebb:	39 de                	cmp    %ebx,%esi
 8049ebd:	0f 46 de             	cmovbe %esi,%ebx
      if (src_len < dst_len)
        dst_len = src_len;
      memcpy (dst, src, dst_len);
 8049ec0:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 8049ec4:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049ec8:	89 2c 24             	mov    %ebp,(%esp)
 8049ecb:	e8 40 f8 ff ff       	call   8049710 <memcpy>
      dst[dst_len] = '\0';
 8049ed0:	c6 44 1d 00 00       	movb   $0x0,0x0(%ebp,%ebx,1)
    }
  return src_len;
}
 8049ed5:	89 f0                	mov    %esi,%eax
 8049ed7:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8049edb:	8b 74 24 30          	mov    0x30(%esp),%esi
 8049edf:	8b 7c 24 34          	mov    0x34(%esp),%edi
 8049ee3:	8b 6c 24 38          	mov    0x38(%esp),%ebp
 8049ee7:	83 c4 3c             	add    $0x3c,%esp
 8049eea:	c3                   	ret    

08049eeb <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
 8049eeb:	83 ec 3c             	sub    $0x3c,%esp
 8049eee:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
 8049ef2:	89 74 24 30          	mov    %esi,0x30(%esp)
 8049ef6:	89 7c 24 34          	mov    %edi,0x34(%esp)
 8049efa:	89 6c 24 38          	mov    %ebp,0x38(%esp)
 8049efe:	8b 5c 24 40          	mov    0x40(%esp),%ebx
 8049f02:	8b 54 24 44          	mov    0x44(%esp),%edx
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
 8049f06:	85 db                	test   %ebx,%ebx
 8049f08:	75 2c                	jne    8049f36 <strlcat+0x4b>
 8049f0a:	c7 44 24 10 05 ab 04 	movl   $0x804ab05,0x10(%esp)
 8049f11:	08 
 8049f12:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 8049f19:	08 
 8049f1a:	c7 44 24 08 aa a8 04 	movl   $0x804a8aa,0x8(%esp)
 8049f21:	08 
 8049f22:	c7 44 24 04 68 01 00 	movl   $0x168,0x4(%esp)
 8049f29:	00 
 8049f2a:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049f31:	e8 8a 03 00 00       	call   804a2c0 <debug_panic>
  ASSERT (src != NULL);
 8049f36:	85 d2                	test   %edx,%edx
 8049f38:	75 2c                	jne    8049f66 <strlcat+0x7b>
 8049f3a:	c7 44 24 10 11 ab 04 	movl   $0x804ab11,0x10(%esp)
 8049f41:	08 
 8049f42:	c7 44 24 0c 32 aa 04 	movl   $0x804aa32,0xc(%esp)
 8049f49:	08 
 8049f4a:	c7 44 24 08 aa a8 04 	movl   $0x804a8aa,0x8(%esp)
 8049f51:	08 
 8049f52:	c7 44 24 04 69 01 00 	movl   $0x169,0x4(%esp)
 8049f59:	00 
 8049f5a:	c7 04 24 49 aa 04 08 	movl   $0x804aa49,(%esp)
 8049f61:	e8 5a 03 00 00       	call   804a2c0 <debug_panic>

  src_len = strlen (src);
 8049f66:	be ff ff ff ff       	mov    $0xffffffff,%esi
 8049f6b:	89 d7                	mov    %edx,%edi
 8049f6d:	b8 00 00 00 00       	mov    $0x0,%eax
 8049f72:	89 f1                	mov    %esi,%ecx
 8049f74:	f2 ae                	repnz scas %es:(%edi),%al
 8049f76:	f7 d1                	not    %ecx
 8049f78:	8d 69 ff             	lea    -0x1(%ecx),%ebp
  dst_len = strlen (dst);
 8049f7b:	89 df                	mov    %ebx,%edi
 8049f7d:	89 f1                	mov    %esi,%ecx
 8049f7f:	f2 ae                	repnz scas %es:(%edi),%al
 8049f81:	89 ce                	mov    %ecx,%esi
 8049f83:	f7 d6                	not    %esi
 8049f85:	83 ee 01             	sub    $0x1,%esi
  if (size > 0 && dst_len < size) 
 8049f88:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
 8049f8d:	74 2a                	je     8049fb9 <strlcat+0xce>
 8049f8f:	3b 74 24 48          	cmp    0x48(%esp),%esi
 8049f93:	73 24                	jae    8049fb9 <strlcat+0xce>
    {
      size_t copy_cnt = size - dst_len - 1;
 8049f95:	8b 7c 24 48          	mov    0x48(%esp),%edi
 8049f99:	83 ef 01             	sub    $0x1,%edi
 8049f9c:	29 f7                	sub    %esi,%edi
 8049f9e:	39 ef                	cmp    %ebp,%edi
 8049fa0:	0f 47 fd             	cmova  %ebp,%edi
      if (src_len < copy_cnt)
        copy_cnt = src_len;
      memcpy (dst + dst_len, src, copy_cnt);
 8049fa3:	01 f3                	add    %esi,%ebx
 8049fa5:	89 7c 24 08          	mov    %edi,0x8(%esp)
 8049fa9:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049fad:	89 1c 24             	mov    %ebx,(%esp)
 8049fb0:	e8 5b f7 ff ff       	call   8049710 <memcpy>
      dst[dst_len + copy_cnt] = '\0';
 8049fb5:	c6 04 3b 00          	movb   $0x0,(%ebx,%edi,1)
    }
  return src_len + dst_len;
 8049fb9:	8d 04 2e             	lea    (%esi,%ebp,1),%eax
}
 8049fbc:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8049fc0:	8b 74 24 30          	mov    0x30(%esp),%esi
 8049fc4:	8b 7c 24 34          	mov    0x34(%esp),%edi
 8049fc8:	8b 6c 24 38          	mov    0x38(%esp),%ebp
 8049fcc:	83 c4 3c             	add    $0x3c,%esp
 8049fcf:	c3                   	ret    

08049fd0 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
 8049fd0:	83 ec 2c             	sub    $0x2c,%esp
 8049fd3:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
 8049fd7:	89 74 24 20          	mov    %esi,0x20(%esp)
 8049fdb:	89 7c 24 24          	mov    %edi,0x24(%esp)
 8049fdf:	89 6c 24 28          	mov    %ebp,0x28(%esp)
 8049fe3:	89 c6                	mov    %eax,%esi
 8049fe5:	89 d7                	mov    %edx,%edi
 8049fe7:	8b 44 24 30          	mov    0x30(%esp),%eax
 8049feb:	8b 54 24 34          	mov    0x34(%esp),%edx
 8049fef:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049ff3:	89 54 24 0c          	mov    %edx,0xc(%esp)
  if ((d >> 32) == 0) 
 8049ff7:	89 d0                	mov    %edx,%eax
 8049ff9:	85 d2                	test   %edx,%edx
 8049ffb:	75 3c                	jne    804a039 <udiv64+0x69>
             <=> [b - 1/d] < b
         which is a tautology.

         Therefore, this code is correct and will not trap. */
      uint64_t b = 1ULL << 32;
      uint32_t n1 = n >> 32;
 8049ffd:	89 f8                	mov    %edi,%eax
      uint32_t n0 = n; 
      uint32_t d0 = d;
 8049fff:	8b 6c 24 08          	mov    0x8(%esp),%ebp

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
 804a003:	ba 00 00 00 00       	mov    $0x0,%edx
 804a008:	f7 f5                	div    %ebp
 804a00a:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a00e:	b9 00 00 00 00       	mov    $0x0,%ecx
 804a013:	bf 00 00 00 00       	mov    $0x0,%edi
 804a018:	01 ce                	add    %ecx,%esi
 804a01a:	11 d7                	adc    %edx,%edi
{
  uint32_t n1 = n >> 32;
  uint32_t n0 = n;
  uint32_t q, r;

  asm ("divl %4"
 804a01c:	89 fa                	mov    %edi,%edx
 804a01e:	89 f0                	mov    %esi,%eax
 804a020:	f7 f5                	div    %ebp
      uint64_t b = 1ULL << 32;
      uint32_t n1 = n >> 32;
      uint32_t n0 = n; 
      uint32_t d0 = d;

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
 804a022:	bf 00 00 00 00       	mov    $0x0,%edi
 804a027:	8b 5c 24 08          	mov    0x8(%esp),%ebx
 804a02b:	b9 00 00 00 00       	mov    $0x0,%ecx
 804a030:	01 c1                	add    %eax,%ecx
 804a032:	11 fb                	adc    %edi,%ebx
 804a034:	e9 fe 00 00 00       	jmp    804a137 <udiv64+0x167>
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
 804a039:	39 7c 24 0c          	cmp    %edi,0xc(%esp)
 804a03d:	0f 87 ea 00 00 00    	ja     804a12d <udiv64+0x15d>
 804a043:	72 0a                	jb     804a04f <udiv64+0x7f>
 804a045:	39 74 24 08          	cmp    %esi,0x8(%esp)
 804a049:	0f 87 de 00 00 00    	ja     804a12d <udiv64+0x15d>
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
 804a04f:	89 c2                	mov    %eax,%edx
  /* This technique is portable, but there are better ways to do
     it on particular systems.  With sufficiently new enough GCC,
     you can use __builtin_clz() to take advantage of GCC's
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
 804a051:	b9 00 00 00 00       	mov    $0x0,%ecx
  if (x <= 0x0000FFFF)
 804a056:	3d ff ff 00 00       	cmp    $0xffff,%eax
 804a05b:	77 05                	ja     804a062 <udiv64+0x92>
    {
      n += 16;
      x <<= 16; 
 804a05d:	c1 e2 10             	shl    $0x10,%edx
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
  if (x <= 0x0000FFFF)
    {
      n += 16;
 804a060:	b1 10                	mov    $0x10,%cl
      x <<= 16; 
    }
  if (x <= 0x00FFFFFF)
 804a062:	81 fa ff ff ff 00    	cmp    $0xffffff,%edx
 804a068:	77 06                	ja     804a070 <udiv64+0xa0>
    {
      n += 8;
 804a06a:	83 c1 08             	add    $0x8,%ecx
      x <<= 8; 
 804a06d:	c1 e2 08             	shl    $0x8,%edx
    }
  if (x <= 0x0FFFFFFF)
 804a070:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
 804a076:	77 06                	ja     804a07e <udiv64+0xae>
    {
      n += 4;
 804a078:	83 c1 04             	add    $0x4,%ecx
      x <<= 4;
 804a07b:	c1 e2 04             	shl    $0x4,%edx
    }
  if (x <= 0x3FFFFFFF)
 804a07e:	81 fa ff ff ff 3f    	cmp    $0x3fffffff,%edx
 804a084:	77 06                	ja     804a08c <udiv64+0xbc>
    {
      n += 2;
 804a086:	83 c1 02             	add    $0x2,%ecx
      x <<= 2; 
 804a089:	c1 e2 02             	shl    $0x2,%edx
    }
  if (x <= 0x7FFFFFFF)
    n++;
 804a08c:	81 fa 00 00 00 80    	cmp    $0x80000000,%edx
 804a092:	83 d1 00             	adc    $0x0,%ecx
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
 804a095:	89 f0                	mov    %esi,%eax
 804a097:	89 fa                	mov    %edi,%edx
 804a099:	0f ac f8 01          	shrd   $0x1,%edi,%eax
 804a09d:	d1 ea                	shr    %edx
 804a09f:	89 04 24             	mov    %eax,(%esp)
 804a0a2:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a0a6:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a0aa:	8b 54 24 0c          	mov    0xc(%esp),%edx
 804a0ae:	0f a5 c2             	shld   %cl,%eax,%edx
 804a0b1:	d3 e0                	shl    %cl,%eax
 804a0b3:	f6 c1 20             	test   $0x20,%cl
 804a0b6:	74 02                	je     804a0ba <udiv64+0xea>
 804a0b8:	89 c2                	mov    %eax,%edx
 804a0ba:	89 54 24 14          	mov    %edx,0x14(%esp)
{
  uint32_t n1 = n >> 32;
  uint32_t n0 = n;
  uint32_t q, r;

  asm ("divl %4"
 804a0be:	8b 54 24 04          	mov    0x4(%esp),%edx
 804a0c2:	8b 04 24             	mov    (%esp),%eax
 804a0c5:	f7 74 24 14          	divl   0x14(%esp)
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
 804a0c9:	ba 1f 00 00 00       	mov    $0x1f,%edx
 804a0ce:	29 ca                	sub    %ecx,%edx
 804a0d0:	89 d1                	mov    %edx,%ecx
 804a0d2:	d3 e8                	shr    %cl,%eax
 804a0d4:	89 44 24 10          	mov    %eax,0x10(%esp)
 804a0d8:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804a0df:	00 
          return n - (q - 1) * d < d ? q - 1 : q; 
 804a0e0:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 804a0e4:	8b 5c 24 14          	mov    0x14(%esp),%ebx
 804a0e8:	83 c1 ff             	add    $0xffffffff,%ecx
 804a0eb:	83 d3 ff             	adc    $0xffffffff,%ebx
 804a0ee:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a0f2:	0f af c3             	imul   %ebx,%eax
 804a0f5:	8b 54 24 0c          	mov    0xc(%esp),%edx
 804a0f9:	0f af d1             	imul   %ecx,%edx
 804a0fc:	8d 2c 10             	lea    (%eax,%edx,1),%ebp
 804a0ff:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a103:	f7 e1                	mul    %ecx
 804a105:	89 04 24             	mov    %eax,(%esp)
 804a108:	01 ea                	add    %ebp,%edx
 804a10a:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a10e:	2b 34 24             	sub    (%esp),%esi
 804a111:	1b 7c 24 04          	sbb    0x4(%esp),%edi
 804a115:	39 7c 24 0c          	cmp    %edi,0xc(%esp)
 804a119:	77 1c                	ja     804a137 <udiv64+0x167>
 804a11b:	72 06                	jb     804a123 <udiv64+0x153>
 804a11d:	39 74 24 08          	cmp    %esi,0x8(%esp)
 804a121:	77 14                	ja     804a137 <udiv64+0x167>
 804a123:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 804a127:	8b 5c 24 14          	mov    0x14(%esp),%ebx
 804a12b:	eb 0a                	jmp    804a137 <udiv64+0x167>
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
        return 0;
 804a12d:	b9 00 00 00 00       	mov    $0x0,%ecx
 804a132:	bb 00 00 00 00       	mov    $0x0,%ebx
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
          return n - (q - 1) * d < d ? q - 1 : q; 
        }
    }
}
 804a137:	89 c8                	mov    %ecx,%eax
 804a139:	89 da                	mov    %ebx,%edx
 804a13b:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
 804a13f:	8b 74 24 20          	mov    0x20(%esp),%esi
 804a143:	8b 7c 24 24          	mov    0x24(%esp),%edi
 804a147:	8b 6c 24 28          	mov    0x28(%esp),%ebp
 804a14b:	83 c4 2c             	add    $0x2c,%esp
 804a14e:	c3                   	ret    

0804a14f <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
 804a14f:	83 ec 1c             	sub    $0x1c,%esp
 804a152:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 804a156:	89 74 24 14          	mov    %esi,0x14(%esp)
 804a15a:	89 7c 24 18          	mov    %edi,0x18(%esp)
 804a15e:	89 c6                	mov    %eax,%esi
 804a160:	89 d7                	mov    %edx,%edi
 804a162:	8b 44 24 20          	mov    0x20(%esp),%eax
 804a166:	8b 54 24 24          	mov    0x24(%esp),%edx
 804a16a:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a16e:	89 54 24 0c          	mov    %edx,0xc(%esp)
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
 804a172:	89 f0                	mov    %esi,%eax
 804a174:	89 fa                	mov    %edi,%edx
 804a176:	f7 d8                	neg    %eax
 804a178:	83 d2 00             	adc    $0x0,%edx
 804a17b:	f7 da                	neg    %edx
 804a17d:	85 ff                	test   %edi,%edi
 804a17f:	78 04                	js     804a185 <sdiv64+0x36>
 804a181:	89 f0                	mov    %esi,%eax
 804a183:	89 fa                	mov    %edi,%edx
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
 804a185:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 804a189:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
 804a18d:	f7 d9                	neg    %ecx
 804a18f:	83 d3 00             	adc    $0x0,%ebx
 804a192:	f7 db                	neg    %ebx
 804a194:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
 804a199:	78 08                	js     804a1a3 <sdiv64+0x54>
 804a19b:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 804a19f:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  uint64_t q_abs = udiv64 (n_abs, d_abs);
 804a1a3:	89 0c 24             	mov    %ecx,(%esp)
 804a1a6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804a1aa:	e8 21 fe ff ff       	call   8049fd0 <udiv64>
 804a1af:	89 c1                	mov    %eax,%ecx
 804a1b1:	89 d3                	mov    %edx,%ebx
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
 804a1b3:	f7 d7                	not    %edi
 804a1b5:	c1 ef 1f             	shr    $0x1f,%edi
 804a1b8:	8b 74 24 0c          	mov    0xc(%esp),%esi
 804a1bc:	c1 ee 1f             	shr    $0x1f,%esi
 804a1bf:	f7 d8                	neg    %eax
 804a1c1:	83 d2 00             	adc    $0x0,%edx
 804a1c4:	f7 da                	neg    %edx
 804a1c6:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a1ca:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804a1ce:	89 fa                	mov    %edi,%edx
 804a1d0:	89 f0                	mov    %esi,%eax
 804a1d2:	38 c2                	cmp    %al,%dl
 804a1d4:	74 08                	je     804a1de <sdiv64+0x8f>
 804a1d6:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804a1da:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
}
 804a1de:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a1e2:	8b 54 24 0c          	mov    0xc(%esp),%edx
 804a1e6:	8b 5c 24 10          	mov    0x10(%esp),%ebx
 804a1ea:	8b 74 24 14          	mov    0x14(%esp),%esi
 804a1ee:	8b 7c 24 18          	mov    0x18(%esp),%edi
 804a1f2:	83 c4 1c             	add    $0x1c,%esp
 804a1f5:	c3                   	ret    

0804a1f6 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
 804a1f6:	83 ec 0c             	sub    $0xc,%esp
  return sdiv64 (n, d);
 804a1f9:	8b 44 24 18          	mov    0x18(%esp),%eax
 804a1fd:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 804a201:	89 04 24             	mov    %eax,(%esp)
 804a204:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a208:	8b 44 24 10          	mov    0x10(%esp),%eax
 804a20c:	8b 54 24 14          	mov    0x14(%esp),%edx
 804a210:	e8 3a ff ff ff       	call   804a14f <sdiv64>
}
 804a215:	83 c4 0c             	add    $0xc,%esp
 804a218:	c3                   	ret    

0804a219 <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
 804a219:	83 ec 14             	sub    $0x14,%esp
 804a21c:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 804a220:	89 74 24 10          	mov    %esi,0x10(%esp)
 804a224:	8b 74 24 18          	mov    0x18(%esp),%esi
 804a228:	8b 5c 24 20          	mov    0x20(%esp),%ebx
/* Divides signed 64-bit N by signed 64-bit D and returns the
   remainder. */
static int32_t
smod64 (int64_t n, int64_t d)
{
  return n - d * sdiv64 (n, d);
 804a22c:	89 1c 24             	mov    %ebx,(%esp)
 804a22f:	8b 44 24 24          	mov    0x24(%esp),%eax
 804a233:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a237:	89 f0                	mov    %esi,%eax
 804a239:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 804a23d:	e8 0d ff ff ff       	call   804a14f <sdiv64>
 804a242:	0f af d8             	imul   %eax,%ebx
 804a245:	89 f0                	mov    %esi,%eax
 804a247:	29 d8                	sub    %ebx,%eax

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
  return smod64 (n, d);
 804a249:	89 c2                	mov    %eax,%edx
 804a24b:	c1 fa 1f             	sar    $0x1f,%edx
}
 804a24e:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
 804a252:	8b 74 24 10          	mov    0x10(%esp),%esi
 804a256:	83 c4 14             	add    $0x14,%esp
 804a259:	c3                   	ret    

0804a25a <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
 804a25a:	83 ec 0c             	sub    $0xc,%esp
  return udiv64 (n, d);
 804a25d:	8b 44 24 18          	mov    0x18(%esp),%eax
 804a261:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 804a265:	89 04 24             	mov    %eax,(%esp)
 804a268:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a26c:	8b 44 24 10          	mov    0x10(%esp),%eax
 804a270:	8b 54 24 14          	mov    0x14(%esp),%edx
 804a274:	e8 57 fd ff ff       	call   8049fd0 <udiv64>
}
 804a279:	83 c4 0c             	add    $0xc,%esp
 804a27c:	c3                   	ret    

0804a27d <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
 804a27d:	83 ec 14             	sub    $0x14,%esp
 804a280:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 804a284:	89 74 24 10          	mov    %esi,0x10(%esp)
 804a288:	8b 74 24 18          	mov    0x18(%esp),%esi
 804a28c:	8b 5c 24 20          	mov    0x20(%esp),%ebx
/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   remainder. */
static uint32_t
umod64 (uint64_t n, uint64_t d)
{
  return n - d * udiv64 (n, d);
 804a290:	89 1c 24             	mov    %ebx,(%esp)
 804a293:	8b 44 24 24          	mov    0x24(%esp),%eax
 804a297:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a29b:	89 f0                	mov    %esi,%eax
 804a29d:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 804a2a1:	e8 2a fd ff ff       	call   8049fd0 <udiv64>
 804a2a6:	0f af d8             	imul   %eax,%ebx
 804a2a9:	89 f0                	mov    %esi,%eax
 804a2ab:	29 d8                	sub    %ebx,%eax
/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
  return umod64 (n, d);
}
 804a2ad:	ba 00 00 00 00       	mov    $0x0,%edx
 804a2b2:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
 804a2b6:	8b 74 24 10          	mov    0x10(%esp),%esi
 804a2ba:	83 c4 14             	add    $0x14,%esp
 804a2bd:	c3                   	ret    
 804a2be:	90                   	nop
 804a2bf:	90                   	nop

0804a2c0 <debug_panic>:
/* Aborts the user program, printing the source file name, line
   number, and function name, plus a user-specific message. */
void
debug_panic (const char *file, int line, const char *function,
             const char *message, ...)
{
 804a2c0:	83 ec 1c             	sub    $0x1c,%esp
  va_list args;

  printf ("User process ABORT at %s:%d in %s(): ", file, line, function);
 804a2c3:	8b 44 24 28          	mov    0x28(%esp),%eax
 804a2c7:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804a2cb:	8b 44 24 24          	mov    0x24(%esp),%eax
 804a2cf:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a2d3:	8b 44 24 20          	mov    0x20(%esp),%eax
 804a2d7:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a2db:	c7 04 24 b8 ac 04 08 	movl   $0x804acb8,(%esp)
 804a2e2:	e8 89 e9 ff ff       	call   8048c70 <printf>

  va_start (args, message);
 804a2e7:	8d 44 24 30          	lea    0x30(%esp),%eax
  vprintf (message, args);
 804a2eb:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a2ef:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 804a2f3:	89 04 24             	mov    %eax,(%esp)
 804a2f6:	e8 d0 02 00 00       	call   804a5cb <vprintf>
  printf ("\n");
 804a2fb:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 804a302:	e8 e1 01 00 00       	call   804a4e8 <putchar>
  va_end (args);

  debug_backtrace ();
 804a307:	e8 e4 02 00 00       	call   804a5f0 <debug_backtrace>
  
  exit (1);
 804a30c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a313:	e8 2e 00 00 00       	call   804a346 <exit>

0804a318 <halt>:
          retval;                                               \
        })

void
halt (void) 
{
 804a318:	83 ec 1c             	sub    $0x1c,%esp
  syscall0 (SYS_HALT);
 804a31b:	6a 00                	push   $0x0
 804a31d:	cd 30                	int    $0x30
 804a31f:	83 c4 04             	add    $0x4,%esp
  NOT_REACHED ();
 804a322:	c7 44 24 0c 94 ac 04 	movl   $0x804ac94,0xc(%esp)
 804a329:	08 
 804a32a:	c7 44 24 08 b2 a8 04 	movl   $0x804a8b2,0x8(%esp)
 804a331:	08 
 804a332:	c7 44 24 04 44 00 00 	movl   $0x44,0x4(%esp)
 804a339:	00 
 804a33a:	c7 04 24 1d ab 04 08 	movl   $0x804ab1d,(%esp)
 804a341:	e8 7a ff ff ff       	call   804a2c0 <debug_panic>

0804a346 <exit>:
}

void
exit (int status)
{
 804a346:	83 ec 1c             	sub    $0x1c,%esp
  syscall1 (SYS_EXIT, status);
 804a349:	ff 74 24 20          	pushl  0x20(%esp)
 804a34d:	6a 01                	push   $0x1
 804a34f:	cd 30                	int    $0x30
 804a351:	83 c4 08             	add    $0x8,%esp
  NOT_REACHED ();
 804a354:	c7 44 24 0c 94 ac 04 	movl   $0x804ac94,0xc(%esp)
 804a35b:	08 
 804a35c:	c7 44 24 08 b7 a8 04 	movl   $0x804a8b7,0x8(%esp)
 804a363:	08 
 804a364:	c7 44 24 04 4b 00 00 	movl   $0x4b,0x4(%esp)
 804a36b:	00 
 804a36c:	c7 04 24 1d ab 04 08 	movl   $0x804ab1d,(%esp)
 804a373:	e8 48 ff ff ff       	call   804a2c0 <debug_panic>

0804a378 <exec>:
}

pid_t
exec (const char *file)
{
  return (pid_t) syscall1 (SYS_EXEC, file);
 804a378:	ff 74 24 04          	pushl  0x4(%esp)
 804a37c:	6a 02                	push   $0x2
 804a37e:	cd 30                	int    $0x30
 804a380:	83 c4 08             	add    $0x8,%esp
}
 804a383:	c3                   	ret    

0804a384 <wait>:

int
wait (pid_t pid)
{
  return syscall1 (SYS_WAIT, pid);
 804a384:	ff 74 24 04          	pushl  0x4(%esp)
 804a388:	6a 03                	push   $0x3
 804a38a:	cd 30                	int    $0x30
 804a38c:	83 c4 08             	add    $0x8,%esp
}
 804a38f:	c3                   	ret    

0804a390 <create>:

bool
create (const char *file, unsigned initial_size)
{
  return syscall2 (SYS_CREATE, file, initial_size);
 804a390:	ff 74 24 08          	pushl  0x8(%esp)
 804a394:	ff 74 24 08          	pushl  0x8(%esp)
 804a398:	6a 04                	push   $0x4
 804a39a:	cd 30                	int    $0x30
 804a39c:	83 c4 0c             	add    $0xc,%esp
 804a39f:	85 c0                	test   %eax,%eax
 804a3a1:	0f 95 c0             	setne  %al
}
 804a3a4:	c3                   	ret    

0804a3a5 <remove>:

bool
remove (const char *file)
{
  return syscall1 (SYS_REMOVE, file);
 804a3a5:	ff 74 24 04          	pushl  0x4(%esp)
 804a3a9:	6a 05                	push   $0x5
 804a3ab:	cd 30                	int    $0x30
 804a3ad:	83 c4 08             	add    $0x8,%esp
 804a3b0:	85 c0                	test   %eax,%eax
 804a3b2:	0f 95 c0             	setne  %al
}
 804a3b5:	c3                   	ret    

0804a3b6 <open>:

int
open (const char *file)
{
  return syscall1 (SYS_OPEN, file);
 804a3b6:	ff 74 24 04          	pushl  0x4(%esp)
 804a3ba:	6a 06                	push   $0x6
 804a3bc:	cd 30                	int    $0x30
 804a3be:	83 c4 08             	add    $0x8,%esp
}
 804a3c1:	c3                   	ret    

0804a3c2 <filesize>:

int
filesize (int fd) 
{
  return syscall1 (SYS_FILESIZE, fd);
 804a3c2:	ff 74 24 04          	pushl  0x4(%esp)
 804a3c6:	6a 07                	push   $0x7
 804a3c8:	cd 30                	int    $0x30
 804a3ca:	83 c4 08             	add    $0x8,%esp
}
 804a3cd:	c3                   	ret    

0804a3ce <read>:

int
read (int fd, void *buffer, unsigned size)
{
  return syscall3 (SYS_READ, fd, buffer, size);
 804a3ce:	ff 74 24 0c          	pushl  0xc(%esp)
 804a3d2:	ff 74 24 0c          	pushl  0xc(%esp)
 804a3d6:	ff 74 24 0c          	pushl  0xc(%esp)
 804a3da:	6a 08                	push   $0x8
 804a3dc:	cd 30                	int    $0x30
 804a3de:	83 c4 10             	add    $0x10,%esp
}
 804a3e1:	c3                   	ret    

0804a3e2 <write>:

int
write (int fd, const void *buffer, unsigned size)
{
  return syscall3 (SYS_WRITE, fd, buffer, size);
 804a3e2:	ff 74 24 0c          	pushl  0xc(%esp)
 804a3e6:	ff 74 24 0c          	pushl  0xc(%esp)
 804a3ea:	ff 74 24 0c          	pushl  0xc(%esp)
 804a3ee:	6a 09                	push   $0x9
 804a3f0:	cd 30                	int    $0x30
 804a3f2:	83 c4 10             	add    $0x10,%esp
}
 804a3f5:	c3                   	ret    

0804a3f6 <seek>:

void
seek (int fd, unsigned position) 
{
  syscall2 (SYS_SEEK, fd, position);
 804a3f6:	ff 74 24 08          	pushl  0x8(%esp)
 804a3fa:	ff 74 24 08          	pushl  0x8(%esp)
 804a3fe:	6a 0a                	push   $0xa
 804a400:	cd 30                	int    $0x30
 804a402:	83 c4 0c             	add    $0xc,%esp
}
 804a405:	c3                   	ret    

0804a406 <tell>:

unsigned
tell (int fd) 
{
  return syscall1 (SYS_TELL, fd);
 804a406:	ff 74 24 04          	pushl  0x4(%esp)
 804a40a:	6a 0b                	push   $0xb
 804a40c:	cd 30                	int    $0x30
 804a40e:	83 c4 08             	add    $0x8,%esp
}
 804a411:	c3                   	ret    

0804a412 <close>:

void
close (int fd)
{
  syscall1 (SYS_CLOSE, fd);
 804a412:	ff 74 24 04          	pushl  0x4(%esp)
 804a416:	6a 0c                	push   $0xc
 804a418:	cd 30                	int    $0x30
 804a41a:	83 c4 08             	add    $0x8,%esp
}
 804a41d:	c3                   	ret    

0804a41e <mmap>:

mapid_t
mmap (int fd, void *addr)
{
  return syscall2 (SYS_MMAP, fd, addr);
 804a41e:	ff 74 24 08          	pushl  0x8(%esp)
 804a422:	ff 74 24 08          	pushl  0x8(%esp)
 804a426:	6a 0d                	push   $0xd
 804a428:	cd 30                	int    $0x30
 804a42a:	83 c4 0c             	add    $0xc,%esp
}
 804a42d:	c3                   	ret    

0804a42e <munmap>:

void
munmap (mapid_t mapid)
{
  syscall1 (SYS_MUNMAP, mapid);
 804a42e:	ff 74 24 04          	pushl  0x4(%esp)
 804a432:	6a 0e                	push   $0xe
 804a434:	cd 30                	int    $0x30
 804a436:	83 c4 08             	add    $0x8,%esp
}
 804a439:	c3                   	ret    

0804a43a <chdir>:

bool
chdir (const char *dir)
{
  return syscall1 (SYS_CHDIR, dir);
 804a43a:	ff 74 24 04          	pushl  0x4(%esp)
 804a43e:	6a 0f                	push   $0xf
 804a440:	cd 30                	int    $0x30
 804a442:	83 c4 08             	add    $0x8,%esp
 804a445:	85 c0                	test   %eax,%eax
 804a447:	0f 95 c0             	setne  %al
}
 804a44a:	c3                   	ret    

0804a44b <mkdir>:

bool
mkdir (const char *dir)
{
  return syscall1 (SYS_MKDIR, dir);
 804a44b:	ff 74 24 04          	pushl  0x4(%esp)
 804a44f:	6a 10                	push   $0x10
 804a451:	cd 30                	int    $0x30
 804a453:	83 c4 08             	add    $0x8,%esp
 804a456:	85 c0                	test   %eax,%eax
 804a458:	0f 95 c0             	setne  %al
}
 804a45b:	c3                   	ret    

0804a45c <readdir>:

bool
readdir (int fd, char name[READDIR_MAX_LEN + 1]) 
{
  return syscall2 (SYS_READDIR, fd, name);
 804a45c:	ff 74 24 08          	pushl  0x8(%esp)
 804a460:	ff 74 24 08          	pushl  0x8(%esp)
 804a464:	6a 11                	push   $0x11
 804a466:	cd 30                	int    $0x30
 804a468:	83 c4 0c             	add    $0xc,%esp
 804a46b:	85 c0                	test   %eax,%eax
 804a46d:	0f 95 c0             	setne  %al
}
 804a470:	c3                   	ret    

0804a471 <isdir>:

bool
isdir (int fd) 
{
  return syscall1 (SYS_ISDIR, fd);
 804a471:	ff 74 24 04          	pushl  0x4(%esp)
 804a475:	6a 12                	push   $0x12
 804a477:	cd 30                	int    $0x30
 804a479:	83 c4 08             	add    $0x8,%esp
 804a47c:	85 c0                	test   %eax,%eax
 804a47e:	0f 95 c0             	setne  %al
}
 804a481:	c3                   	ret    

0804a482 <inumber>:

int
inumber (int fd) 
{
  return syscall1 (SYS_INUMBER, fd);
 804a482:	ff 74 24 04          	pushl  0x4(%esp)
 804a486:	6a 13                	push   $0x13
 804a488:	cd 30                	int    $0x30
 804a48a:	83 c4 08             	add    $0x8,%esp
}
 804a48d:	c3                   	ret    
 804a48e:	90                   	nop
 804a48f:	90                   	nop

0804a490 <flush>:
}

/* Flushes the buffer in AUX. */
static void
flush (struct vhprintf_aux *aux)
{
 804a490:	53                   	push   %ebx
 804a491:	83 ec 18             	sub    $0x18,%esp
 804a494:	89 c3                	mov    %eax,%ebx
  if (aux->p > aux->buf)
 804a496:	8b 40 40             	mov    0x40(%eax),%eax
 804a499:	39 d8                	cmp    %ebx,%eax
 804a49b:	76 15                	jbe    804a4b2 <flush+0x22>
    write (aux->handle, aux->buf, aux->p - aux->buf);
 804a49d:	29 d8                	sub    %ebx,%eax
 804a49f:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a4a3:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804a4a7:	8b 43 48             	mov    0x48(%ebx),%eax
 804a4aa:	89 04 24             	mov    %eax,(%esp)
 804a4ad:	e8 30 ff ff ff       	call   804a3e2 <write>
  aux->p = aux->buf;
 804a4b2:	89 5b 40             	mov    %ebx,0x40(%ebx)
}
 804a4b5:	83 c4 18             	add    $0x18,%esp
 804a4b8:	5b                   	pop    %ebx
 804a4b9:	c3                   	ret    

0804a4ba <add_char>:

/* Adds C to the buffer in AUX, flushing it if the buffer fills
   up. */
static void
add_char (char c, void *aux_) 
{
 804a4ba:	53                   	push   %ebx
 804a4bb:	83 ec 08             	sub    $0x8,%esp
 804a4be:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  struct vhprintf_aux *aux = aux_;
  *aux->p++ = c;
 804a4c2:	8b 43 40             	mov    0x40(%ebx),%eax
 804a4c5:	8b 54 24 10          	mov    0x10(%esp),%edx
 804a4c9:	88 10                	mov    %dl,(%eax)
 804a4cb:	83 c0 01             	add    $0x1,%eax
 804a4ce:	89 43 40             	mov    %eax,0x40(%ebx)
  if (aux->p >= aux->buf + sizeof aux->buf)
 804a4d1:	8d 53 40             	lea    0x40(%ebx),%edx
 804a4d4:	39 d0                	cmp    %edx,%eax
 804a4d6:	72 07                	jb     804a4df <add_char+0x25>
    flush (aux);
 804a4d8:	89 d8                	mov    %ebx,%eax
 804a4da:	e8 b1 ff ff ff       	call   804a490 <flush>
  aux->char_cnt++;
 804a4df:	83 43 44 01          	addl   $0x1,0x44(%ebx)
}
 804a4e3:	83 c4 08             	add    $0x8,%esp
 804a4e6:	5b                   	pop    %ebx
 804a4e7:	c3                   	ret    

0804a4e8 <putchar>:
}

/* Writes C to the console. */
int
putchar (int c) 
{
 804a4e8:	53                   	push   %ebx
 804a4e9:	83 ec 28             	sub    $0x28,%esp
 804a4ec:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  char c2 = c;
 804a4f0:	88 5c 24 1f          	mov    %bl,0x1f(%esp)
  write (STDOUT_FILENO, &c2, 1);
 804a4f4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 804a4fb:	00 
 804a4fc:	8d 44 24 1f          	lea    0x1f(%esp),%eax
 804a500:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a504:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a50b:	e8 d2 fe ff ff       	call   804a3e2 <write>
  return c;
}
 804a510:	89 d8                	mov    %ebx,%eax
 804a512:	83 c4 28             	add    $0x28,%esp
 804a515:	5b                   	pop    %ebx
 804a516:	c3                   	ret    

0804a517 <puts>:

/* Writes string S to the console, followed by a new-line
   character. */
int
puts (const char *s) 
{
 804a517:	57                   	push   %edi
 804a518:	83 ec 18             	sub    $0x18,%esp
 804a51b:	8b 54 24 20          	mov    0x20(%esp),%edx
  write (STDOUT_FILENO, s, strlen (s));
 804a51f:	89 d7                	mov    %edx,%edi
 804a521:	b8 00 00 00 00       	mov    $0x0,%eax
 804a526:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 804a52b:	f2 ae                	repnz scas %es:(%edi),%al
 804a52d:	f7 d1                	not    %ecx
 804a52f:	83 e9 01             	sub    $0x1,%ecx
 804a532:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804a536:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a53a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a541:	e8 9c fe ff ff       	call   804a3e2 <write>
  putchar ('\n');
 804a546:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 804a54d:	e8 96 ff ff ff       	call   804a4e8 <putchar>

  return 0;
}
 804a552:	b8 00 00 00 00       	mov    $0x0,%eax
 804a557:	83 c4 18             	add    $0x18,%esp
 804a55a:	5f                   	pop    %edi
 804a55b:	c3                   	ret    

0804a55c <vhprintf>:
/* Formats the printf() format specification FORMAT with
   arguments given in ARGS and writes the output to the given
   HANDLE. */
int
vhprintf (int handle, const char *format, va_list args) 
{
 804a55c:	53                   	push   %ebx
 804a55d:	83 ec 68             	sub    $0x68,%esp
  struct vhprintf_aux aux;
  aux.p = aux.buf;
 804a560:	8d 5c 24 14          	lea    0x14(%esp),%ebx
 804a564:	89 5c 24 54          	mov    %ebx,0x54(%esp)
  aux.char_cnt = 0;
 804a568:	c7 44 24 58 00 00 00 	movl   $0x0,0x58(%esp)
 804a56f:	00 
  aux.handle = handle;
 804a570:	8b 44 24 70          	mov    0x70(%esp),%eax
 804a574:	89 44 24 5c          	mov    %eax,0x5c(%esp)
  __vprintf (format, args, add_char, &aux);
 804a578:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 804a57c:	c7 44 24 08 ba a4 04 	movl   $0x804a4ba,0x8(%esp)
 804a583:	08 
 804a584:	8b 44 24 78          	mov    0x78(%esp),%eax
 804a588:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a58c:	8b 44 24 74          	mov    0x74(%esp),%eax
 804a590:	89 04 24             	mov    %eax,(%esp)
 804a593:	e8 1e e7 ff ff       	call   8048cb6 <__vprintf>
  flush (&aux);
 804a598:	89 d8                	mov    %ebx,%eax
 804a59a:	e8 f1 fe ff ff       	call   804a490 <flush>
  return aux.char_cnt;
}
 804a59f:	8b 44 24 58          	mov    0x58(%esp),%eax
 804a5a3:	83 c4 68             	add    $0x68,%esp
 804a5a6:	5b                   	pop    %ebx
 804a5a7:	c3                   	ret    

0804a5a8 <hprintf>:
}

/* Like printf(), but writes output to the given HANDLE. */
int
hprintf (int handle, const char *format, ...) 
{
 804a5a8:	83 ec 1c             	sub    $0x1c,%esp
  va_list args;
  int retval;

  va_start (args, format);
 804a5ab:	8d 44 24 28          	lea    0x28(%esp),%eax
  retval = vhprintf (handle, format, args);
 804a5af:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a5b3:	8b 44 24 24          	mov    0x24(%esp),%eax
 804a5b7:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a5bb:	8b 44 24 20          	mov    0x20(%esp),%eax
 804a5bf:	89 04 24             	mov    %eax,(%esp)
 804a5c2:	e8 95 ff ff ff       	call   804a55c <vhprintf>
  va_end (args);

  return retval;
}
 804a5c7:	83 c4 1c             	add    $0x1c,%esp
 804a5ca:	c3                   	ret    

0804a5cb <vprintf>:

/* The standard vprintf() function,
   which is like printf() but uses a va_list. */
int
vprintf (const char *format, va_list args) 
{
 804a5cb:	83 ec 1c             	sub    $0x1c,%esp
  return vhprintf (STDOUT_FILENO, format, args);
 804a5ce:	8b 44 24 24          	mov    0x24(%esp),%eax
 804a5d2:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a5d6:	8b 44 24 20          	mov    0x20(%esp),%eax
 804a5da:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a5de:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a5e5:	e8 72 ff ff ff       	call   804a55c <vhprintf>
}
 804a5ea:	83 c4 1c             	add    $0x1c,%esp
 804a5ed:	c3                   	ret    
 804a5ee:	90                   	nop
 804a5ef:	90                   	nop

0804a5f0 <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
 804a5f0:	55                   	push   %ebp
 804a5f1:	89 e5                	mov    %esp,%ebp
 804a5f3:	53                   	push   %ebx
 804a5f4:	83 ec 14             	sub    $0x14,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
 804a5f7:	8b 45 04             	mov    0x4(%ebp),%eax
 804a5fa:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a5fe:	c7 04 24 36 ab 04 08 	movl   $0x804ab36,(%esp)
 804a605:	e8 66 e6 ff ff       	call   8048c70 <printf>
  for (frame = __builtin_frame_address (1);
 804a60a:	8b 5d 00             	mov    0x0(%ebp),%ebx
 804a60d:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
 804a613:	76 27                	jbe    804a63c <debug_backtrace+0x4c>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
 804a615:	83 3b 00             	cmpl   $0x0,(%ebx)
 804a618:	74 22                	je     804a63c <debug_backtrace+0x4c>
       frame = frame[0]) 
    printf (" %p", frame[1]);
 804a61a:	8b 43 04             	mov    0x4(%ebx),%eax
 804a61d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a621:	c7 04 24 41 ab 04 08 	movl   $0x804ab41,(%esp)
 804a628:	e8 43 e6 ff ff       	call   8048c70 <printf>
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
 804a62d:	8b 1b                	mov    (%ebx),%ebx
{
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
 804a62f:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
 804a635:	76 05                	jbe    804a63c <debug_backtrace+0x4c>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
 804a637:	83 3b 00             	cmpl   $0x0,(%ebx)
 804a63a:	75 de                	jne    804a61a <debug_backtrace+0x2a>
       frame = frame[0]) 
    printf (" %p", frame[1]);
  printf (".\n");
 804a63c:	c7 04 24 47 aa 04 08 	movl   $0x804aa47,(%esp)
 804a643:	e8 cf fe ff ff       	call   804a517 <puts>

  if (!explained) 
 804a648:	80 3d c4 c3 04 08 00 	cmpb   $0x0,0x804c3c4
 804a64f:	75 13                	jne    804a664 <debug_backtrace+0x74>
    {
      explained = true;
 804a651:	c6 05 c4 c3 04 08 01 	movb   $0x1,0x804c3c4
      printf ("The `backtrace' program can make call stacks useful.\n"
 804a658:	c7 04 24 e0 ac 04 08 	movl   $0x804ace0,(%esp)
 804a65f:	e8 b3 fe ff ff       	call   804a517 <puts>
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
 804a664:	83 c4 14             	add    $0x14,%esp
 804a667:	5b                   	pop    %ebx
 804a668:	5d                   	pop    %ebp
 804a669:	c3                   	ret    
