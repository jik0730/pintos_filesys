
build/tests/userprog/args-none:     file format elf32-i386


Disassembly of section .text:

080480a0 <main>:

#include "tests/lib.h"

int
main (int argc, char *argv[]) 
{
 80480a0:	55                   	push   %ebp
 80480a1:	89 e5                	mov    %esp,%ebp
 80480a3:	57                   	push   %edi
 80480a4:	56                   	push   %esi
 80480a5:	53                   	push   %ebx
 80480a6:	83 e4 f0             	and    $0xfffffff0,%esp
 80480a9:	83 ec 10             	sub    $0x10,%esp
 80480ac:	8b 7d 08             	mov    0x8(%ebp),%edi
 80480af:	8b 75 0c             	mov    0xc(%ebp),%esi
  int i;

  test_name = "args";
 80480b2:	c7 05 28 c3 04 08 ec 	movl   $0x804a8ec,0x804c328
 80480b9:	a8 04 08 

  msg ("begin");
 80480bc:	c7 04 24 f1 a8 04 08 	movl   $0x804a8f1,(%esp)
 80480c3:	e8 55 01 00 00       	call   804821d <msg>
  msg ("argc = %d", argc);
 80480c8:	89 7c 24 04          	mov    %edi,0x4(%esp)
 80480cc:	c7 04 24 f7 a8 04 08 	movl   $0x804a8f7,(%esp)
 80480d3:	e8 45 01 00 00       	call   804821d <msg>
  for (i = 0; i <= argc; i++)
 80480d8:	85 ff                	test   %edi,%edi
 80480da:	78 39                	js     8048115 <main+0x75>
 80480dc:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (argv[i] != NULL)
 80480e1:	8b 04 9e             	mov    (%esi,%ebx,4),%eax
 80480e4:	85 c0                	test   %eax,%eax
 80480e6:	74 16                	je     80480fe <main+0x5e>
      msg ("argv[%d] = '%s'", i, argv[i]);
 80480e8:	89 44 24 08          	mov    %eax,0x8(%esp)
 80480ec:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 80480f0:	c7 04 24 01 a9 04 08 	movl   $0x804a901,(%esp)
 80480f7:	e8 21 01 00 00       	call   804821d <msg>
 80480fc:	eb 10                	jmp    804810e <main+0x6e>
    else
      msg ("argv[%d] = null", i);
 80480fe:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8048102:	c7 04 24 11 a9 04 08 	movl   $0x804a911,(%esp)
 8048109:	e8 0f 01 00 00       	call   804821d <msg>

  test_name = "args";

  msg ("begin");
  msg ("argc = %d", argc);
  for (i = 0; i <= argc; i++)
 804810e:	83 c3 01             	add    $0x1,%ebx
 8048111:	39 df                	cmp    %ebx,%edi
 8048113:	7d cc                	jge    80480e1 <main+0x41>
    if (argv[i] != NULL)
      msg ("argv[%d] = '%s'", i, argv[i]);
    else
      msg ("argv[%d] = null", i);
  msg ("end");
 8048115:	c7 04 24 21 a9 04 08 	movl   $0x804a921,(%esp)
 804811c:	e8 fc 00 00 00       	call   804821d <msg>

  return 0;
}
 8048121:	b8 00 00 00 00       	mov    $0x0,%eax
 8048126:	8d 65 f4             	lea    -0xc(%ebp),%esp
 8048129:	5b                   	pop    %ebx
 804812a:	5e                   	pop    %esi
 804812b:	5f                   	pop    %edi
 804812c:	5d                   	pop    %ebp
 804812d:	c3                   	ret    
 804812e:	90                   	nop
 804812f:	90                   	nop

08048130 <vmsg>:
const char *test_name;
bool quiet = false;

static void
vmsg (const char *format, va_list args, const char *suffix) 
{
 8048130:	83 ec 3c             	sub    $0x3c,%esp
 8048133:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
 8048137:	89 74 24 30          	mov    %esi,0x30(%esp)
 804813b:	89 7c 24 34          	mov    %edi,0x34(%esp)
 804813f:	89 6c 24 38          	mov    %ebp,0x38(%esp)
 8048143:	89 44 24 18          	mov    %eax,0x18(%esp)
 8048147:	89 d3                	mov    %edx,%ebx
 8048149:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
     that'll (typically) ensure that it gets sent to the console
     atomically.  Otherwise kernel messages like "foo: exit(0)"
     can end up being interleaved if we're unlucky. */
  static char buf[1024];

  snprintf (buf, sizeof buf, "(%s) ", test_name);
 804814d:	a1 28 c3 04 08       	mov    0x804c328,%eax
 8048152:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048156:	c7 44 24 08 25 a9 04 	movl   $0x804a925,0x8(%esp)
 804815d:	08 
 804815e:	c7 44 24 04 00 04 00 	movl   $0x400,0x4(%esp)
 8048165:	00 
 8048166:	c7 04 24 20 be 04 08 	movl   $0x804be20,(%esp)
 804816d:	e8 80 13 00 00       	call   80494f2 <snprintf>
  vsnprintf (buf + strlen (buf), sizeof buf - strlen (buf), format, args);
 8048172:	be ff ff ff ff       	mov    $0xffffffff,%esi
 8048177:	bf 20 be 04 08       	mov    $0x804be20,%edi
 804817c:	bd 00 00 00 00       	mov    $0x0,%ebp
 8048181:	89 f1                	mov    %esi,%ecx
 8048183:	89 e8                	mov    %ebp,%eax
 8048185:	f2 ae                	repnz scas %es:(%edi),%al
 8048187:	f7 d1                	not    %ecx
 8048189:	83 e9 01             	sub    $0x1,%ecx
 804818c:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 8048190:	8b 44 24 18          	mov    0x18(%esp),%eax
 8048194:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048198:	bb 00 04 00 00       	mov    $0x400,%ebx
 804819d:	89 d8                	mov    %ebx,%eax
 804819f:	29 c8                	sub    %ecx,%eax
 80481a1:	89 44 24 04          	mov    %eax,0x4(%esp)
 80481a5:	81 c1 20 be 04 08    	add    $0x804be20,%ecx
 80481ab:	89 0c 24             	mov    %ecx,(%esp)
 80481ae:	e8 c2 12 00 00       	call   8049475 <vsnprintf>
  strlcpy (buf + strlen (buf), suffix, sizeof buf - strlen (buf));
 80481b3:	bf 20 be 04 08       	mov    $0x804be20,%edi
 80481b8:	89 f1                	mov    %esi,%ecx
 80481ba:	89 e8                	mov    %ebp,%eax
 80481bc:	f2 ae                	repnz scas %es:(%edi),%al
 80481be:	f7 d1                	not    %ecx
 80481c0:	83 e9 01             	sub    $0x1,%ecx
 80481c3:	29 cb                	sub    %ecx,%ebx
 80481c5:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 80481c9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80481cd:	89 44 24 04          	mov    %eax,0x4(%esp)
 80481d1:	81 c1 20 be 04 08    	add    $0x804be20,%ecx
 80481d7:	89 0c 24             	mov    %ecx,(%esp)
 80481da:	e8 73 1c 00 00       	call   8049e52 <strlcpy>
  write (STDOUT_FILENO, buf, strlen (buf));
 80481df:	bf 20 be 04 08       	mov    $0x804be20,%edi
 80481e4:	89 f1                	mov    %esi,%ecx
 80481e6:	89 e8                	mov    %ebp,%eax
 80481e8:	f2 ae                	repnz scas %es:(%edi),%al
 80481ea:	89 ce                	mov    %ecx,%esi
 80481ec:	f7 d6                	not    %esi
 80481ee:	83 ee 01             	sub    $0x1,%esi
 80481f1:	89 74 24 08          	mov    %esi,0x8(%esp)
 80481f5:	c7 44 24 04 20 be 04 	movl   $0x804be20,0x4(%esp)
 80481fc:	08 
 80481fd:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8048204:	e8 09 22 00 00       	call   804a412 <write>
}
 8048209:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 804820d:	8b 74 24 30          	mov    0x30(%esp),%esi
 8048211:	8b 7c 24 34          	mov    0x34(%esp),%edi
 8048215:	8b 6c 24 38          	mov    0x38(%esp),%ebp
 8048219:	83 c4 3c             	add    $0x3c,%esp
 804821c:	c3                   	ret    

0804821d <msg>:

void
msg (const char *format, ...) 
{
 804821d:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  if (quiet)
 8048220:	80 3d 00 be 04 08 00 	cmpb   $0x0,0x804be00
 8048227:	75 12                	jne    804823b <msg+0x1e>
    return;
  va_start (args, format);
  vmsg (format, args, "\n");
 8048229:	b9 33 a9 04 08       	mov    $0x804a933,%ecx
 804822e:	8d 54 24 14          	lea    0x14(%esp),%edx
 8048232:	8b 44 24 10          	mov    0x10(%esp),%eax
 8048236:	e8 f5 fe ff ff       	call   8048130 <vmsg>
  va_end (args);
}
 804823b:	83 c4 0c             	add    $0xc,%esp
 804823e:	c3                   	ret    

0804823f <fail>:

void
fail (const char *format, ...) 
{
 804823f:	83 ec 1c             	sub    $0x1c,%esp
  va_list args;

  va_start (args, format);
  vmsg (format, args, ": FAILED\n");
 8048242:	b9 2b a9 04 08       	mov    $0x804a92b,%ecx
 8048247:	8d 54 24 24          	lea    0x24(%esp),%edx
 804824b:	8b 44 24 20          	mov    0x20(%esp),%eax
 804824f:	e8 dc fe ff ff       	call   8048130 <vmsg>
  va_end (args);

  exit (1);
 8048254:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804825b:	e8 16 21 00 00       	call   804a376 <exit>

08048260 <shuffle>:
    }
}

void
shuffle (void *buf_, size_t cnt, size_t size) 
{
 8048260:	55                   	push   %ebp
 8048261:	57                   	push   %edi
 8048262:	56                   	push   %esi
 8048263:	53                   	push   %ebx
 8048264:	83 ec 1c             	sub    $0x1c,%esp
 8048267:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  char *buf = buf_;
  size_t i;

  for (i = 0; i < cnt; i++)
 804826b:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
 8048270:	74 66                	je     80482d8 <shuffle+0x78>
 8048272:	8b 6c 24 30          	mov    0x30(%esp),%ebp
 8048276:	be 00 00 00 00       	mov    $0x0,%esi
 804827b:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
    {
      size_t j = i + random_ulong () % (cnt - i);
 804827f:	e8 03 06 00 00       	call   8048887 <random_ulong>
 8048284:	8b 4c 24 34          	mov    0x34(%esp),%ecx
 8048288:	29 f1                	sub    %esi,%ecx
 804828a:	ba 00 00 00 00       	mov    $0x0,%edx
 804828f:	f7 f1                	div    %ecx
 8048291:	01 f2                	add    %esi,%edx
      swap (buf + i * size, buf + j * size, size);
 8048293:	0f af d3             	imul   %ebx,%edx
 8048296:	03 54 24 30          	add    0x30(%esp),%edx
 804829a:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
{
  uint8_t *a = a_;
  uint8_t *b = b_;
  size_t i;

  for (i = 0; i < size; i++) 
 804829e:	85 db                	test   %ebx,%ebx
 80482a0:	74 29                	je     80482cb <shuffle+0x6b>
 80482a2:	b8 00 00 00 00       	mov    $0x0,%eax
 80482a7:	89 dd                	mov    %ebx,%ebp
    {
      uint8_t t = a[i];
 80482a9:	0f b6 1c 01          	movzbl (%ecx,%eax,1),%ebx
 80482ad:	88 5c 24 0b          	mov    %bl,0xb(%esp)
      a[i] = b[i];
 80482b1:	0f b6 3c 02          	movzbl (%edx,%eax,1),%edi
 80482b5:	89 fb                	mov    %edi,%ebx
 80482b7:	88 1c 01             	mov    %bl,(%ecx,%eax,1)
      b[i] = t;
 80482ba:	0f b6 5c 24 0b       	movzbl 0xb(%esp),%ebx
 80482bf:	88 1c 02             	mov    %bl,(%edx,%eax,1)
{
  uint8_t *a = a_;
  uint8_t *b = b_;
  size_t i;

  for (i = 0; i < size; i++) 
 80482c2:	83 c0 01             	add    $0x1,%eax
 80482c5:	39 e8                	cmp    %ebp,%eax
 80482c7:	75 e0                	jne    80482a9 <shuffle+0x49>
 80482c9:	89 eb                	mov    %ebp,%ebx
shuffle (void *buf_, size_t cnt, size_t size) 
{
  char *buf = buf_;
  size_t i;

  for (i = 0; i < cnt; i++)
 80482cb:	83 c6 01             	add    $0x1,%esi
 80482ce:	01 5c 24 0c          	add    %ebx,0xc(%esp)
 80482d2:	3b 74 24 34          	cmp    0x34(%esp),%esi
 80482d6:	75 a7                	jne    804827f <shuffle+0x1f>
    {
      size_t j = i + random_ulong () % (cnt - i);
      swap (buf + i * size, buf + j * size, size);
    }
}
 80482d8:	83 c4 1c             	add    $0x1c,%esp
 80482db:	5b                   	pop    %ebx
 80482dc:	5e                   	pop    %esi
 80482dd:	5f                   	pop    %edi
 80482de:	5d                   	pop    %ebp
 80482df:	c3                   	ret    

080482e0 <exec_children>:

void
exec_children (const char *child_name, pid_t pids[], size_t child_cnt) 
{
 80482e0:	55                   	push   %ebp
 80482e1:	57                   	push   %edi
 80482e2:	56                   	push   %esi
 80482e3:	53                   	push   %ebx
 80482e4:	81 ec ac 00 00 00    	sub    $0xac,%esp
 80482ea:	8b ac 24 c4 00 00 00 	mov    0xc4(%esp),%ebp
 80482f1:	8b bc 24 c8 00 00 00 	mov    0xc8(%esp),%edi
  size_t i;

  for (i = 0; i < child_cnt; i++) 
 80482f8:	85 ff                	test   %edi,%edi
 80482fa:	74 7c                	je     8048378 <exec_children+0x98>
 80482fc:	bb 00 00 00 00       	mov    $0x0,%ebx
    {
      char cmd_line[128];
      snprintf (cmd_line, sizeof cmd_line, "%s %zu", child_name, i);
 8048301:	8d 74 24 20          	lea    0x20(%esp),%esi
 8048305:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 8048309:	8b 84 24 c0 00 00 00 	mov    0xc0(%esp),%eax
 8048310:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048314:	c7 44 24 08 35 a9 04 	movl   $0x804a935,0x8(%esp)
 804831b:	08 
 804831c:	c7 44 24 04 80 00 00 	movl   $0x80,0x4(%esp)
 8048323:	00 
 8048324:	89 34 24             	mov    %esi,(%esp)
 8048327:	e8 c6 11 00 00       	call   80494f2 <snprintf>
      CHECK ((pids[i] = exec (cmd_line)) != PID_ERROR,
 804832c:	83 c3 01             	add    $0x1,%ebx
 804832f:	89 74 24 0c          	mov    %esi,0xc(%esp)
 8048333:	89 7c 24 08          	mov    %edi,0x8(%esp)
 8048337:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804833b:	c7 04 24 3c a9 04 08 	movl   $0x804a93c,(%esp)
 8048342:	e8 d6 fe ff ff       	call   804821d <msg>
 8048347:	89 34 24             	mov    %esi,(%esp)
 804834a:	e8 59 20 00 00       	call   804a3a8 <exec>
 804834f:	89 44 9d fc          	mov    %eax,-0x4(%ebp,%ebx,4)
 8048353:	83 f8 ff             	cmp    $0xffffffff,%eax
 8048356:	75 1c                	jne    8048374 <exec_children+0x94>
 8048358:	8d 44 24 20          	lea    0x20(%esp),%eax
 804835c:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048360:	89 7c 24 08          	mov    %edi,0x8(%esp)
 8048364:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8048368:	c7 04 24 3c a9 04 08 	movl   $0x804a93c,(%esp)
 804836f:	e8 cb fe ff ff       	call   804823f <fail>
void
exec_children (const char *child_name, pid_t pids[], size_t child_cnt) 
{
  size_t i;

  for (i = 0; i < child_cnt; i++) 
 8048374:	39 fb                	cmp    %edi,%ebx
 8048376:	75 8d                	jne    8048305 <exec_children+0x25>
      char cmd_line[128];
      snprintf (cmd_line, sizeof cmd_line, "%s %zu", child_name, i);
      CHECK ((pids[i] = exec (cmd_line)) != PID_ERROR,
             "exec child %zu of %zu: \"%s\"", i + 1, child_cnt, cmd_line);
    }
}
 8048378:	81 c4 ac 00 00 00    	add    $0xac,%esp
 804837e:	5b                   	pop    %ebx
 804837f:	5e                   	pop    %esi
 8048380:	5f                   	pop    %edi
 8048381:	5d                   	pop    %ebp
 8048382:	c3                   	ret    

08048383 <wait_children>:

void
wait_children (pid_t pids[], size_t child_cnt) 
{
 8048383:	55                   	push   %ebp
 8048384:	57                   	push   %edi
 8048385:	56                   	push   %esi
 8048386:	53                   	push   %ebx
 8048387:	83 ec 2c             	sub    $0x2c,%esp
 804838a:	8b 6c 24 40          	mov    0x40(%esp),%ebp
  size_t i;
  
  for (i = 0; i < child_cnt; i++) 
 804838e:	bb 00 00 00 00       	mov    $0x0,%ebx
 8048393:	83 7c 24 44 00       	cmpl   $0x0,0x44(%esp)
 8048398:	75 04                	jne    804839e <wait_children+0x1b>
 804839a:	eb 5d                	jmp    80483f9 <wait_children+0x76>
    {
      int status = wait (pids[i]);
      CHECK (status == (int) i,
 804839c:	89 f3                	mov    %esi,%ebx
{
  size_t i;
  
  for (i = 0; i < child_cnt; i++) 
    {
      int status = wait (pids[i]);
 804839e:	8b 44 9d 00          	mov    0x0(%ebp,%ebx,4),%eax
 80483a2:	89 04 24             	mov    %eax,(%esp)
 80483a5:	e8 0a 20 00 00       	call   804a3b4 <wait>
 80483aa:	89 c7                	mov    %eax,%edi
      CHECK (status == (int) i,
 80483ac:	8d 73 01             	lea    0x1(%ebx),%esi
 80483af:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 80483b3:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80483b7:	8b 44 24 44          	mov    0x44(%esp),%eax
 80483bb:	89 44 24 08          	mov    %eax,0x8(%esp)
 80483bf:	89 74 24 04          	mov    %esi,0x4(%esp)
 80483c3:	c7 04 24 9c ab 04 08 	movl   $0x804ab9c,(%esp)
 80483ca:	e8 4e fe ff ff       	call   804821d <msg>
 80483cf:	39 df                	cmp    %ebx,%edi
 80483d1:	74 20                	je     80483f3 <wait_children+0x70>
 80483d3:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 80483d7:	89 7c 24 0c          	mov    %edi,0xc(%esp)
 80483db:	8b 44 24 44          	mov    0x44(%esp),%eax
 80483df:	89 44 24 08          	mov    %eax,0x8(%esp)
 80483e3:	89 74 24 04          	mov    %esi,0x4(%esp)
 80483e7:	c7 04 24 9c ab 04 08 	movl   $0x804ab9c,(%esp)
 80483ee:	e8 4c fe ff ff       	call   804823f <fail>
void
wait_children (pid_t pids[], size_t child_cnt) 
{
  size_t i;
  
  for (i = 0; i < child_cnt; i++) 
 80483f3:	3b 74 24 44          	cmp    0x44(%esp),%esi
 80483f7:	75 a3                	jne    804839c <wait_children+0x19>
      int status = wait (pids[i]);
      CHECK (status == (int) i,
             "wait for child %zu of %zu returned %d (expected %zu)",
             i + 1, child_cnt, status, i);
    }
}
 80483f9:	83 c4 2c             	add    $0x2c,%esp
 80483fc:	5b                   	pop    %ebx
 80483fd:	5e                   	pop    %esi
 80483fe:	5f                   	pop    %edi
 80483ff:	5d                   	pop    %ebp
 8048400:	c3                   	ret    

08048401 <compare_bytes>:
}

void
compare_bytes (const void *read_data_, const void *expected_data_, size_t size,
               size_t ofs, const char *file_name) 
{
 8048401:	83 ec 3c             	sub    $0x3c,%esp
 8048404:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
 8048408:	89 74 24 30          	mov    %esi,0x30(%esp)
 804840c:	89 7c 24 34          	mov    %edi,0x34(%esp)
 8048410:	89 6c 24 38          	mov    %ebp,0x38(%esp)
 8048414:	8b 74 24 40          	mov    0x40(%esp),%esi
 8048418:	8b 5c 24 44          	mov    0x44(%esp),%ebx
 804841c:	8b 7c 24 48          	mov    0x48(%esp),%edi
  const uint8_t *read_data = read_data_;
  const uint8_t *expected_data = expected_data_;
  size_t i, j;
  size_t show_cnt;

  if (!memcmp (read_data, expected_data, size))
 8048420:	89 7c 24 08          	mov    %edi,0x8(%esp)
 8048424:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8048428:	89 34 24             	mov    %esi,(%esp)
 804842b:	e8 77 14 00 00       	call   80498a7 <memcmp>
 8048430:	85 c0                	test   %eax,%eax
 8048432:	0f 84 5c 01 00 00    	je     8048594 <compare_bytes+0x193>
    return;
  
  for (i = 0; i < size; i++)
 8048438:	85 ff                	test   %edi,%edi
 804843a:	0f 84 12 01 00 00    	je     8048552 <compare_bytes+0x151>
    if (read_data[i] != expected_data[i])
 8048440:	bd 00 00 00 00       	mov    $0x0,%ebp
 8048445:	0f b6 03             	movzbl (%ebx),%eax
 8048448:	38 06                	cmp    %al,(%esi)
 804844a:	74 0b                	je     8048457 <compare_bytes+0x56>
 804844c:	eb 10                	jmp    804845e <compare_bytes+0x5d>
 804844e:	0f b6 14 2b          	movzbl (%ebx,%ebp,1),%edx
 8048452:	38 14 2e             	cmp    %dl,(%esi,%ebp,1)
 8048455:	75 07                	jne    804845e <compare_bytes+0x5d>
  size_t show_cnt;

  if (!memcmp (read_data, expected_data, size))
    return;
  
  for (i = 0; i < size; i++)
 8048457:	83 c5 01             	add    $0x1,%ebp
 804845a:	39 fd                	cmp    %edi,%ebp
 804845c:	75 f0                	jne    804844e <compare_bytes+0x4d>
    if (read_data[i] != expected_data[i])
      break;
  for (j = i + 1; j < size; j++)
 804845e:	8d 45 01             	lea    0x1(%ebp),%eax
 8048461:	39 c7                	cmp    %eax,%edi
 8048463:	76 1d                	jbe    8048482 <compare_bytes+0x81>
    if (read_data[j] == expected_data[j])
 8048465:	0f b6 54 2b 01       	movzbl 0x1(%ebx,%ebp,1),%edx
 804846a:	38 54 2e 01          	cmp    %dl,0x1(%esi,%ebp,1)
 804846e:	75 0b                	jne    804847b <compare_bytes+0x7a>
 8048470:	eb 10                	jmp    8048482 <compare_bytes+0x81>
 8048472:	0f b6 14 03          	movzbl (%ebx,%eax,1),%edx
 8048476:	38 14 06             	cmp    %dl,(%esi,%eax,1)
 8048479:	74 07                	je     8048482 <compare_bytes+0x81>
    return;
  
  for (i = 0; i < size; i++)
    if (read_data[i] != expected_data[i])
      break;
  for (j = i + 1; j < size; j++)
 804847b:	83 c0 01             	add    $0x1,%eax
 804847e:	39 c7                	cmp    %eax,%edi
 8048480:	77 f0                	ja     8048472 <compare_bytes+0x71>
    if (read_data[j] == expected_data[j])
      break;

  quiet = false;
 8048482:	c6 05 00 be 04 08 00 	movb   $0x0,0x804be00
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
 8048489:	01 6c 24 4c          	add    %ebp,0x4c(%esp)
 804848d:	89 c7                	mov    %eax,%edi
 804848f:	29 ef                	sub    %ebp,%edi
 8048491:	8b 44 24 50          	mov    0x50(%esp),%eax
 8048495:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048499:	8b 54 24 4c          	mov    0x4c(%esp),%edx
 804849d:	89 54 24 08          	mov    %edx,0x8(%esp)
 80484a1:	89 7c 24 04          	mov    %edi,0x4(%esp)
 80484a5:	c7 04 24 d4 ab 04 08 	movl   $0x804abd4,(%esp)
 80484ac:	e8 6c fd ff ff       	call   804821d <msg>
 80484b1:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
       "from expected.", j - i, ofs + i, file_name);
  show_cnt = j - i;
  if (j - i > 64) 
 80484b5:	83 ff 40             	cmp    $0x40,%edi
 80484b8:	76 1c                	jbe    80484d6 <compare_bytes+0xd5>
    {
      show_cnt = 64;
      msg ("Showing first differing %zu bytes.", show_cnt);
 80484ba:	c7 44 24 04 40 00 00 	movl   $0x40,0x4(%esp)
 80484c1:	00 
 80484c2:	c7 04 24 18 ac 04 08 	movl   $0x804ac18,(%esp)
 80484c9:	e8 4f fd ff ff       	call   804821d <msg>
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
       "from expected.", j - i, ofs + i, file_name);
  show_cnt = j - i;
  if (j - i > 64) 
    {
      show_cnt = 64;
 80484ce:	c7 44 24 1c 40 00 00 	movl   $0x40,0x1c(%esp)
 80484d5:	00 
      msg ("Showing first differing %zu bytes.", show_cnt);
    }
  msg ("Data actually read:");
 80484d6:	c7 04 24 58 a9 04 08 	movl   $0x804a958,(%esp)
 80484dd:	e8 3b fd ff ff       	call   804821d <msg>
  hex_dump (ofs + i, read_data + i, show_cnt, true);
 80484e2:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 80484e9:	00 
 80484ea:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80484ee:	89 44 24 08          	mov    %eax,0x8(%esp)
 80484f2:	01 ee                	add    %ebp,%esi
 80484f4:	89 74 24 04          	mov    %esi,0x4(%esp)
 80484f8:	8b 54 24 4c          	mov    0x4c(%esp),%edx
 80484fc:	89 14 24             	mov    %edx,(%esp)
 80484ff:	e8 19 10 00 00       	call   804951d <hex_dump>
  msg ("Expected data:");
 8048504:	c7 04 24 6c a9 04 08 	movl   $0x804a96c,(%esp)
 804850b:	e8 0d fd ff ff       	call   804821d <msg>
  hex_dump (ofs + i, expected_data + i, show_cnt, true);
 8048510:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 8048517:	00 
 8048518:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804851c:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048520:	01 eb                	add    %ebp,%ebx
 8048522:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8048526:	8b 54 24 4c          	mov    0x4c(%esp),%edx
 804852a:	89 14 24             	mov    %edx,(%esp)
 804852d:	e8 eb 0f 00 00       	call   804951d <hex_dump>
  fail ("%zu bytes read starting at offset %zu in \"%s\" differ "
 8048532:	8b 44 24 50          	mov    0x50(%esp),%eax
 8048536:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804853a:	8b 54 24 4c          	mov    0x4c(%esp),%edx
 804853e:	89 54 24 08          	mov    %edx,0x8(%esp)
 8048542:	89 7c 24 04          	mov    %edi,0x4(%esp)
 8048546:	c7 04 24 3c ac 04 08 	movl   $0x804ac3c,(%esp)
 804854d:	e8 ed fc ff ff       	call   804823f <fail>
      break;
  for (j = i + 1; j < size; j++)
    if (read_data[j] == expected_data[j])
      break;

  quiet = false;
 8048552:	c6 05 00 be 04 08 00 	movb   $0x0,0x804be00
  msg ("%zu bytes read starting at offset %zu in \"%s\" differ "
 8048559:	8b 44 24 50          	mov    0x50(%esp),%eax
 804855d:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048561:	8b 54 24 4c          	mov    0x4c(%esp),%edx
 8048565:	89 54 24 08          	mov    %edx,0x8(%esp)
 8048569:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 8048570:	00 
 8048571:	c7 04 24 d4 ab 04 08 	movl   $0x804abd4,(%esp)
 8048578:	e8 a0 fc ff ff       	call   804821d <msg>
 804857d:	bd 00 00 00 00       	mov    $0x0,%ebp
 8048582:	bf 01 00 00 00       	mov    $0x1,%edi
 8048587:	c7 44 24 1c 01 00 00 	movl   $0x1,0x1c(%esp)
 804858e:	00 
 804858f:	e9 42 ff ff ff       	jmp    80484d6 <compare_bytes+0xd5>
  hex_dump (ofs + i, read_data + i, show_cnt, true);
  msg ("Expected data:");
  hex_dump (ofs + i, expected_data + i, show_cnt, true);
  fail ("%zu bytes read starting at offset %zu in \"%s\" differ "
        "from expected", j - i, ofs + i, file_name);
}
 8048594:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8048598:	8b 74 24 30          	mov    0x30(%esp),%esi
 804859c:	8b 7c 24 34          	mov    0x34(%esp),%edi
 80485a0:	8b 6c 24 38          	mov    0x38(%esp),%ebp
 80485a4:	83 c4 3c             	add    $0x3c,%esp
 80485a7:	c3                   	ret    

080485a8 <check_file_handle>:
}

void
check_file_handle (int fd,
                   const char *file_name, const void *buf_, size_t size) 
{
 80485a8:	55                   	push   %ebp
 80485a9:	57                   	push   %edi
 80485aa:	56                   	push   %esi
 80485ab:	53                   	push   %ebx
 80485ac:	81 ec 3c 02 00 00    	sub    $0x23c,%esp
 80485b2:	8b ac 24 5c 02 00 00 	mov    0x25c(%esp),%ebp
  size_t file_size;

  /* Warn about file of wrong size.  Don't fail yet because we
     may still be able to get more information by reading the
     file. */
  file_size = filesize (fd);
 80485b9:	8b 84 24 50 02 00 00 	mov    0x250(%esp),%eax
 80485c0:	89 04 24             	mov    %eax,(%esp)
 80485c3:	e8 2a 1e 00 00       	call   804a3f2 <filesize>
 80485c8:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  if (file_size != size)
 80485cc:	39 e8                	cmp    %ebp,%eax
 80485ce:	74 1f                	je     80485ef <check_file_handle+0x47>
    msg ("size of %s (%zu) differs from expected (%zu)",
 80485d0:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
 80485d4:	89 44 24 08          	mov    %eax,0x8(%esp)
 80485d8:	8b 84 24 54 02 00 00 	mov    0x254(%esp),%eax
 80485df:	89 44 24 04          	mov    %eax,0x4(%esp)
 80485e3:	c7 04 24 80 ac 04 08 	movl   $0x804ac80,(%esp)
 80485ea:	e8 2e fc ff ff       	call   804821d <msg>
          file_name, file_size, size);

  /* Read the file block-by-block, comparing data as we go. */
  while (ofs < size)
 80485ef:	85 ed                	test   %ebp,%ebp
 80485f1:	0f 84 87 00 00 00    	je     804867e <check_file_handle+0xd6>
 80485f7:	bb 00 00 00 00       	mov    $0x0,%ebx

      block_size = size - ofs;
      if (block_size > sizeof block)
        block_size = sizeof block;

      ret_val = read (fd, block, block_size);
 80485fc:	8d 7c 24 30          	lea    0x30(%esp),%edi
  while (ofs < size)
    {
      char block[512];
      size_t block_size, ret_val;

      block_size = size - ofs;
 8048600:	89 ee                	mov    %ebp,%esi
 8048602:	29 de                	sub    %ebx,%esi
 8048604:	81 fe 00 02 00 00    	cmp    $0x200,%esi
 804860a:	b8 00 02 00 00       	mov    $0x200,%eax
 804860f:	0f 47 f0             	cmova  %eax,%esi
      if (block_size > sizeof block)
        block_size = sizeof block;

      ret_val = read (fd, block, block_size);
 8048612:	89 74 24 08          	mov    %esi,0x8(%esp)
 8048616:	89 7c 24 04          	mov    %edi,0x4(%esp)
 804861a:	8b 84 24 50 02 00 00 	mov    0x250(%esp),%eax
 8048621:	89 04 24             	mov    %eax,(%esp)
 8048624:	e8 d5 1d 00 00       	call   804a3fe <read>
      if (ret_val != block_size)
 8048629:	39 c6                	cmp    %eax,%esi
 804862b:	74 23                	je     8048650 <check_file_handle+0xa8>
        fail ("read of %zu bytes at offset %zu in \"%s\" returned %zu",
 804862d:	89 44 24 10          	mov    %eax,0x10(%esp)
 8048631:	8b 84 24 54 02 00 00 	mov    0x254(%esp),%eax
 8048638:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804863c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 8048640:	89 74 24 04          	mov    %esi,0x4(%esp)
 8048644:	c7 04 24 b0 ac 04 08 	movl   $0x804acb0,(%esp)
 804864b:	e8 ef fb ff ff       	call   804823f <fail>
              block_size, ofs, file_name, ret_val);

      compare_bytes (block, buf + ofs, block_size, ofs, file_name);
 8048650:	8b 84 24 54 02 00 00 	mov    0x254(%esp),%eax
 8048657:	89 44 24 10          	mov    %eax,0x10(%esp)
 804865b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 804865f:	89 74 24 08          	mov    %esi,0x8(%esp)
 8048663:	8b 84 24 58 02 00 00 	mov    0x258(%esp),%eax
 804866a:	01 d8                	add    %ebx,%eax
 804866c:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048670:	89 3c 24             	mov    %edi,(%esp)
 8048673:	e8 89 fd ff ff       	call   8048401 <compare_bytes>
      ofs += block_size;
 8048678:	01 f3                	add    %esi,%ebx
  if (file_size != size)
    msg ("size of %s (%zu) differs from expected (%zu)",
          file_name, file_size, size);

  /* Read the file block-by-block, comparing data as we go. */
  while (ofs < size)
 804867a:	39 dd                	cmp    %ebx,%ebp
 804867c:	77 82                	ja     8048600 <check_file_handle+0x58>
      compare_bytes (block, buf + ofs, block_size, ofs, file_name);
      ofs += block_size;
    }

  /* Now fail due to wrong file size. */
  if (file_size != size)
 804867e:	39 6c 24 2c          	cmp    %ebp,0x2c(%esp)
 8048682:	74 23                	je     80486a7 <check_file_handle+0xff>
    fail ("size of %s (%zu) differs from expected (%zu)",
 8048684:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
 8048688:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 804868c:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048690:	8b 84 24 54 02 00 00 	mov    0x254(%esp),%eax
 8048697:	89 44 24 04          	mov    %eax,0x4(%esp)
 804869b:	c7 04 24 80 ac 04 08 	movl   $0x804ac80,(%esp)
 80486a2:	e8 98 fb ff ff       	call   804823f <fail>
          file_name, file_size, size);

  msg ("verified contents of \"%s\"", file_name);
 80486a7:	8b 84 24 54 02 00 00 	mov    0x254(%esp),%eax
 80486ae:	89 44 24 04          	mov    %eax,0x4(%esp)
 80486b2:	c7 04 24 7b a9 04 08 	movl   $0x804a97b,(%esp)
 80486b9:	e8 5f fb ff ff       	call   804821d <msg>
}
 80486be:	81 c4 3c 02 00 00    	add    $0x23c,%esp
 80486c4:	5b                   	pop    %ebx
 80486c5:	5e                   	pop    %esi
 80486c6:	5f                   	pop    %edi
 80486c7:	5d                   	pop    %ebp
 80486c8:	c3                   	ret    

080486c9 <check_file>:

void
check_file (const char *file_name, const void *buf, size_t size) 
{
 80486c9:	56                   	push   %esi
 80486ca:	53                   	push   %ebx
 80486cb:	83 ec 14             	sub    $0x14,%esp
 80486ce:	8b 5c 24 20          	mov    0x20(%esp),%ebx
  int fd;

  CHECK ((fd = open (file_name)) > 1, "open \"%s\" for verification",
 80486d2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 80486d6:	c7 04 24 95 a9 04 08 	movl   $0x804a995,(%esp)
 80486dd:	e8 3b fb ff ff       	call   804821d <msg>
 80486e2:	89 1c 24             	mov    %ebx,(%esp)
 80486e5:	e8 fc 1c 00 00       	call   804a3e6 <open>
 80486ea:	89 c6                	mov    %eax,%esi
 80486ec:	83 f8 01             	cmp    $0x1,%eax
 80486ef:	7f 10                	jg     8048701 <check_file+0x38>
 80486f1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 80486f5:	c7 04 24 95 a9 04 08 	movl   $0x804a995,(%esp)
 80486fc:	e8 3e fb ff ff       	call   804823f <fail>
         file_name);
  check_file_handle (fd, file_name, buf, size);
 8048701:	8b 44 24 28          	mov    0x28(%esp),%eax
 8048705:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8048709:	8b 44 24 24          	mov    0x24(%esp),%eax
 804870d:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048711:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8048715:	89 34 24             	mov    %esi,(%esp)
 8048718:	e8 8b fe ff ff       	call   80485a8 <check_file_handle>
  msg ("close \"%s\"", file_name);
 804871d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8048721:	c7 04 24 b0 a9 04 08 	movl   $0x804a9b0,(%esp)
 8048728:	e8 f0 fa ff ff       	call   804821d <msg>
  close (fd);
 804872d:	89 34 24             	mov    %esi,(%esp)
 8048730:	e8 0d 1d 00 00       	call   804a442 <close>
}
 8048735:	83 c4 14             	add    $0x14,%esp
 8048738:	5b                   	pop    %ebx
 8048739:	5e                   	pop    %esi
 804873a:	c3                   	ret    
 804873b:	90                   	nop

0804873c <_start>:
int main (int, char *[]);
void _start (int argc, char *argv[]);

void
_start (int argc, char *argv[]) 
{
 804873c:	83 ec 1c             	sub    $0x1c,%esp
  exit (main (argc, argv));
 804873f:	8b 44 24 24          	mov    0x24(%esp),%eax
 8048743:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048747:	8b 44 24 20          	mov    0x20(%esp),%eax
 804874b:	89 04 24             	mov    %eax,(%esp)
 804874e:	e8 4d f9 ff ff       	call   80480a0 <main>
 8048753:	89 04 24             	mov    %eax,(%esp)
 8048756:	e8 1b 1c 00 00       	call   804a376 <exit>
 804875b:	90                   	nop

0804875c <random_init>:
}

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
 804875c:	56                   	push   %esi
 804875d:	53                   	push   %ebx
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
 804875e:	b8 00 00 00 00       	mov    $0x0,%eax
    s[i] = i;
 8048763:	88 80 20 c2 04 08    	mov    %al,0x804c220(%eax)
{
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
 8048769:	83 c0 01             	add    $0x1,%eax
 804876c:	3d 00 01 00 00       	cmp    $0x100,%eax
 8048771:	75 f0                	jne    8048763 <random_init+0x7>
 8048773:	be 00 00 00 00       	mov    $0x0,%esi
 8048778:	66 b8 00 00          	mov    $0x0,%ax
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
    {
      j += s[i] + seedp[i % sizeof seed];
 804877c:	89 c1                	mov    %eax,%ecx
 804877e:	83 e1 03             	and    $0x3,%ecx
 8048781:	0f b6 98 20 c2 04 08 	movzbl 0x804c220(%eax),%ebx
 8048788:	0f b6 4c 0c 0c       	movzbl 0xc(%esp,%ecx,1),%ecx
 804878d:	01 d9                	add    %ebx,%ecx
 804878f:	01 ce                	add    %ecx,%esi
      swap_byte (s + i, s + j);
 8048791:	89 f2                	mov    %esi,%edx
 8048793:	0f b6 ca             	movzbl %dl,%ecx
/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
  uint8_t t = *a;
  *a = *b;
 8048796:	0f b6 91 20 c2 04 08 	movzbl 0x804c220(%ecx),%edx
 804879d:	88 90 20 c2 04 08    	mov    %dl,0x804c220(%eax)
  *b = t;
 80487a3:	88 99 20 c2 04 08    	mov    %bl,0x804c220(%ecx)
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
 80487a9:	83 c0 01             	add    $0x1,%eax
 80487ac:	3d 00 01 00 00       	cmp    $0x100,%eax
 80487b1:	75 c9                	jne    804877c <random_init+0x20>
    {
      j += s[i] + seedp[i % sizeof seed];
      swap_byte (s + i, s + j);
    }

  s_i = s_j = 0;
 80487b3:	c6 05 20 c3 04 08 00 	movb   $0x0,0x804c320
 80487ba:	c6 05 21 c3 04 08 00 	movb   $0x0,0x804c321
  inited = true;
 80487c1:	c6 05 22 c3 04 08 01 	movb   $0x1,0x804c322
}
 80487c8:	5b                   	pop    %ebx
 80487c9:	5e                   	pop    %esi
 80487ca:	c3                   	ret    

080487cb <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
 80487cb:	55                   	push   %ebp
 80487cc:	57                   	push   %edi
 80487cd:	56                   	push   %esi
 80487ce:	53                   	push   %ebx
 80487cf:	83 ec 10             	sub    $0x10,%esp
 80487d2:	8b 5c 24 28          	mov    0x28(%esp),%ebx
  uint8_t *buf;

  if (!inited)
 80487d6:	80 3d 22 c3 04 08 00 	cmpb   $0x0,0x804c322
 80487dd:	75 0c                	jne    80487eb <random_bytes+0x20>
    random_init (0);
 80487df:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80487e6:	e8 71 ff ff ff       	call   804875c <random_init>

  for (buf = buf_; size-- > 0; buf++)
 80487eb:	85 db                	test   %ebx,%ebx
 80487ed:	0f 84 8c 00 00 00    	je     804887f <random_bytes+0xb4>
 80487f3:	8d 43 ff             	lea    -0x1(%ebx),%eax
 80487f6:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80487fa:	0f b6 0d 21 c3 04 08 	movzbl 0x804c321,%ecx
 8048801:	88 4c 24 0b          	mov    %cl,0xb(%esp)
 8048805:	0f b6 15 20 c3 04 08 	movzbl 0x804c320,%edx
 804880c:	89 ce                	mov    %ecx,%esi
 804880e:	8b 4c 24 24          	mov    0x24(%esp),%ecx
 8048812:	89 c8                	mov    %ecx,%eax
 8048814:	89 f1                	mov    %esi,%ecx
 8048816:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804881a:	89 c6                	mov    %eax,%esi
    {
      uint8_t s_k;
      
      s_i++;
 804881c:	83 c1 01             	add    $0x1,%ecx
      s_j += s[s_i];
 804881f:	0f b6 c1             	movzbl %cl,%eax
 8048822:	02 90 20 c2 04 08    	add    0x804c220(%eax),%dl
      swap_byte (s + s_i, s + s_j);
 8048828:	0f b6 ea             	movzbl %dl,%ebp

/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
  uint8_t t = *a;
 804882b:	0f b6 b8 20 c2 04 08 	movzbl 0x804c220(%eax),%edi
  *a = *b;
 8048832:	0f b6 9d 20 c2 04 08 	movzbl 0x804c220(%ebp),%ebx
 8048839:	88 98 20 c2 04 08    	mov    %bl,0x804c220(%eax)
  *b = t;
 804883f:	89 fb                	mov    %edi,%ebx
 8048841:	88 9d 20 c2 04 08    	mov    %bl,0x804c220(%ebp)
      
      s_i++;
      s_j += s[s_i];
      swap_byte (s + s_i, s + s_j);

      s_k = s[s_i] + s[s_j];
 8048847:	0f b6 80 20 c2 04 08 	movzbl 0x804c220(%eax),%eax
 804884e:	01 f8                	add    %edi,%eax
      *buf = s[s_k];
 8048850:	0f b6 f8             	movzbl %al,%edi
 8048853:	0f b6 87 20 c2 04 08 	movzbl 0x804c220(%edi),%eax
 804885a:	88 06                	mov    %al,(%esi)
  uint8_t *buf;

  if (!inited)
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
 804885c:	83 c6 01             	add    $0x1,%esi
 804885f:	83 6c 24 04 01       	subl   $0x1,0x4(%esp)
 8048864:	75 b6                	jne    804881c <random_bytes+0x51>
  inited = true;
}

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
 8048866:	0f b6 4c 24 0b       	movzbl 0xb(%esp),%ecx
 804886b:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
 8048870:	8d 44 19 01          	lea    0x1(%ecx,%ebx,1),%eax
 8048874:	a2 21 c3 04 08       	mov    %al,0x804c321
 8048879:	88 15 20 c3 04 08    	mov    %dl,0x804c320
      swap_byte (s + s_i, s + s_j);

      s_k = s[s_i] + s[s_j];
      *buf = s[s_k];
    }
}
 804887f:	83 c4 10             	add    $0x10,%esp
 8048882:	5b                   	pop    %ebx
 8048883:	5e                   	pop    %esi
 8048884:	5f                   	pop    %edi
 8048885:	5d                   	pop    %ebp
 8048886:	c3                   	ret    

08048887 <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
 8048887:	83 ec 18             	sub    $0x18,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
 804888a:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
 8048891:	00 
 8048892:	8d 44 24 14          	lea    0x14(%esp),%eax
 8048896:	89 04 24             	mov    %eax,(%esp)
 8048899:	e8 2d ff ff ff       	call   80487cb <random_bytes>
  return ul;
}
 804889e:	8b 44 24 14          	mov    0x14(%esp),%eax
 80488a2:	83 c4 18             	add    $0x18,%esp
 80488a5:	c3                   	ret    
 80488a6:	90                   	nop
 80488a7:	90                   	nop
 80488a8:	90                   	nop
 80488a9:	90                   	nop
 80488aa:	90                   	nop
 80488ab:	90                   	nop
 80488ac:	90                   	nop
 80488ad:	90                   	nop
 80488ae:	90                   	nop
 80488af:	90                   	nop

080488b0 <vsnprintf_helper>:
}

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
 80488b0:	83 ec 08             	sub    $0x8,%esp
 80488b3:	89 1c 24             	mov    %ebx,(%esp)
 80488b6:	89 74 24 04          	mov    %esi,0x4(%esp)
 80488ba:	8b 44 24 10          	mov    0x10(%esp),%eax
 80488be:	0f b6 74 24 0c       	movzbl 0xc(%esp),%esi
  struct vsnprintf_aux *aux = aux_;

  if (aux->length++ < aux->max_length)
 80488c3:	8b 50 04             	mov    0x4(%eax),%edx
 80488c6:	8b 48 08             	mov    0x8(%eax),%ecx
 80488c9:	8d 5a 01             	lea    0x1(%edx),%ebx
 80488cc:	89 58 04             	mov    %ebx,0x4(%eax)
 80488cf:	39 ca                	cmp    %ecx,%edx
 80488d1:	7d 0b                	jge    80488de <vsnprintf_helper+0x2e>
    *aux->p++ = ch;
 80488d3:	8b 10                	mov    (%eax),%edx
 80488d5:	89 f1                	mov    %esi,%ecx
 80488d7:	88 0a                	mov    %cl,(%edx)
 80488d9:	83 c2 01             	add    $0x1,%edx
 80488dc:	89 10                	mov    %edx,(%eax)
}
 80488de:	8b 1c 24             	mov    (%esp),%ebx
 80488e1:	8b 74 24 04          	mov    0x4(%esp),%esi
 80488e5:	83 c4 08             	add    $0x8,%esp
 80488e8:	c3                   	ret    

080488e9 <output_dup>:
}

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
 80488e9:	83 ec 2c             	sub    $0x2c,%esp
 80488ec:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
 80488f0:	89 74 24 20          	mov    %esi,0x20(%esp)
 80488f4:	89 7c 24 24          	mov    %edi,0x24(%esp)
 80488f8:	89 6c 24 28          	mov    %ebp,0x28(%esp)
 80488fc:	89 d3                	mov    %edx,%ebx
 80488fe:	89 cd                	mov    %ecx,%ebp
 8048900:	8b 7c 24 30          	mov    0x30(%esp),%edi
  while (cnt-- > 0)
 8048904:	85 d2                	test   %edx,%edx
 8048906:	74 11                	je     8048919 <output_dup+0x30>
    output (ch, aux);
 8048908:	0f be f0             	movsbl %al,%esi
 804890b:	89 7c 24 04          	mov    %edi,0x4(%esp)
 804890f:	89 34 24             	mov    %esi,(%esp)
 8048912:	ff d5                	call   *%ebp

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
  while (cnt-- > 0)
 8048914:	83 eb 01             	sub    $0x1,%ebx
 8048917:	75 f2                	jne    804890b <output_dup+0x22>
    output (ch, aux);
}
 8048919:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
 804891d:	8b 74 24 20          	mov    0x20(%esp),%esi
 8048921:	8b 7c 24 24          	mov    0x24(%esp),%edi
 8048925:	8b 6c 24 28          	mov    0x28(%esp),%ebp
 8048929:	83 c4 2c             	add    $0x2c,%esp
 804892c:	c3                   	ret    

0804892d <format_integer>:
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
                const struct integer_base *b,
                const struct printf_conversion *c,
                void (*output) (char, void *), void *aux)
{
 804892d:	55                   	push   %ebp
 804892e:	57                   	push   %edi
 804892f:	56                   	push   %esi
 8048930:	53                   	push   %ebx
 8048931:	83 ec 7c             	sub    $0x7c,%esp
 8048934:	89 c7                	mov    %eax,%edi
 8048936:	89 d6                	mov    %edx,%esi
 8048938:	0f b6 94 24 90 00 00 	movzbl 0x90(%esp),%edx
 804893f:	00 
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
 8048940:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
 8048947:	00 
  if (is_signed) 
 8048948:	85 c9                	test   %ecx,%ecx
 804894a:	74 41                	je     804898d <format_integer+0x60>
    {
      if (c->flags & PLUS)
 804894c:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
 8048953:	8b 01                	mov    (%ecx),%eax
 8048955:	a8 02                	test   $0x2,%al
 8048957:	74 11                	je     804896a <format_integer+0x3d>
        sign = negative ? '-' : '+';
 8048959:	80 fa 01             	cmp    $0x1,%dl
 804895c:	19 c0                	sbb    %eax,%eax
 804895e:	83 e0 fe             	and    $0xfffffffe,%eax
 8048961:	83 c0 2d             	add    $0x2d,%eax
 8048964:	89 44 24 28          	mov    %eax,0x28(%esp)
 8048968:	eb 23                	jmp    804898d <format_integer+0x60>
      else if (c->flags & SPACE)
 804896a:	a8 04                	test   $0x4,%al
 804896c:	74 11                	je     804897f <format_integer+0x52>
        sign = negative ? '-' : ' ';
 804896e:	80 fa 01             	cmp    $0x1,%dl
 8048971:	19 d2                	sbb    %edx,%edx
 8048973:	83 e2 f3             	and    $0xfffffff3,%edx
 8048976:	83 c2 2d             	add    $0x2d,%edx
 8048979:	89 54 24 28          	mov    %edx,0x28(%esp)
 804897d:	eb 0e                	jmp    804898d <format_integer+0x60>
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
 804897f:	80 fa 01             	cmp    $0x1,%dl
 8048982:	19 c9                	sbb    %ecx,%ecx
 8048984:	f7 d1                	not    %ecx
 8048986:	83 e1 2d             	and    $0x2d,%ecx
 8048989:	89 4c 24 28          	mov    %ecx,0x28(%esp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
 804898d:	89 f8                	mov    %edi,%eax
 804898f:	09 f0                	or     %esi,%eax
 8048991:	0f 95 c0             	setne  %al
 8048994:	8b 94 24 98 00 00 00 	mov    0x98(%esp),%edx
 804899b:	f6 02 08             	testb  $0x8,(%edx)
 804899e:	74 14                	je     80489b4 <format_integer+0x87>
 80489a0:	84 c0                	test   %al,%al
 80489a2:	74 10                	je     80489b4 <format_integer+0x87>
 80489a4:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
 80489ab:	8b 49 08             	mov    0x8(%ecx),%ecx
 80489ae:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
 80489b2:	eb 08                	jmp    80489bc <format_integer+0x8f>
 80489b4:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
 80489bb:	00 

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
 80489bc:	8d 5c 24 30          	lea    0x30(%esp),%ebx
  digit_cnt = 0;
  while (value > 0) 
 80489c0:	84 c0                	test   %al,%al
 80489c2:	0f 84 ba 00 00 00    	je     8048a82 <format_integer+0x155>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
        *cp++ = ',';
      *cp++ = b->digits[value % b->base];
 80489c8:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
 80489cf:	8b 40 04             	mov    0x4(%eax),%eax
 80489d2:	89 44 24 24          	mov    %eax,0x24(%esp)
 80489d6:	8b 94 24 94 00 00 00 	mov    0x94(%esp),%edx
 80489dd:	8b 02                	mov    (%edx),%eax
 80489df:	89 44 24 18          	mov    %eax,0x18(%esp)
 80489e3:	89 c1                	mov    %eax,%ecx
 80489e5:	c1 f9 1f             	sar    $0x1f,%ecx
 80489e8:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
 80489ec:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
 80489f3:	00 
  x = (c->flags & POUND) && value ? b->x : 0;

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
 80489f4:	89 dd                	mov    %ebx,%ebp
 80489f6:	eb 38                	jmp    8048a30 <format_integer+0x103>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
        *cp++ = ',';
      *cp++ = b->digits[value % b->base];
      value /= b->base;
      digit_cnt++;
 80489f8:	83 44 24 20 01       	addl   $0x1,0x20(%esp)
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
 80489fd:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
 8048a04:	f6 00 20             	testb  $0x20,(%eax)
 8048a07:	74 25                	je     8048a2e <format_integer+0x101>
 8048a09:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
 8048a0e:	7e 1e                	jle    8048a2e <format_integer+0x101>
 8048a10:	8b 44 24 20          	mov    0x20(%esp),%eax
 8048a14:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
 8048a1b:	89 c2                	mov    %eax,%edx
 8048a1d:	c1 fa 1f             	sar    $0x1f,%edx
 8048a20:	f7 79 0c             	idivl  0xc(%ecx)
 8048a23:	85 d2                	test   %edx,%edx
 8048a25:	75 07                	jne    8048a2e <format_integer+0x101>
        *cp++ = ',';
 8048a27:	c6 45 01 2c          	movb   $0x2c,0x1(%ebp)
 8048a2b:	8d 5d 02             	lea    0x2(%ebp),%ebx
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
 8048a2e:	89 dd                	mov    %ebx,%ebp
  digit_cnt = 0;
  while (value > 0) 
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
        *cp++ = ',';
      *cp++ = b->digits[value % b->base];
 8048a30:	8b 44 24 18          	mov    0x18(%esp),%eax
 8048a34:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 8048a38:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048a3c:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8048a40:	89 3c 24             	mov    %edi,(%esp)
 8048a43:	89 74 24 04          	mov    %esi,0x4(%esp)
 8048a47:	e8 61 18 00 00       	call   804a2ad <__umoddi3>
 8048a4c:	8b 54 24 24          	mov    0x24(%esp),%edx
 8048a50:	0f b6 04 02          	movzbl (%edx,%eax,1),%eax
 8048a54:	88 45 00             	mov    %al,0x0(%ebp)
 8048a57:	8d 5d 01             	lea    0x1(%ebp),%ebx
      value /= b->base;
 8048a5a:	8b 44 24 18          	mov    0x18(%esp),%eax
 8048a5e:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 8048a62:	89 44 24 08          	mov    %eax,0x8(%esp)
 8048a66:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8048a6a:	89 3c 24             	mov    %edi,(%esp)
 8048a6d:	89 74 24 04          	mov    %esi,0x4(%esp)
 8048a71:	e8 14 18 00 00       	call   804a28a <__udivdi3>
 8048a76:	89 c7                	mov    %eax,%edi
 8048a78:	89 d6                	mov    %edx,%esi
  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
 8048a7a:	09 fa                	or     %edi,%edx
 8048a7c:	0f 85 76 ff ff ff    	jne    80489f8 <format_integer+0xcb>
  /* Append enough zeros to match precision.
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
 8048a82:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
 8048a89:	8b 51 08             	mov    0x8(%ecx),%edx
 8048a8c:	85 d2                	test   %edx,%edx
 8048a8e:	b8 01 00 00 00       	mov    $0x1,%eax
 8048a93:	0f 48 d0             	cmovs  %eax,%edx
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
 8048a96:	8d 7c 24 30          	lea    0x30(%esp),%edi
 8048a9a:	89 d8                	mov    %ebx,%eax
 8048a9c:	29 f8                	sub    %edi,%eax
 8048a9e:	39 c2                	cmp    %eax,%edx
 8048aa0:	7e 1e                	jle    8048ac0 <format_integer+0x193>
 8048aa2:	8d 44 24 6f          	lea    0x6f(%esp),%eax
 8048aa6:	39 c3                	cmp    %eax,%ebx
 8048aa8:	73 16                	jae    8048ac0 <format_integer+0x193>
   NEGATIVE indicating a negative value; otherwise does an
   unsigned conversion and ignores NEGATIVE.  The output is done
   according to the provided base B.  Details of the conversion
   are in C. */
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
 8048aaa:	89 f9                	mov    %edi,%ecx
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
 8048aac:	89 c6                	mov    %eax,%esi
    *cp++ = '0';
 8048aae:	c6 03 30             	movb   $0x30,(%ebx)
 8048ab1:	83 c3 01             	add    $0x1,%ebx
   NEGATIVE indicating a negative value; otherwise does an
   unsigned conversion and ignores NEGATIVE.  The output is done
   according to the provided base B.  Details of the conversion
   are in C. */
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
 8048ab4:	89 d8                	mov    %ebx,%eax
 8048ab6:	29 c8                	sub    %ecx,%eax
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
 8048ab8:	39 d0                	cmp    %edx,%eax
 8048aba:	7d 04                	jge    8048ac0 <format_integer+0x193>
 8048abc:	39 f3                	cmp    %esi,%ebx
 8048abe:	72 ee                	jb     8048aae <format_integer+0x181>
    *cp++ = '0';
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
 8048ac0:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
 8048ac7:	f6 00 08             	testb  $0x8,(%eax)
 8048aca:	74 20                	je     8048aec <format_integer+0x1bf>
 8048acc:	8b 94 24 94 00 00 00 	mov    0x94(%esp),%edx
 8048ad3:	83 3a 08             	cmpl   $0x8,(%edx)
 8048ad6:	75 14                	jne    8048aec <format_integer+0x1bf>
 8048ad8:	8d 44 24 30          	lea    0x30(%esp),%eax
 8048adc:	39 c3                	cmp    %eax,%ebx
 8048ade:	74 06                	je     8048ae6 <format_integer+0x1b9>
 8048ae0:	80 7b ff 30          	cmpb   $0x30,-0x1(%ebx)
 8048ae4:	74 06                	je     8048aec <format_integer+0x1bf>
    *cp++ = '0';
 8048ae6:	c6 03 30             	movb   $0x30,(%ebx)
 8048ae9:	83 c3 01             	add    $0x1,%ebx

  /* Calculate number of pad characters to fill field width. */
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
 8048aec:	29 df                	sub    %ebx,%edi
 8048aee:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
 8048af5:	03 79 04             	add    0x4(%ecx),%edi
 8048af8:	83 7c 24 2c 01       	cmpl   $0x1,0x2c(%esp)
 8048afd:	19 c0                	sbb    %eax,%eax
 8048aff:	f7 d0                	not    %eax
 8048b01:	83 e0 02             	and    $0x2,%eax
 8048b04:	29 c7                	sub    %eax,%edi
 8048b06:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
 8048b0b:	0f 95 c0             	setne  %al
 8048b0e:	0f b6 c0             	movzbl %al,%eax
 8048b11:	29 c7                	sub    %eax,%edi
 8048b13:	b8 00 00 00 00       	mov    $0x0,%eax
 8048b18:	0f 48 f8             	cmovs  %eax,%edi
  if (pad_cnt < 0)
    pad_cnt = 0;

  /* Do output. */
  if ((c->flags & (MINUS | ZERO)) == 0)
 8048b1b:	f6 01 11             	testb  $0x11,(%ecx)
 8048b1e:	75 1d                	jne    8048b3d <format_integer+0x210>
    output_dup (' ', pad_cnt, output, aux);
 8048b20:	8b 84 24 a0 00 00 00 	mov    0xa0(%esp),%eax
 8048b27:	89 04 24             	mov    %eax,(%esp)
 8048b2a:	8b 8c 24 9c 00 00 00 	mov    0x9c(%esp),%ecx
 8048b31:	89 fa                	mov    %edi,%edx
 8048b33:	b8 20 00 00 00       	mov    $0x20,%eax
 8048b38:	e8 ac fd ff ff       	call   80488e9 <output_dup>
  if (sign)
 8048b3d:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
 8048b42:	74 19                	je     8048b5d <format_integer+0x230>
    output (sign, aux);
 8048b44:	8b 94 24 a0 00 00 00 	mov    0xa0(%esp),%edx
 8048b4b:	89 54 24 04          	mov    %edx,0x4(%esp)
 8048b4f:	8b 4c 24 28          	mov    0x28(%esp),%ecx
 8048b53:	89 0c 24             	mov    %ecx,(%esp)
 8048b56:	ff 94 24 9c 00 00 00 	call   *0x9c(%esp)
  if (x) 
 8048b5d:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
 8048b62:	74 33                	je     8048b97 <format_integer+0x26a>
    {
      output ('0', aux);
 8048b64:	8b 84 24 a0 00 00 00 	mov    0xa0(%esp),%eax
 8048b6b:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048b6f:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
 8048b76:	ff 94 24 9c 00 00 00 	call   *0x9c(%esp)
      output (x, aux); 
 8048b7d:	8b 94 24 a0 00 00 00 	mov    0xa0(%esp),%edx
 8048b84:	89 54 24 04          	mov    %edx,0x4(%esp)
 8048b88:	0f be 44 24 2c       	movsbl 0x2c(%esp),%eax
 8048b8d:	89 04 24             	mov    %eax,(%esp)
 8048b90:	ff 94 24 9c 00 00 00 	call   *0x9c(%esp)
    }
  if (c->flags & ZERO)
 8048b97:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
 8048b9e:	f6 01 10             	testb  $0x10,(%ecx)
 8048ba1:	74 1d                	je     8048bc0 <format_integer+0x293>
    output_dup ('0', pad_cnt, output, aux);
 8048ba3:	8b 84 24 a0 00 00 00 	mov    0xa0(%esp),%eax
 8048baa:	89 04 24             	mov    %eax,(%esp)
 8048bad:	8b 8c 24 9c 00 00 00 	mov    0x9c(%esp),%ecx
 8048bb4:	89 fa                	mov    %edi,%edx
 8048bb6:	b8 30 00 00 00       	mov    $0x30,%eax
 8048bbb:	e8 29 fd ff ff       	call   80488e9 <output_dup>
  while (cp > buf)
 8048bc0:	8d 44 24 30          	lea    0x30(%esp),%eax
 8048bc4:	39 c3                	cmp    %eax,%ebx
 8048bc6:	76 2b                	jbe    8048bf3 <format_integer+0x2c6>
 8048bc8:	89 c6                	mov    %eax,%esi
 8048bca:	89 7c 24 20          	mov    %edi,0x20(%esp)
 8048bce:	8b ac 24 9c 00 00 00 	mov    0x9c(%esp),%ebp
 8048bd5:	8b bc 24 a0 00 00 00 	mov    0xa0(%esp),%edi
    output (*--cp, aux);
 8048bdc:	83 eb 01             	sub    $0x1,%ebx
 8048bdf:	89 7c 24 04          	mov    %edi,0x4(%esp)
 8048be3:	0f be 03             	movsbl (%ebx),%eax
 8048be6:	89 04 24             	mov    %eax,(%esp)
 8048be9:	ff d5                	call   *%ebp
      output ('0', aux);
      output (x, aux); 
    }
  if (c->flags & ZERO)
    output_dup ('0', pad_cnt, output, aux);
  while (cp > buf)
 8048beb:	39 f3                	cmp    %esi,%ebx
 8048bed:	75 ed                	jne    8048bdc <format_integer+0x2af>
 8048bef:	8b 7c 24 20          	mov    0x20(%esp),%edi
    output (*--cp, aux);
  if (c->flags & MINUS)
 8048bf3:	8b 94 24 98 00 00 00 	mov    0x98(%esp),%edx
 8048bfa:	f6 02 01             	testb  $0x1,(%edx)
 8048bfd:	74 1d                	je     8048c1c <format_integer+0x2ef>
    output_dup (' ', pad_cnt, output, aux);
 8048bff:	8b 8c 24 a0 00 00 00 	mov    0xa0(%esp),%ecx
 8048c06:	89 0c 24             	mov    %ecx,(%esp)
 8048c09:	8b 8c 24 9c 00 00 00 	mov    0x9c(%esp),%ecx
 8048c10:	89 fa                	mov    %edi,%edx
 8048c12:	b8 20 00 00 00       	mov    $0x20,%eax
 8048c17:	e8 cd fc ff ff       	call   80488e9 <output_dup>
}
 8048c1c:	83 c4 7c             	add    $0x7c,%esp
 8048c1f:	5b                   	pop    %ebx
 8048c20:	5e                   	pop    %esi
 8048c21:	5f                   	pop    %edi
 8048c22:	5d                   	pop    %ebp
 8048c23:	c3                   	ret    

08048c24 <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
 8048c24:	55                   	push   %ebp
 8048c25:	57                   	push   %edi
 8048c26:	56                   	push   %esi
 8048c27:	53                   	push   %ebx
 8048c28:	83 ec 2c             	sub    $0x2c,%esp
 8048c2b:	89 c7                	mov    %eax,%edi
 8048c2d:	89 d6                	mov    %edx,%esi
 8048c2f:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 8048c33:	8b 6c 24 44          	mov    0x44(%esp),%ebp
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
 8048c37:	8b 51 04             	mov    0x4(%ecx),%edx
 8048c3a:	39 f2                	cmp    %esi,%edx
 8048c3c:	7e 18                	jle    8048c56 <format_string+0x32>
 8048c3e:	f6 01 01             	testb  $0x1,(%ecx)
 8048c41:	75 13                	jne    8048c56 <format_string+0x32>
    output_dup (' ', c->width - length, output, aux);
 8048c43:	29 f2                	sub    %esi,%edx
 8048c45:	89 2c 24             	mov    %ebp,(%esp)
 8048c48:	8b 4c 24 40          	mov    0x40(%esp),%ecx
 8048c4c:	b8 20 00 00 00       	mov    $0x20,%eax
 8048c51:	e8 93 fc ff ff       	call   80488e9 <output_dup>
  for (i = 0; i < length; i++)
 8048c56:	85 f6                	test   %esi,%esi
 8048c58:	7e 1b                	jle    8048c75 <format_string+0x51>
 8048c5a:	bb 00 00 00 00       	mov    $0x0,%ebx
    output (string[i], aux);
 8048c5f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
 8048c63:	0f be 04 1f          	movsbl (%edi,%ebx,1),%eax
 8048c67:	89 04 24             	mov    %eax,(%esp)
 8048c6a:	ff 54 24 40          	call   *0x40(%esp)
               void (*output) (char, void *), void *aux) 
{
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
 8048c6e:	83 c3 01             	add    $0x1,%ebx
 8048c71:	39 f3                	cmp    %esi,%ebx
 8048c73:	75 ea                	jne    8048c5f <format_string+0x3b>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
 8048c75:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8048c79:	8b 50 04             	mov    0x4(%eax),%edx
 8048c7c:	39 d6                	cmp    %edx,%esi
 8048c7e:	7d 18                	jge    8048c98 <format_string+0x74>
 8048c80:	f6 00 01             	testb  $0x1,(%eax)
 8048c83:	74 13                	je     8048c98 <format_string+0x74>
    output_dup (' ', c->width - length, output, aux);
 8048c85:	29 f2                	sub    %esi,%edx
 8048c87:	89 2c 24             	mov    %ebp,(%esp)
 8048c8a:	8b 4c 24 40          	mov    0x40(%esp),%ecx
 8048c8e:	b8 20 00 00 00       	mov    $0x20,%eax
 8048c93:	e8 51 fc ff ff       	call   80488e9 <output_dup>
}
 8048c98:	83 c4 2c             	add    $0x2c,%esp
 8048c9b:	5b                   	pop    %ebx
 8048c9c:	5e                   	pop    %esi
 8048c9d:	5f                   	pop    %edi
 8048c9e:	5d                   	pop    %ebp
 8048c9f:	c3                   	ret    

08048ca0 <printf>:
   In the kernel, the console is both the video display and first
   serial port.
   In userspace, the console is file descriptor 1. */
int
printf (const char *format, ...) 
{
 8048ca0:	83 ec 1c             	sub    $0x1c,%esp
  va_list args;
  int retval;

  va_start (args, format);
 8048ca3:	8d 44 24 24          	lea    0x24(%esp),%eax
  retval = vprintf (format, args);
 8048ca7:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048cab:	8b 44 24 20          	mov    0x20(%esp),%eax
 8048caf:	89 04 24             	mov    %eax,(%esp)
 8048cb2:	e8 44 19 00 00       	call   804a5fb <vprintf>
  va_end (args);

  return retval;
}
 8048cb7:	83 c4 1c             	add    $0x1c,%esp
 8048cba:	c3                   	ret    

08048cbb <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
 8048cbb:	83 ec 1c             	sub    $0x1c,%esp
  va_list args;

  va_start (args, aux);
 8048cbe:	8d 44 24 2c          	lea    0x2c(%esp),%eax
  __vprintf (format, args, output, aux);
 8048cc2:	8b 54 24 28          	mov    0x28(%esp),%edx
 8048cc6:	89 54 24 0c          	mov    %edx,0xc(%esp)
 8048cca:	8b 54 24 24          	mov    0x24(%esp),%edx
 8048cce:	89 54 24 08          	mov    %edx,0x8(%esp)
 8048cd2:	89 44 24 04          	mov    %eax,0x4(%esp)
 8048cd6:	8b 44 24 20          	mov    0x20(%esp),%eax
 8048cda:	89 04 24             	mov    %eax,(%esp)
 8048cdd:	e8 04 00 00 00       	call   8048ce6 <__vprintf>
  va_end (args);
}
 8048ce2:	83 c4 1c             	add    $0x1c,%esp
 8048ce5:	c3                   	ret    

08048ce6 <__vprintf>:
                           void (*output) (char, void *), void *aux);

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
 8048ce6:	55                   	push   %ebp
 8048ce7:	57                   	push   %edi
 8048ce8:	56                   	push   %esi
 8048ce9:	53                   	push   %ebx
 8048cea:	83 ec 6c             	sub    $0x6c,%esp
 8048ced:	8b ac 24 80 00 00 00 	mov    0x80(%esp),%ebp
  for (; *format != '\0'; format++)
 8048cf4:	0f b6 45 00          	movzbl 0x0(%ebp),%eax
 8048cf8:	84 c0                	test   %al,%al
 8048cfa:	0f 84 6d 07 00 00    	je     804946d <__vprintf+0x787>
    {
      struct printf_conversion c;

      /* Literally copy non-conversions to output. */
      if (*format != '%') 
 8048d00:	3c 25                	cmp    $0x25,%al
 8048d02:	74 21                	je     8048d25 <__vprintf+0x3f>
        {
          output (*format, aux);
 8048d04:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 8048d0b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8048d0f:	0f be c0             	movsbl %al,%eax
 8048d12:	89 04 24             	mov    %eax,(%esp)
 8048d15:	ff 94 24 88 00 00 00 	call   *0x88(%esp)
          continue;
 8048d1c:	89 6c 24 2c          	mov    %ebp,0x2c(%esp)
 8048d20:	e9 25 07 00 00       	jmp    804944a <__vprintf+0x764>
        }
      format++;
 8048d25:	8d 5d 01             	lea    0x1(%ebp),%ebx
 8048d28:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)

      /* %% => %. */
      if (*format == '%') 
 8048d2c:	b9 00 00 00 00       	mov    $0x0,%ecx
 8048d31:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8048d35:	80 7d 01 25          	cmpb   $0x25,0x1(%ebp)
 8048d39:	75 20                	jne    8048d5b <__vprintf+0x75>
        {
          output ('%', aux);
 8048d3b:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 8048d42:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8048d46:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
 8048d4d:	ff 94 24 88 00 00 00 	call   *0x88(%esp)
          continue;
 8048d54:	e9 f1 06 00 00       	jmp    804944a <__vprintf+0x764>
{
  /* Parse flag characters. */
  c->flags = 0;
  for (;;) 
    {
      switch (*format++) 
 8048d59:	89 eb                	mov    %ebp,%ebx
 8048d5b:	0f b6 13             	movzbl (%ebx),%edx
 8048d5e:	8d 6b 01             	lea    0x1(%ebx),%ebp
 8048d61:	8d 42 e0             	lea    -0x20(%edx),%eax
 8048d64:	3c 10                	cmp    $0x10,%al
 8048d66:	77 2a                	ja     8048d92 <__vprintf+0xac>
 8048d68:	0f b6 c0             	movzbl %al,%eax
 8048d6b:	ff 24 85 9c a6 04 08 	jmp    *0x804a69c(,%eax,4)
        {
        case '-':
          c->flags |= MINUS;
 8048d72:	83 c9 01             	or     $0x1,%ecx
 8048d75:	eb e2                	jmp    8048d59 <__vprintf+0x73>
          break;
        case '+':
          c->flags |= PLUS;
 8048d77:	83 c9 02             	or     $0x2,%ecx
 8048d7a:	eb dd                	jmp    8048d59 <__vprintf+0x73>
          break;
        case ' ':
          c->flags |= SPACE;
 8048d7c:	83 c9 04             	or     $0x4,%ecx
 8048d7f:	90                   	nop
 8048d80:	eb d7                	jmp    8048d59 <__vprintf+0x73>
          break;
        case '#':
          c->flags |= POUND;
 8048d82:	83 c9 08             	or     $0x8,%ecx
 8048d85:	eb d2                	jmp    8048d59 <__vprintf+0x73>
          break;
        case '0':
          c->flags |= ZERO;
 8048d87:	83 c9 10             	or     $0x10,%ecx
 8048d8a:	eb cd                	jmp    8048d59 <__vprintf+0x73>
          break;
        case '\'':
          c->flags |= GROUP;
 8048d8c:	83 c9 20             	or     $0x20,%ecx
 8048d8f:	90                   	nop
 8048d90:	eb c7                	jmp    8048d59 <__vprintf+0x73>
 8048d92:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
 8048d96:	89 4c 24 4c          	mov    %ecx,0x4c(%esp)
          format--;
          goto not_a_flag;
        }
    }
 not_a_flag:
  if (c->flags & MINUS)
 8048d9a:	f6 c1 01             	test   $0x1,%cl
 8048d9d:	74 07                	je     8048da6 <__vprintf+0xc0>
    c->flags &= ~ZERO;
 8048d9f:	83 e1 ef             	and    $0xffffffef,%ecx
 8048da2:	89 4c 24 4c          	mov    %ecx,0x4c(%esp)
  if (c->flags & PLUS)
 8048da6:	8b 44 24 4c          	mov    0x4c(%esp),%eax
 8048daa:	a8 02                	test   $0x2,%al
 8048dac:	74 07                	je     8048db5 <__vprintf+0xcf>
    c->flags &= ~SPACE;
 8048dae:	83 e0 fb             	and    $0xfffffffb,%eax
 8048db1:	89 44 24 4c          	mov    %eax,0x4c(%esp)

  /* Parse field width. */
  c->width = 0;
 8048db5:	c7 44 24 50 00 00 00 	movl   $0x0,0x50(%esp)
 8048dbc:	00 
  if (*format == '*')
 8048dbd:	80 fa 2a             	cmp    $0x2a,%dl
 8048dc0:	74 16                	je     8048dd8 <__vprintf+0xf2>
      format++;
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
 8048dc2:	0f be 13             	movsbl (%ebx),%edx
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
static inline int isalpha (int c) { return islower (c) || isupper (c); }
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
 8048dc5:	8d 4a d0             	lea    -0x30(%edx),%ecx
 8048dc8:	b8 00 00 00 00       	mov    $0x0,%eax
 8048dcd:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8048dd1:	83 f9 09             	cmp    $0x9,%ecx
 8048dd4:	76 1f                	jbe    8048df5 <__vprintf+0x10f>
 8048dd6:	eb 4d                	jmp    8048e25 <__vprintf+0x13f>
  /* Parse field width. */
  c->width = 0;
  if (*format == '*')
    {
      format++;
      c->width = va_arg (*args, int);
 8048dd8:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048ddf:	8b 03                	mov    (%ebx),%eax
 8048de1:	89 44 24 50          	mov    %eax,0x50(%esp)
 8048de5:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8048de8:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
{
  /* Parse flag characters. */
  c->flags = 0;
  for (;;) 
    {
      switch (*format++) 
 8048def:	89 6c 24 2c          	mov    %ebp,0x2c(%esp)
 8048df3:	eb 1d                	jmp    8048e12 <__vprintf+0x12c>
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
        c->width = c->width * 10 + *format - '0';
 8048df5:	8d 04 80             	lea    (%eax,%eax,4),%eax
 8048df8:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
      format++;
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
 8048dfc:	83 c3 01             	add    $0x1,%ebx
 8048dff:	0f be 13             	movsbl (%ebx),%edx
 8048e02:	8d 4a d0             	lea    -0x30(%edx),%ecx
 8048e05:	83 f9 09             	cmp    $0x9,%ecx
 8048e08:	76 eb                	jbe    8048df5 <__vprintf+0x10f>
 8048e0a:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
 8048e0e:	89 44 24 50          	mov    %eax,0x50(%esp)
        c->width = c->width * 10 + *format - '0';
    }
  if (c->width < 0) 
 8048e12:	8b 44 24 50          	mov    0x50(%esp),%eax
 8048e16:	85 c0                	test   %eax,%eax
 8048e18:	79 0b                	jns    8048e25 <__vprintf+0x13f>
    {
      c->width = -c->width;
 8048e1a:	f7 d8                	neg    %eax
 8048e1c:	89 44 24 50          	mov    %eax,0x50(%esp)
      c->flags |= MINUS;
 8048e20:	83 4c 24 4c 01       	orl    $0x1,0x4c(%esp)
    }
      
  /* Parse precision. */
  c->precision = -1;
 8048e25:	c7 44 24 54 ff ff ff 	movl   $0xffffffff,0x54(%esp)
 8048e2c:	ff 
  if (*format == '.') 
 8048e2d:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8048e31:	80 3b 2e             	cmpb   $0x2e,(%ebx)
 8048e34:	75 7c                	jne    8048eb2 <__vprintf+0x1cc>
    {
      format++;
      if (*format == '*') 
 8048e36:	80 7b 01 2a          	cmpb   $0x2a,0x1(%ebx)
 8048e3a:	75 1e                	jne    8048e5a <__vprintf+0x174>
        {
          format++;
 8048e3c:	89 da                	mov    %ebx,%edx
 8048e3e:	83 c2 02             	add    $0x2,%edx
          c->precision = va_arg (*args, int);
 8048e41:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048e48:	8b 03                	mov    (%ebx),%eax
 8048e4a:	89 44 24 54          	mov    %eax,0x54(%esp)
 8048e4e:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8048e51:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
 8048e58:	eb 41                	jmp    8048e9b <__vprintf+0x1b5>
      
  /* Parse precision. */
  c->precision = -1;
  if (*format == '.') 
    {
      format++;
 8048e5a:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 8048e5e:	83 c2 01             	add    $0x1,%edx
          format++;
          c->precision = va_arg (*args, int);
        }
      else 
        {
          c->precision = 0;
 8048e61:	c7 44 24 54 00 00 00 	movl   $0x0,0x54(%esp)
 8048e68:	00 
          for (; isdigit (*format); format++)
 8048e69:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8048e6d:	0f be 4b 01          	movsbl 0x1(%ebx),%ecx
 8048e71:	8d 41 d0             	lea    -0x30(%ecx),%eax
 8048e74:	83 f8 09             	cmp    $0x9,%eax
 8048e77:	0f 87 e6 05 00 00    	ja     8049463 <__vprintf+0x77d>
 8048e7d:	b8 00 00 00 00       	mov    $0x0,%eax
            c->precision = c->precision * 10 + *format - '0';
 8048e82:	8d 04 80             	lea    (%eax,%eax,4),%eax
 8048e85:	8d 44 41 d0          	lea    -0x30(%ecx,%eax,2),%eax
          c->precision = va_arg (*args, int);
        }
      else 
        {
          c->precision = 0;
          for (; isdigit (*format); format++)
 8048e89:	83 c2 01             	add    $0x1,%edx
 8048e8c:	0f be 0a             	movsbl (%edx),%ecx
 8048e8f:	8d 59 d0             	lea    -0x30(%ecx),%ebx
 8048e92:	83 fb 09             	cmp    $0x9,%ebx
 8048e95:	76 eb                	jbe    8048e82 <__vprintf+0x19c>
 8048e97:	89 44 24 54          	mov    %eax,0x54(%esp)
            c->precision = c->precision * 10 + *format - '0';
        }
      if (c->precision < 0) 
 8048e9b:	83 7c 24 54 00       	cmpl   $0x0,0x54(%esp)
 8048ea0:	0f 89 bd 05 00 00    	jns    8049463 <__vprintf+0x77d>
        c->precision = -1;
 8048ea6:	c7 44 24 54 ff ff ff 	movl   $0xffffffff,0x54(%esp)
 8048ead:	ff 
 8048eae:	89 54 24 2c          	mov    %edx,0x2c(%esp)
 8048eb2:	8b 54 24 2c          	mov    0x2c(%esp),%edx
    }
  if (c->precision >= 0)
    c->flags &= ~ZERO;

  /* Parse type. */
  c->type = INT;
 8048eb6:	c7 44 24 58 03 00 00 	movl   $0x3,0x58(%esp)
 8048ebd:	00 
  switch (*format++) 
 8048ebe:	8d 5a 01             	lea    0x1(%edx),%ebx
 8048ec1:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
 8048ec5:	0f b6 02             	movzbl (%edx),%eax
 8048ec8:	83 e8 68             	sub    $0x68,%eax
 8048ecb:	3c 12                	cmp    $0x12,%al
 8048ecd:	77 6a                	ja     8048f39 <__vprintf+0x253>
 8048ecf:	0f b6 c0             	movzbl %al,%eax
 8048ed2:	ff 24 85 e0 a6 04 08 	jmp    *0x804a6e0(,%eax,4)
    {
    case 'h':
      if (*format == 'h') 
 8048ed9:	80 7a 01 68          	cmpb   $0x68,0x1(%edx)
 8048edd:	75 11                	jne    8048ef0 <__vprintf+0x20a>
        {
          format++;
 8048edf:	83 c2 02             	add    $0x2,%edx
 8048ee2:	89 54 24 2c          	mov    %edx,0x2c(%esp)
          c->type = CHAR;
 8048ee6:	c7 44 24 58 01 00 00 	movl   $0x1,0x58(%esp)
 8048eed:	00 
 8048eee:	eb 4d                	jmp    8048f3d <__vprintf+0x257>
        }
      else
        c->type = SHORT;
 8048ef0:	c7 44 24 58 02 00 00 	movl   $0x2,0x58(%esp)
 8048ef7:	00 
 8048ef8:	eb 43                	jmp    8048f3d <__vprintf+0x257>
      break;
      
    case 'j':
      c->type = INTMAX;
 8048efa:	c7 44 24 58 04 00 00 	movl   $0x4,0x58(%esp)
 8048f01:	00 
 8048f02:	eb 39                	jmp    8048f3d <__vprintf+0x257>
      break;

    case 'l':
      if (*format == 'l')
 8048f04:	80 7a 01 6c          	cmpb   $0x6c,0x1(%edx)
 8048f08:	75 11                	jne    8048f1b <__vprintf+0x235>
        {
          format++;
 8048f0a:	83 c2 02             	add    $0x2,%edx
 8048f0d:	89 54 24 2c          	mov    %edx,0x2c(%esp)
          c->type = LONGLONG;
 8048f11:	c7 44 24 58 06 00 00 	movl   $0x6,0x58(%esp)
 8048f18:	00 
 8048f19:	eb 22                	jmp    8048f3d <__vprintf+0x257>
        }
      else
        c->type = LONG;
 8048f1b:	c7 44 24 58 05 00 00 	movl   $0x5,0x58(%esp)
 8048f22:	00 
 8048f23:	eb 18                	jmp    8048f3d <__vprintf+0x257>
      break;

    case 't':
      c->type = PTRDIFFT;
 8048f25:	c7 44 24 58 07 00 00 	movl   $0x7,0x58(%esp)
 8048f2c:	00 
 8048f2d:	eb 0e                	jmp    8048f3d <__vprintf+0x257>
      break;

    case 'z':
      c->type = SIZET;
 8048f2f:	c7 44 24 58 08 00 00 	movl   $0x8,0x58(%esp)
 8048f36:	00 
 8048f37:	eb 04                	jmp    8048f3d <__vprintf+0x257>
  if (c->precision >= 0)
    c->flags &= ~ZERO;

  /* Parse type. */
  c->type = INT;
  switch (*format++) 
 8048f39:	89 54 24 2c          	mov    %edx,0x2c(%esp)

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);

      /* Do conversion. */
      switch (*format) 
 8048f3d:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8048f41:	0f b6 13             	movzbl (%ebx),%edx
 8048f44:	8d 42 bb             	lea    -0x45(%edx),%eax
 8048f47:	3c 33                	cmp    $0x33,%al
 8048f49:	0f 87 d2 04 00 00    	ja     8049421 <__vprintf+0x73b>
 8048f4f:	0f b6 c0             	movzbl %al,%eax
 8048f52:	ff 24 85 2c a7 04 08 	jmp    *0x804a72c(,%eax,4)
        case 'i': 
          {
            /* Signed integer conversions. */
            intmax_t value;
            
            switch (c.type) 
 8048f59:	83 7c 24 58 08       	cmpl   $0x8,0x58(%esp)
 8048f5e:	0f 87 52 01 00 00    	ja     80490b6 <__vprintf+0x3d0>
 8048f64:	8b 44 24 58          	mov    0x58(%esp),%eax
 8048f68:	ff 24 85 fc a7 04 08 	jmp    *0x804a7fc(,%eax,4)
              {
              case CHAR: 
                value = (signed char) va_arg (args, int);
 8048f6f:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048f76:	0f be 03             	movsbl (%ebx),%eax
 8048f79:	89 44 24 30          	mov    %eax,0x30(%esp)
 8048f7d:	89 c2                	mov    %eax,%edx
 8048f7f:	c1 fa 1f             	sar    $0x1f,%edx
 8048f82:	89 54 24 34          	mov    %edx,0x34(%esp)
 8048f86:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8048f89:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8048f90:	e9 45 01 00 00       	jmp    80490da <__vprintf+0x3f4>
              case SHORT:
                value = (short) va_arg (args, int);
 8048f95:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048f9c:	0f bf 03             	movswl (%ebx),%eax
 8048f9f:	89 44 24 30          	mov    %eax,0x30(%esp)
 8048fa3:	89 c2                	mov    %eax,%edx
 8048fa5:	c1 fa 1f             	sar    $0x1f,%edx
 8048fa8:	89 54 24 34          	mov    %edx,0x34(%esp)
 8048fac:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8048faf:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8048fb6:	e9 1f 01 00 00       	jmp    80490da <__vprintf+0x3f4>
              case INT:
                value = va_arg (args, int);
 8048fbb:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048fc2:	8b 03                	mov    (%ebx),%eax
 8048fc4:	89 44 24 30          	mov    %eax,0x30(%esp)
 8048fc8:	89 c2                	mov    %eax,%edx
 8048fca:	c1 fa 1f             	sar    $0x1f,%edx
 8048fcd:	89 54 24 34          	mov    %edx,0x34(%esp)
 8048fd1:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8048fd4:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8048fdb:	e9 fa 00 00 00       	jmp    80490da <__vprintf+0x3f4>
              case INTMAX:
                value = va_arg (args, intmax_t);
 8048fe0:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048fe7:	8b 0b                	mov    (%ebx),%ecx
 8048fe9:	8b 5b 04             	mov    0x4(%ebx),%ebx
 8048fec:	89 4c 24 30          	mov    %ecx,0x30(%esp)
 8048ff0:	89 5c 24 34          	mov    %ebx,0x34(%esp)
 8048ff4:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8048ffb:	8d 5b 08             	lea    0x8(%ebx),%ebx
 8048ffe:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8049005:	e9 d0 00 00 00       	jmp    80490da <__vprintf+0x3f4>
              case LONG:
                value = va_arg (args, long);
 804900a:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8049011:	8b 03                	mov    (%ebx),%eax
 8049013:	89 44 24 30          	mov    %eax,0x30(%esp)
 8049017:	89 c2                	mov    %eax,%edx
 8049019:	c1 fa 1f             	sar    $0x1f,%edx
 804901c:	89 54 24 34          	mov    %edx,0x34(%esp)
 8049020:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8049023:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 804902a:	e9 ab 00 00 00       	jmp    80490da <__vprintf+0x3f4>
              case LONGLONG:
                value = va_arg (args, long long);
 804902f:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8049036:	8b 0b                	mov    (%ebx),%ecx
 8049038:	8b 5b 04             	mov    0x4(%ebx),%ebx
 804903b:	89 4c 24 30          	mov    %ecx,0x30(%esp)
 804903f:	89 5c 24 34          	mov    %ebx,0x34(%esp)
 8049043:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 804904a:	8d 5b 08             	lea    0x8(%ebx),%ebx
 804904d:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8049054:	e9 81 00 00 00       	jmp    80490da <__vprintf+0x3f4>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
 8049059:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8049060:	8b 03                	mov    (%ebx),%eax
 8049062:	89 44 24 30          	mov    %eax,0x30(%esp)
 8049066:	89 c2                	mov    %eax,%edx
 8049068:	c1 fa 1f             	sar    $0x1f,%edx
 804906b:	89 54 24 34          	mov    %edx,0x34(%esp)
 804906f:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8049072:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8049079:	eb 5f                	jmp    80490da <__vprintf+0x3f4>
              case SIZET:
                value = va_arg (args, size_t);
 804907b:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
 8049082:	83 c0 04             	add    $0x4,%eax
 8049085:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 804908c:	8b 0b                	mov    (%ebx),%ecx
 804908e:	bb 00 00 00 00       	mov    $0x0,%ebx
 8049093:	89 4c 24 30          	mov    %ecx,0x30(%esp)
 8049097:	89 5c 24 34          	mov    %ebx,0x34(%esp)
 804909b:	89 84 24 84 00 00 00 	mov    %eax,0x84(%esp)
                if (value > SIZE_MAX / 2)
 80490a2:	81 f9 ff ff ff 7f    	cmp    $0x7fffffff,%ecx
 80490a8:	76 30                	jbe    80490da <__vprintf+0x3f4>
                  value = value - SIZE_MAX - 1;
 80490aa:	83 44 24 30 00       	addl   $0x0,0x30(%esp)
 80490af:	83 54 24 34 ff       	adcl   $0xffffffff,0x34(%esp)
 80490b4:	eb 24                	jmp    80490da <__vprintf+0x3f4>
                break;
              default:
                NOT_REACHED ();
 80490b6:	c7 44 24 0c e8 ac 04 	movl   $0x804ace8,0xc(%esp)
 80490bd:	08 
 80490be:	c7 44 24 08 44 a8 04 	movl   $0x804a844,0x8(%esp)
 80490c5:	08 
 80490c6:	c7 44 24 04 dc 00 00 	movl   $0xdc,0x4(%esp)
 80490cd:	00 
 80490ce:	c7 04 24 c2 a9 04 08 	movl   $0x804a9c2,(%esp)
 80490d5:	e8 16 12 00 00       	call   804a2f0 <debug_panic>
              }

            format_integer (value < 0 ? -value : value,
 80490da:	8b 54 24 34          	mov    0x34(%esp),%edx
 80490de:	c1 fa 1f             	sar    $0x1f,%edx
 80490e1:	8b 4c 24 30          	mov    0x30(%esp),%ecx
 80490e5:	31 d1                	xor    %edx,%ecx
 80490e7:	89 4c 24 38          	mov    %ecx,0x38(%esp)
 80490eb:	8b 5c 24 34          	mov    0x34(%esp),%ebx
 80490ef:	31 d3                	xor    %edx,%ebx
 80490f1:	89 5c 24 3c          	mov    %ebx,0x3c(%esp)
 80490f5:	8b 4c 24 38          	mov    0x38(%esp),%ecx
 80490f9:	8b 5c 24 3c          	mov    0x3c(%esp),%ebx
 80490fd:	29 d1                	sub    %edx,%ecx
 80490ff:	19 d3                	sbb    %edx,%ebx
 8049101:	89 c8                	mov    %ecx,%eax
 8049103:	89 da                	mov    %ebx,%edx
 8049105:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 804910c:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 8049110:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
 8049117:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
                            true, value < 0, &base_d, &c, output, aux);
 804911b:	8d 4c 24 4c          	lea    0x4c(%esp),%ecx
 804911f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
                break;
              default:
                NOT_REACHED ();
              }

            format_integer (value < 0 ? -value : value,
 8049123:	c7 44 24 04 50 a8 04 	movl   $0x804a850,0x4(%esp)
 804912a:	08 
 804912b:	8b 4c 24 34          	mov    0x34(%esp),%ecx
 804912f:	c1 e9 1f             	shr    $0x1f,%ecx
 8049132:	89 0c 24             	mov    %ecx,(%esp)
 8049135:	b9 01 00 00 00       	mov    $0x1,%ecx
 804913a:	e8 ee f7 ff ff       	call   804892d <format_integer>
                            true, value < 0, &base_d, &c, output, aux);
          }
          break;
 804913f:	e9 06 03 00 00       	jmp    804944a <__vprintf+0x764>
          {
            /* Unsigned integer conversions. */
            uintmax_t value;
            const struct integer_base *b;

            switch (c.type) 
 8049144:	83 7c 24 58 08       	cmpl   $0x8,0x58(%esp)
 8049149:	0f 87 e5 00 00 00    	ja     8049234 <__vprintf+0x54e>
 804914f:	8b 44 24 58          	mov    0x58(%esp),%eax
 8049153:	ff 24 85 20 a8 04 08 	jmp    *0x804a820(,%eax,4)
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
 804915a:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8049161:	0f b6 33             	movzbl (%ebx),%esi
 8049164:	bf 00 00 00 00       	mov    $0x0,%edi
 8049169:	8d 5b 04             	lea    0x4(%ebx),%ebx
 804916c:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8049173:	e9 e0 00 00 00       	jmp    8049258 <__vprintf+0x572>
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
 8049178:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 804917f:	0f b7 33             	movzwl (%ebx),%esi
 8049182:	bf 00 00 00 00       	mov    $0x0,%edi
 8049187:	8d 5b 04             	lea    0x4(%ebx),%ebx
 804918a:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8049191:	e9 c2 00 00 00       	jmp    8049258 <__vprintf+0x572>
              case INT:
                value = va_arg (args, unsigned);
 8049196:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 804919d:	8b 33                	mov    (%ebx),%esi
 804919f:	bf 00 00 00 00       	mov    $0x0,%edi
 80491a4:	8d 5b 04             	lea    0x4(%ebx),%ebx
 80491a7:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 80491ae:	e9 a5 00 00 00       	jmp    8049258 <__vprintf+0x572>
              case INTMAX:
                value = va_arg (args, uintmax_t);
 80491b3:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 80491ba:	8b 33                	mov    (%ebx),%esi
 80491bc:	8b 7b 04             	mov    0x4(%ebx),%edi
 80491bf:	8d 5b 08             	lea    0x8(%ebx),%ebx
 80491c2:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 80491c9:	e9 8a 00 00 00       	jmp    8049258 <__vprintf+0x572>
              case LONG:
                value = va_arg (args, unsigned long);
 80491ce:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 80491d5:	8b 33                	mov    (%ebx),%esi
 80491d7:	bf 00 00 00 00       	mov    $0x0,%edi
 80491dc:	8d 5b 04             	lea    0x4(%ebx),%ebx
 80491df:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 80491e6:	eb 70                	jmp    8049258 <__vprintf+0x572>
              case LONGLONG:
                value = va_arg (args, unsigned long long);
 80491e8:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 80491ef:	8b 33                	mov    (%ebx),%esi
 80491f1:	8b 7b 04             	mov    0x4(%ebx),%edi
 80491f4:	8d 5b 08             	lea    0x8(%ebx),%ebx
 80491f7:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 80491fe:	eb 58                	jmp    8049258 <__vprintf+0x572>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
 8049200:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8049207:	8b 33                	mov    (%ebx),%esi
 8049209:	bf 00 00 00 00       	mov    $0x0,%edi
                break;
              case LONGLONG:
                value = va_arg (args, unsigned long long);
                break;
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
 804920e:	8d 5b 04             	lea    0x4(%ebx),%ebx
 8049211:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
#endif
                break;
 8049218:	eb 3e                	jmp    8049258 <__vprintf+0x572>
              case SIZET:
                value = va_arg (args, size_t);
 804921a:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8049221:	8b 33                	mov    (%ebx),%esi
 8049223:	bf 00 00 00 00       	mov    $0x0,%edi
 8049228:	8d 5b 04             	lea    0x4(%ebx),%ebx
 804922b:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
                break;
 8049232:	eb 24                	jmp    8049258 <__vprintf+0x572>
              default:
                NOT_REACHED ();
 8049234:	c7 44 24 0c e8 ac 04 	movl   $0x804ace8,0xc(%esp)
 804923b:	08 
 804923c:	c7 44 24 08 44 a8 04 	movl   $0x804a844,0x8(%esp)
 8049243:	08 
 8049244:	c7 44 24 04 0b 01 00 	movl   $0x10b,0x4(%esp)
 804924b:	00 
 804924c:	c7 04 24 c2 a9 04 08 	movl   $0x804a9c2,(%esp)
 8049253:	e8 98 10 00 00       	call   804a2f0 <debug_panic>
              }

            switch (*format) 
 8049258:	80 fa 6f             	cmp    $0x6f,%dl
 804925b:	74 4c                	je     80492a9 <__vprintf+0x5c3>
 804925d:	80 fa 6f             	cmp    $0x6f,%dl
 8049260:	7f 07                	jg     8049269 <__vprintf+0x583>
 8049262:	80 fa 58             	cmp    $0x58,%dl
 8049265:	75 1e                	jne    8049285 <__vprintf+0x59f>
 8049267:	eb 15                	jmp    804927e <__vprintf+0x598>
 8049269:	80 fa 75             	cmp    $0x75,%dl
 804926c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049270:	74 3e                	je     80492b0 <__vprintf+0x5ca>
 8049272:	80 fa 78             	cmp    $0x78,%dl
 8049275:	75 0e                	jne    8049285 <__vprintf+0x59f>
              {
              case 'o': b = &base_o; break;
              case 'u': b = &base_d; break;
              case 'x': b = &base_x; break;
 8049277:	b8 70 a8 04 08       	mov    $0x804a870,%eax
 804927c:	eb 37                	jmp    80492b5 <__vprintf+0x5cf>
              case 'X': b = &base_X; break;
 804927e:	b8 80 a8 04 08       	mov    $0x804a880,%eax
 8049283:	eb 30                	jmp    80492b5 <__vprintf+0x5cf>
              default: NOT_REACHED ();
 8049285:	c7 44 24 0c e8 ac 04 	movl   $0x804ace8,0xc(%esp)
 804928c:	08 
 804928d:	c7 44 24 08 44 a8 04 	movl   $0x804a844,0x8(%esp)
 8049294:	08 
 8049295:	c7 44 24 04 14 01 00 	movl   $0x114,0x4(%esp)
 804929c:	00 
 804929d:	c7 04 24 c2 a9 04 08 	movl   $0x804a9c2,(%esp)
 80492a4:	e8 47 10 00 00       	call   804a2f0 <debug_panic>
                NOT_REACHED ();
              }

            switch (*format) 
              {
              case 'o': b = &base_o; break;
 80492a9:	b8 60 a8 04 08       	mov    $0x804a860,%eax
 80492ae:	eb 05                	jmp    80492b5 <__vprintf+0x5cf>
              case 'u': b = &base_d; break;
 80492b0:	b8 50 a8 04 08       	mov    $0x804a850,%eax
              case 'x': b = &base_x; break;
              case 'X': b = &base_X; break;
              default: NOT_REACHED ();
              }

            format_integer (value, false, false, b, &c, output, aux);
 80492b5:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 80492bc:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 80492c0:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
 80492c7:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 80492cb:	8d 54 24 4c          	lea    0x4c(%esp),%edx
 80492cf:	89 54 24 08          	mov    %edx,0x8(%esp)
 80492d3:	89 44 24 04          	mov    %eax,0x4(%esp)
 80492d7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80492de:	b9 00 00 00 00       	mov    $0x0,%ecx
 80492e3:	89 f0                	mov    %esi,%eax
 80492e5:	89 fa                	mov    %edi,%edx
 80492e7:	e8 41 f6 ff ff       	call   804892d <format_integer>
          }
          break;
 80492ec:	e9 59 01 00 00       	jmp    804944a <__vprintf+0x764>

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
 80492f1:	8b ac 24 84 00 00 00 	mov    0x84(%esp),%ebp
 80492f8:	83 c5 04             	add    $0x4,%ebp
 80492fb:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8049302:	8b 03                	mov    (%ebx),%eax
 8049304:	88 44 24 5f          	mov    %al,0x5f(%esp)
            format_string (&ch, 1, &c, output, aux);
 8049308:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 804930f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8049313:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
 804931a:	89 1c 24             	mov    %ebx,(%esp)
 804931d:	8d 4c 24 4c          	lea    0x4c(%esp),%ecx
 8049321:	ba 01 00 00 00       	mov    $0x1,%edx
 8049326:	8d 44 24 5f          	lea    0x5f(%esp),%eax
 804932a:	e8 f5 f8 ff ff       	call   8048c24 <format_string>
          break;

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
 804932f:	89 ac 24 84 00 00 00 	mov    %ebp,0x84(%esp)
            format_string (&ch, 1, &c, output, aux);
          }
          break;
 8049336:	e9 0f 01 00 00       	jmp    804944a <__vprintf+0x764>

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
 804933b:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 8049342:	83 c3 04             	add    $0x4,%ebx
 8049345:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
 804934c:	8b 28                	mov    (%eax),%ebp
            if (s == NULL)
              s = "(null)";
 804934e:	85 ed                	test   %ebp,%ebp
 8049350:	b8 bb a9 04 08       	mov    $0x804a9bb,%eax
 8049355:	0f 44 e8             	cmove  %eax,%ebp

            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
 8049358:	8b 44 24 54          	mov    0x54(%esp),%eax
 804935c:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049360:	89 2c 24             	mov    %ebp,(%esp)
 8049363:	e8 bb 0a 00 00       	call   8049e23 <strnlen>
 8049368:	8b 94 24 8c 00 00 00 	mov    0x8c(%esp),%edx
 804936f:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049373:	8b 8c 24 88 00 00 00 	mov    0x88(%esp),%ecx
 804937a:	89 0c 24             	mov    %ecx,(%esp)
 804937d:	8d 4c 24 4c          	lea    0x4c(%esp),%ecx
 8049381:	89 c2                	mov    %eax,%edx
 8049383:	89 e8                	mov    %ebp,%eax
 8049385:	e8 9a f8 ff ff       	call   8048c24 <format_string>
          break;

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
 804938a:	89 9c 24 84 00 00 00 	mov    %ebx,0x84(%esp)
            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
          }
          break;
 8049391:	e9 b4 00 00 00       	jmp    804944a <__vprintf+0x764>
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
 8049396:	8b ac 24 84 00 00 00 	mov    0x84(%esp),%ebp
 804939d:	83 c5 04             	add    $0x4,%ebp
 80493a0:	8b 9c 24 84 00 00 00 	mov    0x84(%esp),%ebx
 80493a7:	8b 03                	mov    (%ebx),%eax

            c.flags = POUND;
 80493a9:	c7 44 24 4c 08 00 00 	movl   $0x8,0x4c(%esp)
 80493b0:	00 
            format_integer ((uintptr_t) p, false, false,
 80493b1:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 80493b8:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 80493bc:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
 80493c3:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
                            &base_x, &c, output, aux);
 80493c7:	8d 54 24 4c          	lea    0x4c(%esp),%edx
 80493cb:	89 54 24 08          	mov    %edx,0x8(%esp)
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);

            c.flags = POUND;
            format_integer ((uintptr_t) p, false, false,
 80493cf:	c7 44 24 04 70 a8 04 	movl   $0x804a870,0x4(%esp)
 80493d6:	08 
 80493d7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
 80493de:	b9 00 00 00 00       	mov    $0x0,%ecx
 80493e3:	ba 00 00 00 00       	mov    $0x0,%edx
 80493e8:	e8 40 f5 ff ff       	call   804892d <format_integer>
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
 80493ed:	89 ac 24 84 00 00 00 	mov    %ebp,0x84(%esp)

            c.flags = POUND;
            format_integer ((uintptr_t) p, false, false,
                            &base_x, &c, output, aux);
          }
          break;
 80493f4:	eb 54                	jmp    804944a <__vprintf+0x764>
        case 'g':
        case 'G':
        case 'n':
          /* We don't support floating-point arithmetic,
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
 80493f6:	0f be c2             	movsbl %dl,%eax
 80493f9:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80493fd:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 8049404:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 8049408:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
 804940f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 8049413:	c7 04 24 d4 a9 04 08 	movl   $0x804a9d4,(%esp)
 804941a:	e8 9c f8 ff ff       	call   8048cbb <__printf>
          break;
 804941f:	eb 29                	jmp    804944a <__vprintf+0x764>

        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
 8049421:	0f be c2             	movsbl %dl,%eax
 8049424:	89 44 24 0c          	mov    %eax,0xc(%esp)
 8049428:	8b 9c 24 8c 00 00 00 	mov    0x8c(%esp),%ebx
 804942f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 8049433:	8b 9c 24 88 00 00 00 	mov    0x88(%esp),%ebx
 804943a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804943e:	c7 04 24 ea a9 04 08 	movl   $0x804a9ea,(%esp)
 8049445:	e8 71 f8 ff ff       	call   8048cbb <__printf>

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
  for (; *format != '\0'; format++)
 804944a:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
 804944e:	83 c5 01             	add    $0x1,%ebp
 8049451:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8049455:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
 8049459:	84 c0                	test   %al,%al
 804945b:	0f 85 9f f8 ff ff    	jne    8048d00 <__vprintf+0x1a>
 8049461:	eb 0a                	jmp    804946d <__vprintf+0x787>
        }
      if (c->precision < 0) 
        c->precision = -1;
    }
  if (c->precision >= 0)
    c->flags &= ~ZERO;
 8049463:	83 64 24 4c ef       	andl   $0xffffffef,0x4c(%esp)
 8049468:	e9 49 fa ff ff       	jmp    8048eb6 <__vprintf+0x1d0>
        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
          break;
        }
    }
}
 804946d:	83 c4 6c             	add    $0x6c,%esp
 8049470:	5b                   	pop    %ebx
 8049471:	5e                   	pop    %esi
 8049472:	5f                   	pop    %edi
 8049473:	5d                   	pop    %ebp
 8049474:	c3                   	ret    

08049475 <vsnprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) 
{
 8049475:	53                   	push   %ebx
 8049476:	83 ec 28             	sub    $0x28,%esp
 8049479:	8b 44 24 34          	mov    0x34(%esp),%eax
 804947d:	8b 54 24 38          	mov    0x38(%esp),%edx
 8049481:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
 8049485:	8b 5c 24 30          	mov    0x30(%esp),%ebx
 8049489:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  aux.length = 0;
 804948d:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
 8049494:	00 
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
 8049495:	85 c0                	test   %eax,%eax
 8049497:	74 33                	je     80494cc <vsnprintf+0x57>
 8049499:	83 e8 01             	sub    $0x1,%eax
 804949c:	89 44 24 1c          	mov    %eax,0x1c(%esp)

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
 80494a0:	8d 44 24 14          	lea    0x14(%esp),%eax
 80494a4:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80494a8:	c7 44 24 08 b0 88 04 	movl   $0x80488b0,0x8(%esp)
 80494af:	08 
 80494b0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 80494b4:	89 14 24             	mov    %edx,(%esp)
 80494b7:	e8 2a f8 ff ff       	call   8048ce6 <__vprintf>

  /* Add null terminator. */
  if (buf_size > 0)
    *aux.p = '\0';
 80494bc:	8b 44 24 14          	mov    0x14(%esp),%eax
 80494c0:	c6 00 00             	movb   $0x0,(%eax)

  return aux.length;
}
 80494c3:	8b 44 24 18          	mov    0x18(%esp),%eax
 80494c7:	83 c4 28             	add    $0x28,%esp
 80494ca:	5b                   	pop    %ebx
 80494cb:	c3                   	ret    
{
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
  aux.length = 0;
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
 80494cc:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 80494d3:	00 

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
 80494d4:	8d 44 24 14          	lea    0x14(%esp),%eax
 80494d8:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80494dc:	c7 44 24 08 b0 88 04 	movl   $0x80488b0,0x8(%esp)
 80494e3:	08 
 80494e4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 80494e8:	89 14 24             	mov    %edx,(%esp)
 80494eb:	e8 f6 f7 ff ff       	call   8048ce6 <__vprintf>
 80494f0:	eb d1                	jmp    80494c3 <vsnprintf+0x4e>

080494f2 <snprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
snprintf (char *buffer, size_t buf_size, const char *format, ...) 
{
 80494f2:	83 ec 1c             	sub    $0x1c,%esp
  va_list args;
  int retval;

  va_start (args, format);
 80494f5:	8d 44 24 2c          	lea    0x2c(%esp),%eax
  retval = vsnprintf (buffer, buf_size, format, args);
 80494f9:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80494fd:	8b 44 24 28          	mov    0x28(%esp),%eax
 8049501:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049505:	8b 44 24 24          	mov    0x24(%esp),%eax
 8049509:	89 44 24 04          	mov    %eax,0x4(%esp)
 804950d:	8b 44 24 20          	mov    0x20(%esp),%eax
 8049511:	89 04 24             	mov    %eax,(%esp)
 8049514:	e8 5c ff ff ff       	call   8049475 <vsnprintf>
  va_end (args);

  return retval;
}
 8049519:	83 c4 1c             	add    $0x1c,%esp
 804951c:	c3                   	ret    

0804951d <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
 804951d:	55                   	push   %ebp
 804951e:	57                   	push   %edi
 804951f:	56                   	push   %esi
 8049520:	53                   	push   %ebx
 8049521:	83 ec 3c             	sub    $0x3c,%esp
 8049524:	0f b6 44 24 5c       	movzbl 0x5c(%esp),%eax
 8049529:	88 44 24 2f          	mov    %al,0x2f(%esp)
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
 804952d:	83 7c 24 58 00       	cmpl   $0x0,0x58(%esp)
 8049532:	0f 84 6e 01 00 00    	je     80496a6 <hex_dump+0x189>
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
  const uint8_t *buf = buf_;
 8049538:	8b 54 24 54          	mov    0x54(%esp),%edx
 804953c:	89 54 24 20          	mov    %edx,0x20(%esp)
      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
 8049540:	bf 20 00 00 00       	mov    $0x20,%edi
    {
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
 8049545:	8b 74 24 50          	mov    0x50(%esp),%esi
 8049549:	83 e6 0f             	and    $0xf,%esi
      end = per_line;
      if (end - start > size)
 804954c:	b8 10 00 00 00       	mov    $0x10,%eax
 8049551:	29 f0                	sub    %esi,%eax
        end = start + size;
 8049553:	8b 6c 24 58          	mov    0x58(%esp),%ebp
 8049557:	01 f5                	add    %esi,%ebp
 8049559:	3b 44 24 58          	cmp    0x58(%esp),%eax
 804955d:	b8 10 00 00 00       	mov    $0x10,%eax
 8049562:	0f 46 e8             	cmovbe %eax,%ebp
      n = end - start;
 8049565:	89 ea                	mov    %ebp,%edx
 8049567:	29 f2                	sub    %esi,%edx
 8049569:	89 54 24 1c          	mov    %edx,0x1c(%esp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
 804956d:	8b 44 24 50          	mov    0x50(%esp),%eax
 8049571:	83 e0 f0             	and    $0xfffffff0,%eax
 8049574:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049578:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804957f:	00 
 8049580:	c7 04 24 01 aa 04 08 	movl   $0x804aa01,(%esp)
 8049587:	e8 14 f7 ff ff       	call   8048ca0 <printf>
      for (i = 0; i < start; i++)
 804958c:	bb 00 00 00 00       	mov    $0x0,%ebx
 8049591:	85 f6                	test   %esi,%esi
 8049593:	74 15                	je     80495aa <hex_dump+0x8d>
        printf ("   ");
 8049595:	c7 04 24 09 aa 04 08 	movl   $0x804aa09,(%esp)
 804959c:	e8 ff f6 ff ff       	call   8048ca0 <printf>
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
 80495a1:	83 c3 01             	add    $0x1,%ebx
 80495a4:	39 f3                	cmp    %esi,%ebx
 80495a6:	75 ed                	jne    8049595 <hex_dump+0x78>
 80495a8:	89 f3                	mov    %esi,%ebx
        printf ("   ");
      for (; i < end; i++) 
 80495aa:	39 dd                	cmp    %ebx,%ebp
 80495ac:	76 3c                	jbe    80495ea <hex_dump+0xcd>
   arranged 16 per line.  Numeric offsets are also included,
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
 80495ae:	8b 44 24 20          	mov    0x20(%esp),%eax
 80495b2:	29 f0                	sub    %esi,%eax
 80495b4:	89 74 24 28          	mov    %esi,0x28(%esp)
 80495b8:	89 c6                	mov    %eax,%esi
      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
 80495ba:	83 fb 07             	cmp    $0x7,%ebx
 80495bd:	b8 2d 00 00 00       	mov    $0x2d,%eax
 80495c2:	0f 45 c7             	cmovne %edi,%eax
 80495c5:	89 44 24 08          	mov    %eax,0x8(%esp)
 80495c9:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
 80495cd:	89 44 24 04          	mov    %eax,0x4(%esp)
 80495d1:	c7 04 24 0d aa 04 08 	movl   $0x804aa0d,(%esp)
 80495d8:	e8 c3 f6 ff ff       	call   8048ca0 <printf>

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
 80495dd:	83 c3 01             	add    $0x1,%ebx
 80495e0:	39 dd                	cmp    %ebx,%ebp
 80495e2:	77 d6                	ja     80495ba <hex_dump+0x9d>
 80495e4:	8b 74 24 28          	mov    0x28(%esp),%esi
 80495e8:	89 eb                	mov    %ebp,%ebx
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
 80495ea:	80 7c 24 2f 00       	cmpb   $0x0,0x2f(%esp)
 80495ef:	0f 84 8f 00 00 00    	je     8049684 <hex_dump+0x167>
        {
          for (; i < per_line; i++)
 80495f5:	83 fb 0f             	cmp    $0xf,%ebx
 80495f8:	77 14                	ja     804960e <hex_dump+0xf1>
            printf ("   ");
 80495fa:	c7 04 24 09 aa 04 08 	movl   $0x804aa09,(%esp)
 8049601:	e8 9a f6 ff ff       	call   8048ca0 <printf>
      for (; i < end; i++) 
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
        {
          for (; i < per_line; i++)
 8049606:	83 c3 01             	add    $0x1,%ebx
 8049609:	83 fb 10             	cmp    $0x10,%ebx
 804960c:	75 ec                	jne    80495fa <hex_dump+0xdd>
            printf ("   ");
          printf ("|");
 804960e:	c7 04 24 7c 00 00 00 	movl   $0x7c,(%esp)
 8049615:	e8 fe 0e 00 00       	call   804a518 <putchar>
          for (i = 0; i < start; i++)
 804961a:	bb 00 00 00 00       	mov    $0x0,%ebx
 804961f:	85 f6                	test   %esi,%esi
 8049621:	74 11                	je     8049634 <hex_dump+0x117>
            printf (" ");
 8049623:	89 3c 24             	mov    %edi,(%esp)
 8049626:	e8 ed 0e 00 00       	call   804a518 <putchar>
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
 804962b:	83 c3 01             	add    $0x1,%ebx
 804962e:	39 f3                	cmp    %esi,%ebx
 8049630:	75 f1                	jne    8049623 <hex_dump+0x106>
 8049632:	89 f3                	mov    %esi,%ebx
            printf (" ");
          for (; i < end; i++)
 8049634:	39 dd                	cmp    %ebx,%ebp
 8049636:	76 2b                	jbe    8049663 <hex_dump+0x146>
   arranged 16 per line.  Numeric offsets are also included,
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
 8049638:	8b 54 24 20          	mov    0x20(%esp),%edx
 804963c:	29 f2                	sub    %esi,%edx
 804963e:	89 d6                	mov    %edx,%esi
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
 8049640:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
  return (c == ' ' || c == '\f' || c == '\n'
          || c == '\r' || c == '\t' || c == '\v');
}
static inline int isblank (int c) { return c == ' ' || c == '\t'; }
static inline int isgraph (int c) { return c > 32 && c < 127; }
static inline int isprint (int c) { return c >= 32 && c < 127; }
 8049644:	8d 50 e0             	lea    -0x20(%eax),%edx
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
 8049647:	83 fa 5f             	cmp    $0x5f,%edx
 804964a:	ba 2e 00 00 00       	mov    $0x2e,%edx
 804964f:	0f 43 c2             	cmovae %edx,%eax
 8049652:	89 04 24             	mov    %eax,(%esp)
 8049655:	e8 be 0e 00 00       	call   804a518 <putchar>
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
 804965a:	83 c3 01             	add    $0x1,%ebx
 804965d:	39 dd                	cmp    %ebx,%ebp
 804965f:	77 df                	ja     8049640 <hex_dump+0x123>
 8049661:	89 eb                	mov    %ebp,%ebx
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
 8049663:	83 fb 0f             	cmp    $0xf,%ebx
 8049666:	77 10                	ja     8049678 <hex_dump+0x15b>
            printf (" ");
 8049668:	89 3c 24             	mov    %edi,(%esp)
 804966b:	e8 a8 0e 00 00       	call   804a518 <putchar>
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
 8049670:	83 c3 01             	add    $0x1,%ebx
 8049673:	83 fb 10             	cmp    $0x10,%ebx
 8049676:	75 f0                	jne    8049668 <hex_dump+0x14b>
            printf (" ");
          printf ("|");
 8049678:	c7 04 24 7c 00 00 00 	movl   $0x7c,(%esp)
 804967f:	e8 94 0e 00 00       	call   804a518 <putchar>
        }
      printf ("\n");
 8049684:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 804968b:	e8 88 0e 00 00       	call   804a518 <putchar>

      ofs += n;
 8049690:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8049694:	01 44 24 50          	add    %eax,0x50(%esp)
      buf += n;
 8049698:	01 44 24 20          	add    %eax,0x20(%esp)
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
 804969c:	29 44 24 58          	sub    %eax,0x58(%esp)
 80496a0:	0f 85 9f fe ff ff    	jne    8049545 <hex_dump+0x28>

      ofs += n;
      buf += n;
      size -= n;
    }
}
 80496a6:	83 c4 3c             	add    $0x3c,%esp
 80496a9:	5b                   	pop    %ebx
 80496aa:	5e                   	pop    %esi
 80496ab:	5f                   	pop    %edi
 80496ac:	5d                   	pop    %ebp
 80496ad:	c3                   	ret    

080496ae <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
 80496ae:	57                   	push   %edi
 80496af:	56                   	push   %esi
 80496b0:	83 ec 14             	sub    $0x14,%esp
 80496b3:	8b 74 24 20          	mov    0x20(%esp),%esi
 80496b7:	8b 7c 24 24          	mov    0x24(%esp),%edi
  if (size == 1)
 80496bb:	89 f0                	mov    %esi,%eax
 80496bd:	83 f0 01             	xor    $0x1,%eax
 80496c0:	09 f8                	or     %edi,%eax
 80496c2:	74 22                	je     80496e6 <print_human_readable_size+0x38>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
 80496c4:	83 ff 00             	cmp    $0x0,%edi
 80496c7:	77 0d                	ja     80496d6 <print_human_readable_size+0x28>
 80496c9:	b9 d0 bd 04 08       	mov    $0x804bdd0,%ecx
 80496ce:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
 80496d4:	76 42                	jbe    8049718 <print_human_readable_size+0x6a>
 80496d6:	b9 d0 bd 04 08       	mov    $0x804bdd0,%ecx
 80496db:	83 3d d4 bd 04 08 00 	cmpl   $0x0,0x804bdd4
 80496e2:	75 10                	jne    80496f4 <print_human_readable_size+0x46>
 80496e4:	eb 32                	jmp    8049718 <print_human_readable_size+0x6a>
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
  if (size == 1)
    printf ("1 byte");
 80496e6:	c7 04 24 16 aa 04 08 	movl   $0x804aa16,(%esp)
 80496ed:	e8 ae f5 ff ff       	call   8048ca0 <printf>
 80496f2:	eb 3e                	jmp    8049732 <print_human_readable_size+0x84>
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
        size /= 1024;
 80496f4:	89 f0                	mov    %esi,%eax
 80496f6:	89 fa                	mov    %edi,%edx
 80496f8:	0f ac f8 0a          	shrd   $0xa,%edi,%eax
 80496fc:	c1 ea 0a             	shr    $0xa,%edx
 80496ff:	89 c6                	mov    %eax,%esi
 8049701:	89 d7                	mov    %edx,%edi
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
 8049703:	83 c1 04             	add    $0x4,%ecx
 8049706:	83 fa 00             	cmp    $0x0,%edx
 8049709:	77 07                	ja     8049712 <print_human_readable_size+0x64>
 804970b:	3d ff 03 00 00       	cmp    $0x3ff,%eax
 8049710:	76 06                	jbe    8049718 <print_human_readable_size+0x6a>
 8049712:	83 79 04 00          	cmpl   $0x0,0x4(%ecx)
 8049716:	75 dc                	jne    80496f4 <print_human_readable_size+0x46>
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
 8049718:	8b 01                	mov    (%ecx),%eax
 804971a:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804971e:	89 74 24 04          	mov    %esi,0x4(%esp)
 8049722:	89 7c 24 08          	mov    %edi,0x8(%esp)
 8049726:	c7 04 24 1d aa 04 08 	movl   $0x804aa1d,(%esp)
 804972d:	e8 6e f5 ff ff       	call   8048ca0 <printf>
    }
}
 8049732:	83 c4 14             	add    $0x14,%esp
 8049735:	5e                   	pop    %esi
 8049736:	5f                   	pop    %edi
 8049737:	c3                   	ret    
 8049738:	90                   	nop
 8049739:	90                   	nop
 804973a:	90                   	nop
 804973b:	90                   	nop
 804973c:	90                   	nop
 804973d:	90                   	nop
 804973e:	90                   	nop
 804973f:	90                   	nop

08049740 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
 8049740:	56                   	push   %esi
 8049741:	53                   	push   %ebx
 8049742:	83 ec 24             	sub    $0x24,%esp
 8049745:	8b 44 24 30          	mov    0x30(%esp),%eax
 8049749:	8b 74 24 34          	mov    0x34(%esp),%esi
 804974d:	8b 5c 24 38          	mov    0x38(%esp),%ebx
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
 8049751:	85 db                	test   %ebx,%ebx
 8049753:	0f 94 c2             	sete   %dl
 8049756:	85 c0                	test   %eax,%eax
 8049758:	75 30                	jne    804978a <memcpy+0x4a>
 804975a:	84 d2                	test   %dl,%dl
 804975c:	75 2c                	jne    804978a <memcpy+0x4a>
 804975e:	c7 44 24 10 6d aa 04 	movl   $0x804aa6d,0x10(%esp)
 8049765:	08 
 8049766:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 804976d:	08 
 804976e:	c7 44 24 08 90 a8 04 	movl   $0x804a890,0x8(%esp)
 8049775:	08 
 8049776:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
 804977d:	00 
 804977e:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 8049785:	e8 66 0b 00 00       	call   804a2f0 <debug_panic>
  ASSERT (src != NULL || size == 0);
 804978a:	84 d2                	test   %dl,%dl
 804978c:	75 04                	jne    8049792 <memcpy+0x52>
 804978e:	85 f6                	test   %esi,%esi
 8049790:	74 0b                	je     804979d <memcpy+0x5d>

  while (size-- > 0)
 8049792:	ba 00 00 00 00       	mov    $0x0,%edx
 8049797:	85 db                	test   %ebx,%ebx
 8049799:	75 2e                	jne    80497c9 <memcpy+0x89>
 804979b:	eb 3a                	jmp    80497d7 <memcpy+0x97>
{
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);
 804979d:	c7 44 24 10 b0 aa 04 	movl   $0x804aab0,0x10(%esp)
 80497a4:	08 
 80497a5:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 80497ac:	08 
 80497ad:	c7 44 24 08 90 a8 04 	movl   $0x804a890,0x8(%esp)
 80497b4:	08 
 80497b5:	c7 44 24 04 0d 00 00 	movl   $0xd,0x4(%esp)
 80497bc:	00 
 80497bd:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 80497c4:	e8 27 0b 00 00       	call   804a2f0 <debug_panic>

  while (size-- > 0)
    *dst++ = *src++;
 80497c9:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
 80497cd:	88 0c 10             	mov    %cl,(%eax,%edx,1)
 80497d0:	83 c2 01             	add    $0x1,%edx
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
 80497d3:	39 da                	cmp    %ebx,%edx
 80497d5:	75 f2                	jne    80497c9 <memcpy+0x89>
    *dst++ = *src++;

  return dst_;
}
 80497d7:	83 c4 24             	add    $0x24,%esp
 80497da:	5b                   	pop    %ebx
 80497db:	5e                   	pop    %esi
 80497dc:	c3                   	ret    

080497dd <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
 80497dd:	55                   	push   %ebp
 80497de:	57                   	push   %edi
 80497df:	56                   	push   %esi
 80497e0:	53                   	push   %ebx
 80497e1:	83 ec 2c             	sub    $0x2c,%esp
 80497e4:	8b 5c 24 40          	mov    0x40(%esp),%ebx
 80497e8:	8b 74 24 44          	mov    0x44(%esp),%esi
 80497ec:	8b 4c 24 48          	mov    0x48(%esp),%ecx
  unsigned char *dst = dst_;
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
 80497f0:	85 c9                	test   %ecx,%ecx
 80497f2:	0f 94 c0             	sete   %al
 80497f5:	85 db                	test   %ebx,%ebx
 80497f7:	75 30                	jne    8049829 <memmove+0x4c>
 80497f9:	84 c0                	test   %al,%al
 80497fb:	75 2c                	jne    8049829 <memmove+0x4c>
 80497fd:	c7 44 24 10 6d aa 04 	movl   $0x804aa6d,0x10(%esp)
 8049804:	08 
 8049805:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 804980c:	08 
 804980d:	c7 44 24 08 97 a8 04 	movl   $0x804a897,0x8(%esp)
 8049814:	08 
 8049815:	c7 44 24 04 1d 00 00 	movl   $0x1d,0x4(%esp)
 804981c:	00 
 804981d:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 8049824:	e8 c7 0a 00 00       	call   804a2f0 <debug_panic>
  ASSERT (src != NULL || size == 0);
 8049829:	84 c0                	test   %al,%al
 804982b:	75 30                	jne    804985d <memmove+0x80>
 804982d:	85 f6                	test   %esi,%esi
 804982f:	75 2c                	jne    804985d <memmove+0x80>
 8049831:	c7 44 24 10 b0 aa 04 	movl   $0x804aab0,0x10(%esp)
 8049838:	08 
 8049839:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 8049840:	08 
 8049841:	c7 44 24 08 97 a8 04 	movl   $0x804a897,0x8(%esp)
 8049848:	08 
 8049849:	c7 44 24 04 1e 00 00 	movl   $0x1e,0x4(%esp)
 8049850:	00 
 8049851:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 8049858:	e8 93 0a 00 00       	call   804a2f0 <debug_panic>

  if (dst < src) 
 804985d:	39 f3                	cmp    %esi,%ebx
 804985f:	73 1e                	jae    804987f <memmove+0xa2>
    {
      while (size-- > 0)
 8049861:	89 d8                	mov    %ebx,%eax
 8049863:	85 c9                	test   %ecx,%ecx
 8049865:	74 38                	je     804989f <memmove+0xc2>
 8049867:	b8 00 00 00 00       	mov    $0x0,%eax
        *dst++ = *src++;
 804986c:	0f b6 14 06          	movzbl (%esi,%eax,1),%edx
 8049870:	88 14 03             	mov    %dl,(%ebx,%eax,1)
 8049873:	83 c0 01             	add    $0x1,%eax
  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
    {
      while (size-- > 0)
 8049876:	39 c1                	cmp    %eax,%ecx
 8049878:	75 f2                	jne    804986c <memmove+0x8f>
 804987a:	8d 04 0b             	lea    (%ebx,%ecx,1),%eax
 804987d:	eb 20                	jmp    804989f <memmove+0xc2>
        *dst++ = *src++;
    }
  else 
    {
      dst += size;
 804987f:	8d 04 0b             	lea    (%ebx,%ecx,1),%eax
      src += size;
      while (size-- > 0)
 8049882:	85 c9                	test   %ecx,%ecx
 8049884:	74 19                	je     804989f <memmove+0xc2>
        *dst++ = *src++;
    }
  else 
    {
      dst += size;
      src += size;
 8049886:	89 ca                	mov    %ecx,%edx
}

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
 8049888:	89 cb                	mov    %ecx,%ebx
 804988a:	f7 db                	neg    %ebx
 804988c:	8d 2c 18             	lea    (%eax,%ebx,1),%ebp
  else 
    {
      dst += size;
      src += size;
      while (size-- > 0)
        *--dst = *--src;
 804988f:	0f b6 4c 16 ff       	movzbl -0x1(%esi,%edx,1),%ecx
 8049894:	88 4c 15 ff          	mov    %cl,-0x1(%ebp,%edx,1)
    }
  else 
    {
      dst += size;
      src += size;
      while (size-- > 0)
 8049898:	83 ea 01             	sub    $0x1,%edx
 804989b:	75 f2                	jne    804988f <memmove+0xb2>
 804989d:	01 d8                	add    %ebx,%eax
        *--dst = *--src;
    }

  return dst;
}
 804989f:	83 c4 2c             	add    $0x2c,%esp
 80498a2:	5b                   	pop    %ebx
 80498a3:	5e                   	pop    %esi
 80498a4:	5f                   	pop    %edi
 80498a5:	5d                   	pop    %ebp
 80498a6:	c3                   	ret    

080498a7 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
 80498a7:	57                   	push   %edi
 80498a8:	56                   	push   %esi
 80498a9:	53                   	push   %ebx
 80498aa:	83 ec 20             	sub    $0x20,%esp
 80498ad:	8b 5c 24 30          	mov    0x30(%esp),%ebx
 80498b1:	8b 74 24 34          	mov    0x34(%esp),%esi
 80498b5:	8b 7c 24 38          	mov    0x38(%esp),%edi
  const unsigned char *a = a_;
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
 80498b9:	85 ff                	test   %edi,%edi
 80498bb:	0f 94 c0             	sete   %al
 80498be:	85 db                	test   %ebx,%ebx
 80498c0:	75 30                	jne    80498f2 <memcmp+0x4b>
 80498c2:	84 c0                	test   %al,%al
 80498c4:	75 2c                	jne    80498f2 <memcmp+0x4b>
 80498c6:	c7 44 24 10 c9 aa 04 	movl   $0x804aac9,0x10(%esp)
 80498cd:	08 
 80498ce:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 80498d5:	08 
 80498d6:	c7 44 24 08 9f a8 04 	movl   $0x804a89f,0x8(%esp)
 80498dd:	08 
 80498de:	c7 44 24 04 3a 00 00 	movl   $0x3a,0x4(%esp)
 80498e5:	00 
 80498e6:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 80498ed:	e8 fe 09 00 00       	call   804a2f0 <debug_panic>
  ASSERT (b != NULL || size == 0);
 80498f2:	84 c0                	test   %al,%al
 80498f4:	75 04                	jne    80498fa <memcmp+0x53>
 80498f6:	85 f6                	test   %esi,%esi
 80498f8:	74 1d                	je     8049917 <memcmp+0x70>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
      return *a > *b ? +1 : -1;
  return 0;
 80498fa:	b8 00 00 00 00       	mov    $0x0,%eax
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
 80498ff:	85 ff                	test   %edi,%edi
 8049901:	74 65                	je     8049968 <memcmp+0xc1>
    if (*a != *b)
 8049903:	0f b6 13             	movzbl (%ebx),%edx
 8049906:	0f b6 0e             	movzbl (%esi),%ecx
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
 8049909:	83 ef 01             	sub    $0x1,%edi
 804990c:	b8 00 00 00 00       	mov    $0x0,%eax
    if (*a != *b)
 8049911:	38 ca                	cmp    %cl,%dl
 8049913:	74 4a                	je     804995f <memcmp+0xb8>
 8049915:	eb 3c                	jmp    8049953 <memcmp+0xac>
{
  const unsigned char *a = a_;
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);
 8049917:	c7 44 24 10 e0 aa 04 	movl   $0x804aae0,0x10(%esp)
 804991e:	08 
 804991f:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 8049926:	08 
 8049927:	c7 44 24 08 9f a8 04 	movl   $0x804a89f,0x8(%esp)
 804992e:	08 
 804992f:	c7 44 24 04 3b 00 00 	movl   $0x3b,0x4(%esp)
 8049936:	00 
 8049937:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 804993e:	e8 ad 09 00 00       	call   804a2f0 <debug_panic>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
 8049943:	0f b6 54 03 01       	movzbl 0x1(%ebx,%eax,1),%edx
 8049948:	83 c0 01             	add    $0x1,%eax
 804994b:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
 804994f:	38 ca                	cmp    %cl,%dl
 8049951:	74 0c                	je     804995f <memcmp+0xb8>
      return *a > *b ? +1 : -1;
 8049953:	38 d1                	cmp    %dl,%cl
 8049955:	19 c0                	sbb    %eax,%eax
 8049957:	83 e0 02             	and    $0x2,%eax
 804995a:	83 e8 01             	sub    $0x1,%eax
 804995d:	eb 09                	jmp    8049968 <memcmp+0xc1>
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
 804995f:	39 f8                	cmp    %edi,%eax
 8049961:	75 e0                	jne    8049943 <memcmp+0x9c>
    if (*a != *b)
      return *a > *b ? +1 : -1;
  return 0;
 8049963:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049968:	83 c4 20             	add    $0x20,%esp
 804996b:	5b                   	pop    %ebx
 804996c:	5e                   	pop    %esi
 804996d:	5f                   	pop    %edi
 804996e:	c3                   	ret    

0804996f <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
 804996f:	53                   	push   %ebx
 8049970:	83 ec 28             	sub    $0x28,%esp
 8049973:	8b 4c 24 30          	mov    0x30(%esp),%ecx
 8049977:	8b 5c 24 34          	mov    0x34(%esp),%ebx
  const unsigned char *a = (const unsigned char *) a_;
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
 804997b:	85 c9                	test   %ecx,%ecx
 804997d:	75 2c                	jne    80499ab <strcmp+0x3c>
 804997f:	c7 44 24 10 f7 aa 04 	movl   $0x804aaf7,0x10(%esp)
 8049986:	08 
 8049987:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 804998e:	08 
 804998f:	c7 44 24 08 a6 a8 04 	movl   $0x804a8a6,0x8(%esp)
 8049996:	08 
 8049997:	c7 44 24 04 4e 00 00 	movl   $0x4e,0x4(%esp)
 804999e:	00 
 804999f:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 80499a6:	e8 45 09 00 00       	call   804a2f0 <debug_panic>
  ASSERT (b != NULL);
 80499ab:	85 db                	test   %ebx,%ebx
 80499ad:	74 0f                	je     80499be <strcmp+0x4f>

  while (*a != '\0' && *a == *b) 
 80499af:	0f b6 11             	movzbl (%ecx),%edx
 80499b2:	89 d8                	mov    %ebx,%eax
 80499b4:	84 d2                	test   %dl,%dl
 80499b6:	74 44                	je     80499fc <strcmp+0x8d>
 80499b8:	3a 13                	cmp    (%ebx),%dl
 80499ba:	74 2e                	je     80499ea <strcmp+0x7b>
 80499bc:	eb 3e                	jmp    80499fc <strcmp+0x8d>
{
  const unsigned char *a = (const unsigned char *) a_;
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);
 80499be:	c7 44 24 10 01 ab 04 	movl   $0x804ab01,0x10(%esp)
 80499c5:	08 
 80499c6:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 80499cd:	08 
 80499ce:	c7 44 24 08 a6 a8 04 	movl   $0x804a8a6,0x8(%esp)
 80499d5:	08 
 80499d6:	c7 44 24 04 4f 00 00 	movl   $0x4f,0x4(%esp)
 80499dd:	00 
 80499de:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 80499e5:	e8 06 09 00 00       	call   804a2f0 <debug_panic>

  while (*a != '\0' && *a == *b) 
    {
      a++;
      b++;
 80499ea:	83 c0 01             	add    $0x1,%eax
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
 80499ed:	0f b6 51 01          	movzbl 0x1(%ecx),%edx
 80499f1:	84 d2                	test   %dl,%dl
 80499f3:	74 07                	je     80499fc <strcmp+0x8d>
 80499f5:	83 c1 01             	add    $0x1,%ecx
 80499f8:	3a 10                	cmp    (%eax),%dl
 80499fa:	74 ee                	je     80499ea <strcmp+0x7b>
    {
      a++;
      b++;
    }

  return *a < *b ? -1 : *a > *b;
 80499fc:	0f b6 08             	movzbl (%eax),%ecx
 80499ff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 8049a04:	38 d1                	cmp    %dl,%cl
 8049a06:	77 06                	ja     8049a0e <strcmp+0x9f>
 8049a08:	0f 92 c0             	setb   %al
 8049a0b:	0f b6 c0             	movzbl %al,%eax
}
 8049a0e:	83 c4 28             	add    $0x28,%esp
 8049a11:	5b                   	pop    %ebx
 8049a12:	c3                   	ret    

08049a13 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
 8049a13:	53                   	push   %ebx
 8049a14:	83 ec 28             	sub    $0x28,%esp
 8049a17:	8b 5c 24 30          	mov    0x30(%esp),%ebx
 8049a1b:	8b 4c 24 38          	mov    0x38(%esp),%ecx
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);
 8049a1f:	85 db                	test   %ebx,%ebx
 8049a21:	75 04                	jne    8049a27 <memchr+0x14>
 8049a23:	85 c9                	test   %ecx,%ecx
 8049a25:	75 1a                	jne    8049a41 <memchr+0x2e>

  for (; size-- > 0; block++)
    if (*block == ch)
      return (void *) block;

  return NULL;
 8049a27:	b8 00 00 00 00       	mov    $0x0,%eax
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
 8049a2c:	85 c9                	test   %ecx,%ecx
 8049a2e:	74 4d                	je     8049a7d <memchr+0x6a>
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
  const unsigned char *block = block_;
  unsigned char ch = ch_;
 8049a30:	0f b6 54 24 34       	movzbl 0x34(%esp),%edx

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
    if (*block == ch)
 8049a35:	89 d8                	mov    %ebx,%eax

/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
 8049a37:	8d 4c 0b ff          	lea    -0x1(%ebx,%ecx,1),%ecx
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
    if (*block == ch)
 8049a3b:	38 13                	cmp    %dl,(%ebx)
 8049a3d:	75 35                	jne    8049a74 <memchr+0x61>
 8049a3f:	eb 3c                	jmp    8049a7d <memchr+0x6a>
memchr (const void *block_, int ch_, size_t size) 
{
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);
 8049a41:	c7 44 24 10 0b ab 04 	movl   $0x804ab0b,0x10(%esp)
 8049a48:	08 
 8049a49:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 8049a50:	08 
 8049a51:	c7 44 24 08 ad a8 04 	movl   $0x804a8ad,0x8(%esp)
 8049a58:	08 
 8049a59:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
 8049a60:	00 
 8049a61:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 8049a68:	e8 83 08 00 00       	call   804a2f0 <debug_panic>

  for (; size-- > 0; block++)
 8049a6d:	83 c0 01             	add    $0x1,%eax
    if (*block == ch)
 8049a70:	38 10                	cmp    %dl,(%eax)
 8049a72:	74 09                	je     8049a7d <memchr+0x6a>
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
 8049a74:	39 c8                	cmp    %ecx,%eax
 8049a76:	75 f5                	jne    8049a6d <memchr+0x5a>
    if (*block == ch)
      return (void *) block;

  return NULL;
 8049a78:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049a7d:	83 c4 28             	add    $0x28,%esp
 8049a80:	5b                   	pop    %ebx
 8049a81:	c3                   	ret    

08049a82 <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
 8049a82:	83 ec 2c             	sub    $0x2c,%esp
 8049a85:	8b 44 24 30          	mov    0x30(%esp),%eax
  char c = c_;

  ASSERT (string != NULL);
 8049a89:	85 c0                	test   %eax,%eax
 8049a8b:	74 0e                	je     8049a9b <strchr+0x19>
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
  char c = c_;
 8049a8d:	0f b6 4c 24 34       	movzbl 0x34(%esp),%ecx

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
 8049a92:	0f b6 10             	movzbl (%eax),%edx
 8049a95:	38 ca                	cmp    %cl,%dl
 8049a97:	75 2e                	jne    8049ac7 <strchr+0x45>
 8049a99:	eb 4f                	jmp    8049aea <strchr+0x68>
char *
strchr (const char *string, int c_) 
{
  char c = c_;

  ASSERT (string != NULL);
 8049a9b:	c7 44 24 10 26 ab 04 	movl   $0x804ab26,0x10(%esp)
 8049aa2:	08 
 8049aa3:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 8049aaa:	08 
 8049aab:	c7 44 24 08 b4 a8 04 	movl   $0x804a8b4,0x8(%esp)
 8049ab2:	08 
 8049ab3:	c7 44 24 04 75 00 00 	movl   $0x75,0x4(%esp)
 8049aba:	00 
 8049abb:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 8049ac2:	e8 29 08 00 00       	call   804a2f0 <debug_panic>

  for (;;) 
    if (*string == c)
      return (char *) string;
    else if (*string == '\0')
 8049ac7:	84 d2                	test   %dl,%dl
 8049ac9:	75 07                	jne    8049ad2 <strchr+0x50>
 8049acb:	eb 11                	jmp    8049ade <strchr+0x5c>
 8049acd:	84 d2                	test   %dl,%dl
 8049acf:	90                   	nop
 8049ad0:	74 13                	je     8049ae5 <strchr+0x63>
      return NULL;
    else
      string++;
 8049ad2:	83 c0 01             	add    $0x1,%eax
  char c = c_;

  ASSERT (string != NULL);

  for (;;) 
    if (*string == c)
 8049ad5:	0f b6 10             	movzbl (%eax),%edx
 8049ad8:	38 ca                	cmp    %cl,%dl
 8049ada:	75 f1                	jne    8049acd <strchr+0x4b>
 8049adc:	eb 0c                	jmp    8049aea <strchr+0x68>
      return (char *) string;
    else if (*string == '\0')
      return NULL;
 8049ade:	b8 00 00 00 00       	mov    $0x0,%eax
 8049ae3:	eb 05                	jmp    8049aea <strchr+0x68>
 8049ae5:	b8 00 00 00 00       	mov    $0x0,%eax
    else
      string++;
}
 8049aea:	83 c4 2c             	add    $0x2c,%esp
 8049aed:	c3                   	ret    

08049aee <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
 8049aee:	57                   	push   %edi
 8049aef:	56                   	push   %esi
 8049af0:	53                   	push   %ebx
 8049af1:	83 ec 10             	sub    $0x10,%esp
 8049af4:	8b 74 24 20          	mov    0x20(%esp),%esi
 8049af8:	8b 7c 24 24          	mov    0x24(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
 8049afc:	0f b6 06             	movzbl (%esi),%eax
 8049aff:	bb 00 00 00 00       	mov    $0x0,%ebx
 8049b04:	84 c0                	test   %al,%al
 8049b06:	74 1e                	je     8049b26 <strcspn+0x38>
    if (strchr (stop, string[length]) != NULL)
 8049b08:	0f be c0             	movsbl %al,%eax
 8049b0b:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049b0f:	89 3c 24             	mov    %edi,(%esp)
 8049b12:	e8 6b ff ff ff       	call   8049a82 <strchr>
 8049b17:	85 c0                	test   %eax,%eax
 8049b19:	75 0b                	jne    8049b26 <strcspn+0x38>
size_t
strcspn (const char *string, const char *stop) 
{
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
 8049b1b:	83 c3 01             	add    $0x1,%ebx
 8049b1e:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
 8049b22:	84 c0                	test   %al,%al
 8049b24:	75 e2                	jne    8049b08 <strcspn+0x1a>
    if (strchr (stop, string[length]) != NULL)
      break;
  return length;
}
 8049b26:	89 d8                	mov    %ebx,%eax
 8049b28:	83 c4 10             	add    $0x10,%esp
 8049b2b:	5b                   	pop    %ebx
 8049b2c:	5e                   	pop    %esi
 8049b2d:	5f                   	pop    %edi
 8049b2e:	c3                   	ret    

08049b2f <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
 8049b2f:	56                   	push   %esi
 8049b30:	53                   	push   %ebx
 8049b31:	83 ec 14             	sub    $0x14,%esp
 8049b34:	8b 5c 24 20          	mov    0x20(%esp),%ebx
 8049b38:	8b 74 24 24          	mov    0x24(%esp),%esi
  for (; *string != '\0'; string++)
 8049b3c:	0f b6 03             	movzbl (%ebx),%eax
 8049b3f:	84 c0                	test   %al,%al
 8049b41:	74 24                	je     8049b67 <strpbrk+0x38>
    if (strchr (stop, *string) != NULL)
 8049b43:	0f be c0             	movsbl %al,%eax
 8049b46:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049b4a:	89 34 24             	mov    %esi,(%esp)
 8049b4d:	e8 30 ff ff ff       	call   8049a82 <strchr>
 8049b52:	85 c0                	test   %eax,%eax
 8049b54:	75 16                	jne    8049b6c <strpbrk+0x3d>
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
  for (; *string != '\0'; string++)
 8049b56:	83 c3 01             	add    $0x1,%ebx
 8049b59:	0f b6 03             	movzbl (%ebx),%eax
 8049b5c:	84 c0                	test   %al,%al
 8049b5e:	75 e3                	jne    8049b43 <strpbrk+0x14>
    if (strchr (stop, *string) != NULL)
      return (char *) string;
  return NULL;
 8049b60:	bb 00 00 00 00       	mov    $0x0,%ebx
 8049b65:	eb 05                	jmp    8049b6c <strpbrk+0x3d>
 8049b67:	bb 00 00 00 00       	mov    $0x0,%ebx
}
 8049b6c:	89 d8                	mov    %ebx,%eax
 8049b6e:	83 c4 14             	add    $0x14,%esp
 8049b71:	5b                   	pop    %ebx
 8049b72:	5e                   	pop    %esi
 8049b73:	c3                   	ret    

08049b74 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
 8049b74:	53                   	push   %ebx
 8049b75:	8b 54 24 08          	mov    0x8(%esp),%edx
  char c = c_;
 8049b79:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
  const char *p = NULL;

  for (; *string != '\0'; string++)
 8049b7e:	0f b6 0a             	movzbl (%edx),%ecx
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
  char c = c_;
  const char *p = NULL;
 8049b81:	b8 00 00 00 00       	mov    $0x0,%eax

  for (; *string != '\0'; string++)
 8049b86:	84 c9                	test   %cl,%cl
 8049b88:	74 0f                	je     8049b99 <strrchr+0x25>
    if (*string == c)
 8049b8a:	38 cb                	cmp    %cl,%bl
 8049b8c:	0f 44 c2             	cmove  %edx,%eax
strrchr (const char *string, int c_) 
{
  char c = c_;
  const char *p = NULL;

  for (; *string != '\0'; string++)
 8049b8f:	83 c2 01             	add    $0x1,%edx
 8049b92:	0f b6 0a             	movzbl (%edx),%ecx
 8049b95:	84 c9                	test   %cl,%cl
 8049b97:	75 f1                	jne    8049b8a <strrchr+0x16>
    if (*string == c)
      p = string;
  return (char *) p;
}
 8049b99:	5b                   	pop    %ebx
 8049b9a:	c3                   	ret    

08049b9b <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
 8049b9b:	57                   	push   %edi
 8049b9c:	56                   	push   %esi
 8049b9d:	53                   	push   %ebx
 8049b9e:	83 ec 10             	sub    $0x10,%esp
 8049ba1:	8b 74 24 20          	mov    0x20(%esp),%esi
 8049ba5:	8b 7c 24 24          	mov    0x24(%esp),%edi
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
 8049ba9:	0f b6 06             	movzbl (%esi),%eax
 8049bac:	bb 00 00 00 00       	mov    $0x0,%ebx
 8049bb1:	84 c0                	test   %al,%al
 8049bb3:	74 1e                	je     8049bd3 <strspn+0x38>
    if (strchr (skip, string[length]) == NULL)
 8049bb5:	0f be c0             	movsbl %al,%eax
 8049bb8:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049bbc:	89 3c 24             	mov    %edi,(%esp)
 8049bbf:	e8 be fe ff ff       	call   8049a82 <strchr>
 8049bc4:	85 c0                	test   %eax,%eax
 8049bc6:	74 0b                	je     8049bd3 <strspn+0x38>
size_t
strspn (const char *string, const char *skip) 
{
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
 8049bc8:	83 c3 01             	add    $0x1,%ebx
 8049bcb:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
 8049bcf:	84 c0                	test   %al,%al
 8049bd1:	75 e2                	jne    8049bb5 <strspn+0x1a>
    if (strchr (skip, string[length]) == NULL)
      break;
  return length;
}
 8049bd3:	89 d8                	mov    %ebx,%eax
 8049bd5:	83 c4 10             	add    $0x10,%esp
 8049bd8:	5b                   	pop    %ebx
 8049bd9:	5e                   	pop    %esi
 8049bda:	5f                   	pop    %edi
 8049bdb:	c3                   	ret    

08049bdc <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
 8049bdc:	55                   	push   %ebp
 8049bdd:	57                   	push   %edi
 8049bde:	56                   	push   %esi
 8049bdf:	53                   	push   %ebx
 8049be0:	83 ec 3c             	sub    $0x3c,%esp
 8049be3:	8b 74 24 50          	mov    0x50(%esp),%esi
 8049be7:	8b 7c 24 54          	mov    0x54(%esp),%edi
  char *token;
  
  ASSERT (delimiters != NULL);
 8049beb:	85 ff                	test   %edi,%edi
 8049bed:	75 2c                	jne    8049c1b <strtok_r+0x3f>
 8049bef:	c7 44 24 10 35 ab 04 	movl   $0x804ab35,0x10(%esp)
 8049bf6:	08 
 8049bf7:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 8049bfe:	08 
 8049bff:	c7 44 24 08 bb a8 04 	movl   $0x804a8bb,0x8(%esp)
 8049c06:	08 
 8049c07:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
 8049c0e:	00 
 8049c0f:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 8049c16:	e8 d5 06 00 00       	call   804a2f0 <debug_panic>
  ASSERT (save_ptr != NULL);
 8049c1b:	83 7c 24 58 00       	cmpl   $0x0,0x58(%esp)
 8049c20:	75 2c                	jne    8049c4e <strtok_r+0x72>
 8049c22:	c7 44 24 10 48 ab 04 	movl   $0x804ab48,0x10(%esp)
 8049c29:	08 
 8049c2a:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 8049c31:	08 
 8049c32:	c7 44 24 08 bb a8 04 	movl   $0x804a8bb,0x8(%esp)
 8049c39:	08 
 8049c3a:	c7 44 24 04 f0 00 00 	movl   $0xf0,0x4(%esp)
 8049c41:	00 
 8049c42:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 8049c49:	e8 a2 06 00 00       	call   804a2f0 <debug_panic>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
 8049c4e:	85 f6                	test   %esi,%esi
 8049c50:	75 4a                	jne    8049c9c <strtok_r+0xc0>
    s = *save_ptr;
 8049c52:	8b 44 24 58          	mov    0x58(%esp),%eax
 8049c56:	8b 30                	mov    (%eax),%esi
  ASSERT (s != NULL);
 8049c58:	85 f6                	test   %esi,%esi
 8049c5a:	75 40                	jne    8049c9c <strtok_r+0xc0>
 8049c5c:	c7 44 24 10 3e ab 04 	movl   $0x804ab3e,0x10(%esp)
 8049c63:	08 
 8049c64:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 8049c6b:	08 
 8049c6c:	c7 44 24 08 bb a8 04 	movl   $0x804a8bb,0x8(%esp)
 8049c73:	08 
 8049c74:	c7 44 24 04 f6 00 00 	movl   $0xf6,0x4(%esp)
 8049c7b:	00 
 8049c7c:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 8049c83:	e8 68 06 00 00       	call   804a2f0 <debug_panic>
  while (strchr (delimiters, *s) != NULL) 
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
 8049c88:	84 db                	test   %bl,%bl
 8049c8a:	75 0d                	jne    8049c99 <strtok_r+0xbd>
        {
          *save_ptr = s;
 8049c8c:	8b 54 24 58          	mov    0x58(%esp),%edx
 8049c90:	89 32                	mov    %esi,(%edx)
          return NULL;
 8049c92:	b8 00 00 00 00       	mov    $0x0,%eax
 8049c97:	eb 64                	jmp    8049cfd <strtok_r+0x121>
        }

      s++;
 8049c99:	83 c6 01             	add    $0x1,%esi
  if (s == NULL)
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
 8049c9c:	0f b6 1e             	movzbl (%esi),%ebx
 8049c9f:	0f be c3             	movsbl %bl,%eax
 8049ca2:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049ca6:	89 3c 24             	mov    %edi,(%esp)
 8049ca9:	e8 d4 fd ff ff       	call   8049a82 <strchr>
 8049cae:	85 c0                	test   %eax,%eax
 8049cb0:	75 d6                	jne    8049c88 <strtok_r+0xac>
 8049cb2:	89 f3                	mov    %esi,%ebx
 8049cb4:	eb 04                	jmp    8049cba <strtok_r+0xde>
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
  while (strchr (delimiters, *s) == NULL)
    s++;
 8049cb6:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8049cba:	8d 43 01             	lea    0x1(%ebx),%eax
 8049cbd:	89 44 24 2c          	mov    %eax,0x2c(%esp)
      s++;
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
  while (strchr (delimiters, *s) == NULL)
 8049cc1:	0f b6 6b 01          	movzbl 0x1(%ebx),%ebp
 8049cc5:	89 ea                	mov    %ebp,%edx
 8049cc7:	0f be c2             	movsbl %dl,%eax
 8049cca:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049cce:	89 3c 24             	mov    %edi,(%esp)
 8049cd1:	e8 ac fd ff ff       	call   8049a82 <strchr>
 8049cd6:	85 c0                	test   %eax,%eax
 8049cd8:	74 dc                	je     8049cb6 <strtok_r+0xda>
    s++;
  if (*s != '\0') 
 8049cda:	89 e8                	mov    %ebp,%eax
 8049cdc:	84 c0                	test   %al,%al
 8049cde:	74 11                	je     8049cf1 <strtok_r+0x115>
    {
      *s = '\0';
 8049ce0:	c6 43 01 00          	movb   $0x0,0x1(%ebx)
      *save_ptr = s + 1;
 8049ce4:	83 c3 02             	add    $0x2,%ebx
 8049ce7:	8b 54 24 58          	mov    0x58(%esp),%edx
 8049ceb:	89 1a                	mov    %ebx,(%edx)
 8049ced:	89 f0                	mov    %esi,%eax
 8049cef:	eb 0c                	jmp    8049cfd <strtok_r+0x121>
    }
  else 
    *save_ptr = s;
 8049cf1:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 8049cf5:	8b 44 24 58          	mov    0x58(%esp),%eax
 8049cf9:	89 10                	mov    %edx,(%eax)
 8049cfb:	89 f0                	mov    %esi,%eax
  return token;
}
 8049cfd:	83 c4 3c             	add    $0x3c,%esp
 8049d00:	5b                   	pop    %ebx
 8049d01:	5e                   	pop    %esi
 8049d02:	5f                   	pop    %edi
 8049d03:	5d                   	pop    %ebp
 8049d04:	c3                   	ret    

08049d05 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
 8049d05:	53                   	push   %ebx
 8049d06:	83 ec 28             	sub    $0x28,%esp
 8049d09:	8b 44 24 30          	mov    0x30(%esp),%eax
 8049d0d:	8b 5c 24 34          	mov    0x34(%esp),%ebx
 8049d11:	8b 54 24 38          	mov    0x38(%esp),%edx
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
 8049d15:	85 c0                	test   %eax,%eax
 8049d17:	75 04                	jne    8049d1d <memset+0x18>
 8049d19:	85 d2                	test   %edx,%edx
 8049d1b:	75 08                	jne    8049d25 <memset+0x20>
  
  while (size-- > 0)
 8049d1d:	89 c1                	mov    %eax,%ecx
 8049d1f:	85 d2                	test   %edx,%edx
 8049d21:	75 2e                	jne    8049d51 <memset+0x4c>
 8049d23:	eb 36                	jmp    8049d5b <memset+0x56>
void *
memset (void *dst_, int value, size_t size) 
{
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
 8049d25:	c7 44 24 10 6d aa 04 	movl   $0x804aa6d,0x10(%esp)
 8049d2c:	08 
 8049d2d:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 8049d34:	08 
 8049d35:	c7 44 24 08 c4 a8 04 	movl   $0x804a8c4,0x8(%esp)
 8049d3c:	08 
 8049d3d:	c7 44 24 04 1b 01 00 	movl   $0x11b,0x4(%esp)
 8049d44:	00 
 8049d45:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 8049d4c:	e8 9f 05 00 00       	call   804a2f0 <debug_panic>
  
  while (size-- > 0)
    *dst++ = value;
 8049d51:	88 19                	mov    %bl,(%ecx)
 8049d53:	83 c1 01             	add    $0x1,%ecx
{
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
 8049d56:	83 ea 01             	sub    $0x1,%edx
 8049d59:	75 f6                	jne    8049d51 <memset+0x4c>
    *dst++ = value;

  return dst_;
}
 8049d5b:	83 c4 28             	add    $0x28,%esp
 8049d5e:	5b                   	pop    %ebx
 8049d5f:	c3                   	ret    

08049d60 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
 8049d60:	83 ec 2c             	sub    $0x2c,%esp
 8049d63:	8b 54 24 30          	mov    0x30(%esp),%edx
  const char *p;

  ASSERT (string != NULL);
 8049d67:	85 d2                	test   %edx,%edx
 8049d69:	74 09                	je     8049d74 <strlen+0x14>

  for (p = string; *p != '\0'; p++)
 8049d6b:	89 d0                	mov    %edx,%eax
 8049d6d:	80 3a 00             	cmpb   $0x0,(%edx)
 8049d70:	75 2e                	jne    8049da0 <strlen+0x40>
 8049d72:	eb 34                	jmp    8049da8 <strlen+0x48>
size_t
strlen (const char *string) 
{
  const char *p;

  ASSERT (string != NULL);
 8049d74:	c7 44 24 10 26 ab 04 	movl   $0x804ab26,0x10(%esp)
 8049d7b:	08 
 8049d7c:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 8049d83:	08 
 8049d84:	c7 44 24 08 cb a8 04 	movl   $0x804a8cb,0x8(%esp)
 8049d8b:	08 
 8049d8c:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
 8049d93:	00 
 8049d94:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 8049d9b:	e8 50 05 00 00       	call   804a2f0 <debug_panic>

  for (p = string; *p != '\0'; p++)
 8049da0:	83 c0 01             	add    $0x1,%eax
 8049da3:	80 38 00             	cmpb   $0x0,(%eax)
 8049da6:	75 f8                	jne    8049da0 <strlen+0x40>
    continue;
  return p - string;
 8049da8:	29 d0                	sub    %edx,%eax
}
 8049daa:	83 c4 2c             	add    $0x2c,%esp
 8049dad:	c3                   	ret    

08049dae <strstr>:
/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
{
 8049dae:	55                   	push   %ebp
 8049daf:	57                   	push   %edi
 8049db0:	56                   	push   %esi
 8049db1:	53                   	push   %ebx
 8049db2:	83 ec 2c             	sub    $0x2c,%esp
 8049db5:	8b 6c 24 44          	mov    0x44(%esp),%ebp
  size_t haystack_len = strlen (haystack);
 8049db9:	ba ff ff ff ff       	mov    $0xffffffff,%edx
 8049dbe:	8b 7c 24 40          	mov    0x40(%esp),%edi
 8049dc2:	b8 00 00 00 00       	mov    $0x0,%eax
 8049dc7:	89 d1                	mov    %edx,%ecx
 8049dc9:	f2 ae                	repnz scas %es:(%edi),%al
 8049dcb:	f7 d1                	not    %ecx
 8049dcd:	8d 59 ff             	lea    -0x1(%ecx),%ebx
  size_t needle_len = strlen (needle);
 8049dd0:	89 ef                	mov    %ebp,%edi
 8049dd2:	89 d1                	mov    %edx,%ecx
 8049dd4:	f2 ae                	repnz scas %es:(%edi),%al
 8049dd6:	89 ca                	mov    %ecx,%edx
 8049dd8:	f7 d2                	not    %edx
 8049dda:	8d 7a ff             	lea    -0x1(%edx),%edi
      for (i = 0; i <= haystack_len - needle_len; i++)
        if (!memcmp (haystack + i, needle, needle_len))
          return (char *) haystack + i;
    }

  return NULL;
 8049ddd:	be 00 00 00 00       	mov    $0x0,%esi
strstr (const char *haystack, const char *needle) 
{
  size_t haystack_len = strlen (haystack);
  size_t needle_len = strlen (needle);

  if (haystack_len >= needle_len) 
 8049de2:	39 fb                	cmp    %edi,%ebx
 8049de4:	72 33                	jb     8049e19 <strstr+0x6b>
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
 8049de6:	29 fb                	sub    %edi,%ebx
 8049de8:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
 8049dec:	bb 00 00 00 00       	mov    $0x0,%ebx

/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
 8049df1:	8b 74 24 40          	mov    0x40(%esp),%esi
 8049df5:	01 de                	add    %ebx,%esi
  if (haystack_len >= needle_len) 
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
        if (!memcmp (haystack + i, needle, needle_len))
 8049df7:	89 7c 24 08          	mov    %edi,0x8(%esp)
 8049dfb:	89 6c 24 04          	mov    %ebp,0x4(%esp)
 8049dff:	89 34 24             	mov    %esi,(%esp)
 8049e02:	e8 a0 fa ff ff       	call   80498a7 <memcmp>
 8049e07:	85 c0                	test   %eax,%eax
 8049e09:	74 0e                	je     8049e19 <strstr+0x6b>

  if (haystack_len >= needle_len) 
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
 8049e0b:	83 c3 01             	add    $0x1,%ebx
 8049e0e:	3b 5c 24 1c          	cmp    0x1c(%esp),%ebx
 8049e12:	76 dd                	jbe    8049df1 <strstr+0x43>
        if (!memcmp (haystack + i, needle, needle_len))
          return (char *) haystack + i;
    }

  return NULL;
 8049e14:	be 00 00 00 00       	mov    $0x0,%esi
}
 8049e19:	89 f0                	mov    %esi,%eax
 8049e1b:	83 c4 2c             	add    $0x2c,%esp
 8049e1e:	5b                   	pop    %ebx
 8049e1f:	5e                   	pop    %esi
 8049e20:	5f                   	pop    %edi
 8049e21:	5d                   	pop    %ebp
 8049e22:	c3                   	ret    

08049e23 <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
 8049e23:	8b 54 24 04          	mov    0x4(%esp),%edx
 8049e27:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
 8049e2b:	80 3a 00             	cmpb   $0x0,(%edx)
 8049e2e:	74 18                	je     8049e48 <strnlen+0x25>
 8049e30:	85 c9                	test   %ecx,%ecx
 8049e32:	74 14                	je     8049e48 <strnlen+0x25>
 8049e34:	b8 00 00 00 00       	mov    $0x0,%eax
 8049e39:	83 c0 01             	add    $0x1,%eax
 8049e3c:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
 8049e40:	74 0b                	je     8049e4d <strnlen+0x2a>
 8049e42:	39 c1                	cmp    %eax,%ecx
 8049e44:	77 f3                	ja     8049e39 <strnlen+0x16>
 8049e46:	f3 c3                	repz ret 
 8049e48:	b8 00 00 00 00       	mov    $0x0,%eax
 8049e4d:	8d 76 00             	lea    0x0(%esi),%esi
    continue;
  return length;
}
 8049e50:	f3 c3                	repz ret 

08049e52 <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
 8049e52:	83 ec 3c             	sub    $0x3c,%esp
 8049e55:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
 8049e59:	89 74 24 30          	mov    %esi,0x30(%esp)
 8049e5d:	89 7c 24 34          	mov    %edi,0x34(%esp)
 8049e61:	89 6c 24 38          	mov    %ebp,0x38(%esp)
 8049e65:	8b 6c 24 40          	mov    0x40(%esp),%ebp
 8049e69:	8b 54 24 44          	mov    0x44(%esp),%edx
 8049e6d:	8b 5c 24 48          	mov    0x48(%esp),%ebx
  size_t src_len;

  ASSERT (dst != NULL);
 8049e71:	85 ed                	test   %ebp,%ebp
 8049e73:	75 2c                	jne    8049ea1 <strlcpy+0x4f>
 8049e75:	c7 44 24 10 59 ab 04 	movl   $0x804ab59,0x10(%esp)
 8049e7c:	08 
 8049e7d:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 8049e84:	08 
 8049e85:	c7 44 24 08 d2 a8 04 	movl   $0x804a8d2,0x8(%esp)
 8049e8c:	08 
 8049e8d:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
 8049e94:	00 
 8049e95:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 8049e9c:	e8 4f 04 00 00       	call   804a2f0 <debug_panic>
  ASSERT (src != NULL);
 8049ea1:	85 d2                	test   %edx,%edx
 8049ea3:	75 2c                	jne    8049ed1 <strlcpy+0x7f>
 8049ea5:	c7 44 24 10 65 ab 04 	movl   $0x804ab65,0x10(%esp)
 8049eac:	08 
 8049ead:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 8049eb4:	08 
 8049eb5:	c7 44 24 08 d2 a8 04 	movl   $0x804a8d2,0x8(%esp)
 8049ebc:	08 
 8049ebd:	c7 44 24 04 4b 01 00 	movl   $0x14b,0x4(%esp)
 8049ec4:	00 
 8049ec5:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 8049ecc:	e8 1f 04 00 00       	call   804a2f0 <debug_panic>

  src_len = strlen (src);
 8049ed1:	89 d7                	mov    %edx,%edi
 8049ed3:	b8 00 00 00 00       	mov    $0x0,%eax
 8049ed8:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 8049edd:	f2 ae                	repnz scas %es:(%edi),%al
 8049edf:	f7 d1                	not    %ecx
 8049ee1:	8d 71 ff             	lea    -0x1(%ecx),%esi
  if (size > 0) 
 8049ee4:	85 db                	test   %ebx,%ebx
 8049ee6:	74 1d                	je     8049f05 <strlcpy+0xb3>
    {
      size_t dst_len = size - 1;
 8049ee8:	83 eb 01             	sub    $0x1,%ebx
 8049eeb:	39 de                	cmp    %ebx,%esi
 8049eed:	0f 46 de             	cmovbe %esi,%ebx
      if (src_len < dst_len)
        dst_len = src_len;
      memcpy (dst, src, dst_len);
 8049ef0:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 8049ef4:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049ef8:	89 2c 24             	mov    %ebp,(%esp)
 8049efb:	e8 40 f8 ff ff       	call   8049740 <memcpy>
      dst[dst_len] = '\0';
 8049f00:	c6 44 1d 00 00       	movb   $0x0,0x0(%ebp,%ebx,1)
    }
  return src_len;
}
 8049f05:	89 f0                	mov    %esi,%eax
 8049f07:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8049f0b:	8b 74 24 30          	mov    0x30(%esp),%esi
 8049f0f:	8b 7c 24 34          	mov    0x34(%esp),%edi
 8049f13:	8b 6c 24 38          	mov    0x38(%esp),%ebp
 8049f17:	83 c4 3c             	add    $0x3c,%esp
 8049f1a:	c3                   	ret    

08049f1b <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
 8049f1b:	83 ec 3c             	sub    $0x3c,%esp
 8049f1e:	89 5c 24 2c          	mov    %ebx,0x2c(%esp)
 8049f22:	89 74 24 30          	mov    %esi,0x30(%esp)
 8049f26:	89 7c 24 34          	mov    %edi,0x34(%esp)
 8049f2a:	89 6c 24 38          	mov    %ebp,0x38(%esp)
 8049f2e:	8b 5c 24 40          	mov    0x40(%esp),%ebx
 8049f32:	8b 54 24 44          	mov    0x44(%esp),%edx
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
 8049f36:	85 db                	test   %ebx,%ebx
 8049f38:	75 2c                	jne    8049f66 <strlcat+0x4b>
 8049f3a:	c7 44 24 10 59 ab 04 	movl   $0x804ab59,0x10(%esp)
 8049f41:	08 
 8049f42:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 8049f49:	08 
 8049f4a:	c7 44 24 08 da a8 04 	movl   $0x804a8da,0x8(%esp)
 8049f51:	08 
 8049f52:	c7 44 24 04 68 01 00 	movl   $0x168,0x4(%esp)
 8049f59:	00 
 8049f5a:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 8049f61:	e8 8a 03 00 00       	call   804a2f0 <debug_panic>
  ASSERT (src != NULL);
 8049f66:	85 d2                	test   %edx,%edx
 8049f68:	75 2c                	jne    8049f96 <strlcat+0x7b>
 8049f6a:	c7 44 24 10 65 ab 04 	movl   $0x804ab65,0x10(%esp)
 8049f71:	08 
 8049f72:	c7 44 24 0c 86 aa 04 	movl   $0x804aa86,0xc(%esp)
 8049f79:	08 
 8049f7a:	c7 44 24 08 da a8 04 	movl   $0x804a8da,0x8(%esp)
 8049f81:	08 
 8049f82:	c7 44 24 04 69 01 00 	movl   $0x169,0x4(%esp)
 8049f89:	00 
 8049f8a:	c7 04 24 9d aa 04 08 	movl   $0x804aa9d,(%esp)
 8049f91:	e8 5a 03 00 00       	call   804a2f0 <debug_panic>

  src_len = strlen (src);
 8049f96:	be ff ff ff ff       	mov    $0xffffffff,%esi
 8049f9b:	89 d7                	mov    %edx,%edi
 8049f9d:	b8 00 00 00 00       	mov    $0x0,%eax
 8049fa2:	89 f1                	mov    %esi,%ecx
 8049fa4:	f2 ae                	repnz scas %es:(%edi),%al
 8049fa6:	f7 d1                	not    %ecx
 8049fa8:	8d 69 ff             	lea    -0x1(%ecx),%ebp
  dst_len = strlen (dst);
 8049fab:	89 df                	mov    %ebx,%edi
 8049fad:	89 f1                	mov    %esi,%ecx
 8049faf:	f2 ae                	repnz scas %es:(%edi),%al
 8049fb1:	89 ce                	mov    %ecx,%esi
 8049fb3:	f7 d6                	not    %esi
 8049fb5:	83 ee 01             	sub    $0x1,%esi
  if (size > 0 && dst_len < size) 
 8049fb8:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
 8049fbd:	74 2a                	je     8049fe9 <strlcat+0xce>
 8049fbf:	3b 74 24 48          	cmp    0x48(%esp),%esi
 8049fc3:	73 24                	jae    8049fe9 <strlcat+0xce>
    {
      size_t copy_cnt = size - dst_len - 1;
 8049fc5:	8b 7c 24 48          	mov    0x48(%esp),%edi
 8049fc9:	83 ef 01             	sub    $0x1,%edi
 8049fcc:	29 f7                	sub    %esi,%edi
 8049fce:	39 ef                	cmp    %ebp,%edi
 8049fd0:	0f 47 fd             	cmova  %ebp,%edi
      if (src_len < copy_cnt)
        copy_cnt = src_len;
      memcpy (dst + dst_len, src, copy_cnt);
 8049fd3:	01 f3                	add    %esi,%ebx
 8049fd5:	89 7c 24 08          	mov    %edi,0x8(%esp)
 8049fd9:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049fdd:	89 1c 24             	mov    %ebx,(%esp)
 8049fe0:	e8 5b f7 ff ff       	call   8049740 <memcpy>
      dst[dst_len + copy_cnt] = '\0';
 8049fe5:	c6 04 3b 00          	movb   $0x0,(%ebx,%edi,1)
    }
  return src_len + dst_len;
 8049fe9:	8d 04 2e             	lea    (%esi,%ebp,1),%eax
}
 8049fec:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 8049ff0:	8b 74 24 30          	mov    0x30(%esp),%esi
 8049ff4:	8b 7c 24 34          	mov    0x34(%esp),%edi
 8049ff8:	8b 6c 24 38          	mov    0x38(%esp),%ebp
 8049ffc:	83 c4 3c             	add    $0x3c,%esp
 8049fff:	c3                   	ret    

0804a000 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
 804a000:	83 ec 2c             	sub    $0x2c,%esp
 804a003:	89 5c 24 1c          	mov    %ebx,0x1c(%esp)
 804a007:	89 74 24 20          	mov    %esi,0x20(%esp)
 804a00b:	89 7c 24 24          	mov    %edi,0x24(%esp)
 804a00f:	89 6c 24 28          	mov    %ebp,0x28(%esp)
 804a013:	89 c6                	mov    %eax,%esi
 804a015:	89 d7                	mov    %edx,%edi
 804a017:	8b 44 24 30          	mov    0x30(%esp),%eax
 804a01b:	8b 54 24 34          	mov    0x34(%esp),%edx
 804a01f:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a023:	89 54 24 0c          	mov    %edx,0xc(%esp)
  if ((d >> 32) == 0) 
 804a027:	89 d0                	mov    %edx,%eax
 804a029:	85 d2                	test   %edx,%edx
 804a02b:	75 3c                	jne    804a069 <udiv64+0x69>
             <=> [b - 1/d] < b
         which is a tautology.

         Therefore, this code is correct and will not trap. */
      uint64_t b = 1ULL << 32;
      uint32_t n1 = n >> 32;
 804a02d:	89 f8                	mov    %edi,%eax
      uint32_t n0 = n; 
      uint32_t d0 = d;
 804a02f:	8b 6c 24 08          	mov    0x8(%esp),%ebp

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
 804a033:	ba 00 00 00 00       	mov    $0x0,%edx
 804a038:	f7 f5                	div    %ebp
 804a03a:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a03e:	b9 00 00 00 00       	mov    $0x0,%ecx
 804a043:	bf 00 00 00 00       	mov    $0x0,%edi
 804a048:	01 ce                	add    %ecx,%esi
 804a04a:	11 d7                	adc    %edx,%edi
{
  uint32_t n1 = n >> 32;
  uint32_t n0 = n;
  uint32_t q, r;

  asm ("divl %4"
 804a04c:	89 fa                	mov    %edi,%edx
 804a04e:	89 f0                	mov    %esi,%eax
 804a050:	f7 f5                	div    %ebp
      uint64_t b = 1ULL << 32;
      uint32_t n1 = n >> 32;
      uint32_t n0 = n; 
      uint32_t d0 = d;

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
 804a052:	bf 00 00 00 00       	mov    $0x0,%edi
 804a057:	8b 5c 24 08          	mov    0x8(%esp),%ebx
 804a05b:	b9 00 00 00 00       	mov    $0x0,%ecx
 804a060:	01 c1                	add    %eax,%ecx
 804a062:	11 fb                	adc    %edi,%ebx
 804a064:	e9 fe 00 00 00       	jmp    804a167 <udiv64+0x167>
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
 804a069:	39 7c 24 0c          	cmp    %edi,0xc(%esp)
 804a06d:	0f 87 ea 00 00 00    	ja     804a15d <udiv64+0x15d>
 804a073:	72 0a                	jb     804a07f <udiv64+0x7f>
 804a075:	39 74 24 08          	cmp    %esi,0x8(%esp)
 804a079:	0f 87 de 00 00 00    	ja     804a15d <udiv64+0x15d>
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
 804a07f:	89 c2                	mov    %eax,%edx
  /* This technique is portable, but there are better ways to do
     it on particular systems.  With sufficiently new enough GCC,
     you can use __builtin_clz() to take advantage of GCC's
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
 804a081:	b9 00 00 00 00       	mov    $0x0,%ecx
  if (x <= 0x0000FFFF)
 804a086:	3d ff ff 00 00       	cmp    $0xffff,%eax
 804a08b:	77 05                	ja     804a092 <udiv64+0x92>
    {
      n += 16;
      x <<= 16; 
 804a08d:	c1 e2 10             	shl    $0x10,%edx
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
  if (x <= 0x0000FFFF)
    {
      n += 16;
 804a090:	b1 10                	mov    $0x10,%cl
      x <<= 16; 
    }
  if (x <= 0x00FFFFFF)
 804a092:	81 fa ff ff ff 00    	cmp    $0xffffff,%edx
 804a098:	77 06                	ja     804a0a0 <udiv64+0xa0>
    {
      n += 8;
 804a09a:	83 c1 08             	add    $0x8,%ecx
      x <<= 8; 
 804a09d:	c1 e2 08             	shl    $0x8,%edx
    }
  if (x <= 0x0FFFFFFF)
 804a0a0:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
 804a0a6:	77 06                	ja     804a0ae <udiv64+0xae>
    {
      n += 4;
 804a0a8:	83 c1 04             	add    $0x4,%ecx
      x <<= 4;
 804a0ab:	c1 e2 04             	shl    $0x4,%edx
    }
  if (x <= 0x3FFFFFFF)
 804a0ae:	81 fa ff ff ff 3f    	cmp    $0x3fffffff,%edx
 804a0b4:	77 06                	ja     804a0bc <udiv64+0xbc>
    {
      n += 2;
 804a0b6:	83 c1 02             	add    $0x2,%ecx
      x <<= 2; 
 804a0b9:	c1 e2 02             	shl    $0x2,%edx
    }
  if (x <= 0x7FFFFFFF)
    n++;
 804a0bc:	81 fa 00 00 00 80    	cmp    $0x80000000,%edx
 804a0c2:	83 d1 00             	adc    $0x0,%ecx
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
 804a0c5:	89 f0                	mov    %esi,%eax
 804a0c7:	89 fa                	mov    %edi,%edx
 804a0c9:	0f ac f8 01          	shrd   $0x1,%edi,%eax
 804a0cd:	d1 ea                	shr    %edx
 804a0cf:	89 04 24             	mov    %eax,(%esp)
 804a0d2:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a0d6:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a0da:	8b 54 24 0c          	mov    0xc(%esp),%edx
 804a0de:	0f a5 c2             	shld   %cl,%eax,%edx
 804a0e1:	d3 e0                	shl    %cl,%eax
 804a0e3:	f6 c1 20             	test   $0x20,%cl
 804a0e6:	74 02                	je     804a0ea <udiv64+0xea>
 804a0e8:	89 c2                	mov    %eax,%edx
 804a0ea:	89 54 24 14          	mov    %edx,0x14(%esp)
{
  uint32_t n1 = n >> 32;
  uint32_t n0 = n;
  uint32_t q, r;

  asm ("divl %4"
 804a0ee:	8b 54 24 04          	mov    0x4(%esp),%edx
 804a0f2:	8b 04 24             	mov    (%esp),%eax
 804a0f5:	f7 74 24 14          	divl   0x14(%esp)
        return 0;
      else 
        {
          uint32_t d1 = d >> 32;
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
 804a0f9:	ba 1f 00 00 00       	mov    $0x1f,%edx
 804a0fe:	29 ca                	sub    %ecx,%edx
 804a100:	89 d1                	mov    %edx,%ecx
 804a102:	d3 e8                	shr    %cl,%eax
 804a104:	89 44 24 10          	mov    %eax,0x10(%esp)
 804a108:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804a10f:	00 
          return n - (q - 1) * d < d ? q - 1 : q; 
 804a110:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 804a114:	8b 5c 24 14          	mov    0x14(%esp),%ebx
 804a118:	83 c1 ff             	add    $0xffffffff,%ecx
 804a11b:	83 d3 ff             	adc    $0xffffffff,%ebx
 804a11e:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a122:	0f af c3             	imul   %ebx,%eax
 804a125:	8b 54 24 0c          	mov    0xc(%esp),%edx
 804a129:	0f af d1             	imul   %ecx,%edx
 804a12c:	8d 2c 10             	lea    (%eax,%edx,1),%ebp
 804a12f:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a133:	f7 e1                	mul    %ecx
 804a135:	89 04 24             	mov    %eax,(%esp)
 804a138:	01 ea                	add    %ebp,%edx
 804a13a:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a13e:	2b 34 24             	sub    (%esp),%esi
 804a141:	1b 7c 24 04          	sbb    0x4(%esp),%edi
 804a145:	39 7c 24 0c          	cmp    %edi,0xc(%esp)
 804a149:	77 1c                	ja     804a167 <udiv64+0x167>
 804a14b:	72 06                	jb     804a153 <udiv64+0x153>
 804a14d:	39 74 24 08          	cmp    %esi,0x8(%esp)
 804a151:	77 14                	ja     804a167 <udiv64+0x167>
 804a153:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 804a157:	8b 5c 24 14          	mov    0x14(%esp),%ebx
 804a15b:	eb 0a                	jmp    804a167 <udiv64+0x167>
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
        return 0;
 804a15d:	b9 00 00 00 00       	mov    $0x0,%ecx
 804a162:	bb 00 00 00 00       	mov    $0x0,%ebx
          int s = nlz (d1);
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
          return n - (q - 1) * d < d ? q - 1 : q; 
        }
    }
}
 804a167:	89 c8                	mov    %ecx,%eax
 804a169:	89 da                	mov    %ebx,%edx
 804a16b:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
 804a16f:	8b 74 24 20          	mov    0x20(%esp),%esi
 804a173:	8b 7c 24 24          	mov    0x24(%esp),%edi
 804a177:	8b 6c 24 28          	mov    0x28(%esp),%ebp
 804a17b:	83 c4 2c             	add    $0x2c,%esp
 804a17e:	c3                   	ret    

0804a17f <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
 804a17f:	83 ec 1c             	sub    $0x1c,%esp
 804a182:	89 5c 24 10          	mov    %ebx,0x10(%esp)
 804a186:	89 74 24 14          	mov    %esi,0x14(%esp)
 804a18a:	89 7c 24 18          	mov    %edi,0x18(%esp)
 804a18e:	89 c6                	mov    %eax,%esi
 804a190:	89 d7                	mov    %edx,%edi
 804a192:	8b 44 24 20          	mov    0x20(%esp),%eax
 804a196:	8b 54 24 24          	mov    0x24(%esp),%edx
 804a19a:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a19e:	89 54 24 0c          	mov    %edx,0xc(%esp)
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
 804a1a2:	89 f0                	mov    %esi,%eax
 804a1a4:	89 fa                	mov    %edi,%edx
 804a1a6:	f7 d8                	neg    %eax
 804a1a8:	83 d2 00             	adc    $0x0,%edx
 804a1ab:	f7 da                	neg    %edx
 804a1ad:	85 ff                	test   %edi,%edi
 804a1af:	78 04                	js     804a1b5 <sdiv64+0x36>
 804a1b1:	89 f0                	mov    %esi,%eax
 804a1b3:	89 fa                	mov    %edi,%edx
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
 804a1b5:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 804a1b9:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
 804a1bd:	f7 d9                	neg    %ecx
 804a1bf:	83 d3 00             	adc    $0x0,%ebx
 804a1c2:	f7 db                	neg    %ebx
 804a1c4:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
 804a1c9:	78 08                	js     804a1d3 <sdiv64+0x54>
 804a1cb:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 804a1cf:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  uint64_t q_abs = udiv64 (n_abs, d_abs);
 804a1d3:	89 0c 24             	mov    %ecx,(%esp)
 804a1d6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804a1da:	e8 21 fe ff ff       	call   804a000 <udiv64>
 804a1df:	89 c1                	mov    %eax,%ecx
 804a1e1:	89 d3                	mov    %edx,%ebx
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
 804a1e3:	f7 d7                	not    %edi
 804a1e5:	c1 ef 1f             	shr    $0x1f,%edi
 804a1e8:	8b 74 24 0c          	mov    0xc(%esp),%esi
 804a1ec:	c1 ee 1f             	shr    $0x1f,%esi
 804a1ef:	f7 d8                	neg    %eax
 804a1f1:	83 d2 00             	adc    $0x0,%edx
 804a1f4:	f7 da                	neg    %edx
 804a1f6:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a1fa:	89 54 24 0c          	mov    %edx,0xc(%esp)
 804a1fe:	89 fa                	mov    %edi,%edx
 804a200:	89 f0                	mov    %esi,%eax
 804a202:	38 c2                	cmp    %al,%dl
 804a204:	74 08                	je     804a20e <sdiv64+0x8f>
 804a206:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804a20a:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
}
 804a20e:	8b 44 24 08          	mov    0x8(%esp),%eax
 804a212:	8b 54 24 0c          	mov    0xc(%esp),%edx
 804a216:	8b 5c 24 10          	mov    0x10(%esp),%ebx
 804a21a:	8b 74 24 14          	mov    0x14(%esp),%esi
 804a21e:	8b 7c 24 18          	mov    0x18(%esp),%edi
 804a222:	83 c4 1c             	add    $0x1c,%esp
 804a225:	c3                   	ret    

0804a226 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
 804a226:	83 ec 0c             	sub    $0xc,%esp
  return sdiv64 (n, d);
 804a229:	8b 44 24 18          	mov    0x18(%esp),%eax
 804a22d:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 804a231:	89 04 24             	mov    %eax,(%esp)
 804a234:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a238:	8b 44 24 10          	mov    0x10(%esp),%eax
 804a23c:	8b 54 24 14          	mov    0x14(%esp),%edx
 804a240:	e8 3a ff ff ff       	call   804a17f <sdiv64>
}
 804a245:	83 c4 0c             	add    $0xc,%esp
 804a248:	c3                   	ret    

0804a249 <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
 804a249:	83 ec 14             	sub    $0x14,%esp
 804a24c:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 804a250:	89 74 24 10          	mov    %esi,0x10(%esp)
 804a254:	8b 74 24 18          	mov    0x18(%esp),%esi
 804a258:	8b 5c 24 20          	mov    0x20(%esp),%ebx
/* Divides signed 64-bit N by signed 64-bit D and returns the
   remainder. */
static int32_t
smod64 (int64_t n, int64_t d)
{
  return n - d * sdiv64 (n, d);
 804a25c:	89 1c 24             	mov    %ebx,(%esp)
 804a25f:	8b 44 24 24          	mov    0x24(%esp),%eax
 804a263:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a267:	89 f0                	mov    %esi,%eax
 804a269:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 804a26d:	e8 0d ff ff ff       	call   804a17f <sdiv64>
 804a272:	0f af d8             	imul   %eax,%ebx
 804a275:	89 f0                	mov    %esi,%eax
 804a277:	29 d8                	sub    %ebx,%eax

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
  return smod64 (n, d);
 804a279:	89 c2                	mov    %eax,%edx
 804a27b:	c1 fa 1f             	sar    $0x1f,%edx
}
 804a27e:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
 804a282:	8b 74 24 10          	mov    0x10(%esp),%esi
 804a286:	83 c4 14             	add    $0x14,%esp
 804a289:	c3                   	ret    

0804a28a <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
 804a28a:	83 ec 0c             	sub    $0xc,%esp
  return udiv64 (n, d);
 804a28d:	8b 44 24 18          	mov    0x18(%esp),%eax
 804a291:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 804a295:	89 04 24             	mov    %eax,(%esp)
 804a298:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a29c:	8b 44 24 10          	mov    0x10(%esp),%eax
 804a2a0:	8b 54 24 14          	mov    0x14(%esp),%edx
 804a2a4:	e8 57 fd ff ff       	call   804a000 <udiv64>
}
 804a2a9:	83 c4 0c             	add    $0xc,%esp
 804a2ac:	c3                   	ret    

0804a2ad <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
 804a2ad:	83 ec 14             	sub    $0x14,%esp
 804a2b0:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 804a2b4:	89 74 24 10          	mov    %esi,0x10(%esp)
 804a2b8:	8b 74 24 18          	mov    0x18(%esp),%esi
 804a2bc:	8b 5c 24 20          	mov    0x20(%esp),%ebx
/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   remainder. */
static uint32_t
umod64 (uint64_t n, uint64_t d)
{
  return n - d * udiv64 (n, d);
 804a2c0:	89 1c 24             	mov    %ebx,(%esp)
 804a2c3:	8b 44 24 24          	mov    0x24(%esp),%eax
 804a2c7:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a2cb:	89 f0                	mov    %esi,%eax
 804a2cd:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 804a2d1:	e8 2a fd ff ff       	call   804a000 <udiv64>
 804a2d6:	0f af d8             	imul   %eax,%ebx
 804a2d9:	89 f0                	mov    %esi,%eax
 804a2db:	29 d8                	sub    %ebx,%eax
/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
  return umod64 (n, d);
}
 804a2dd:	ba 00 00 00 00       	mov    $0x0,%edx
 804a2e2:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
 804a2e6:	8b 74 24 10          	mov    0x10(%esp),%esi
 804a2ea:	83 c4 14             	add    $0x14,%esp
 804a2ed:	c3                   	ret    
 804a2ee:	90                   	nop
 804a2ef:	90                   	nop

0804a2f0 <debug_panic>:
/* Aborts the user program, printing the source file name, line
   number, and function name, plus a user-specific message. */
void
debug_panic (const char *file, int line, const char *function,
             const char *message, ...)
{
 804a2f0:	83 ec 1c             	sub    $0x1c,%esp
  va_list args;

  printf ("User process ABORT at %s:%d in %s(): ", file, line, function);
 804a2f3:	8b 44 24 28          	mov    0x28(%esp),%eax
 804a2f7:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804a2fb:	8b 44 24 24          	mov    0x24(%esp),%eax
 804a2ff:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a303:	8b 44 24 20          	mov    0x20(%esp),%eax
 804a307:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a30b:	c7 04 24 0c ad 04 08 	movl   $0x804ad0c,(%esp)
 804a312:	e8 89 e9 ff ff       	call   8048ca0 <printf>

  va_start (args, message);
 804a317:	8d 44 24 30          	lea    0x30(%esp),%eax
  vprintf (message, args);
 804a31b:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a31f:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 804a323:	89 04 24             	mov    %eax,(%esp)
 804a326:	e8 d0 02 00 00       	call   804a5fb <vprintf>
  printf ("\n");
 804a32b:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 804a332:	e8 e1 01 00 00       	call   804a518 <putchar>
  va_end (args);

  debug_backtrace ();
 804a337:	e8 e4 02 00 00       	call   804a620 <debug_backtrace>
  
  exit (1);
 804a33c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a343:	e8 2e 00 00 00       	call   804a376 <exit>

0804a348 <halt>:
          retval;                                               \
        })

void
halt (void) 
{
 804a348:	83 ec 1c             	sub    $0x1c,%esp
  syscall0 (SYS_HALT);
 804a34b:	6a 00                	push   $0x0
 804a34d:	cd 30                	int    $0x30
 804a34f:	83 c4 04             	add    $0x4,%esp
  NOT_REACHED ();
 804a352:	c7 44 24 0c e8 ac 04 	movl   $0x804ace8,0xc(%esp)
 804a359:	08 
 804a35a:	c7 44 24 08 e2 a8 04 	movl   $0x804a8e2,0x8(%esp)
 804a361:	08 
 804a362:	c7 44 24 04 44 00 00 	movl   $0x44,0x4(%esp)
 804a369:	00 
 804a36a:	c7 04 24 71 ab 04 08 	movl   $0x804ab71,(%esp)
 804a371:	e8 7a ff ff ff       	call   804a2f0 <debug_panic>

0804a376 <exit>:
}

void
exit (int status)
{
 804a376:	83 ec 1c             	sub    $0x1c,%esp
  syscall1 (SYS_EXIT, status);
 804a379:	ff 74 24 20          	pushl  0x20(%esp)
 804a37d:	6a 01                	push   $0x1
 804a37f:	cd 30                	int    $0x30
 804a381:	83 c4 08             	add    $0x8,%esp
  NOT_REACHED ();
 804a384:	c7 44 24 0c e8 ac 04 	movl   $0x804ace8,0xc(%esp)
 804a38b:	08 
 804a38c:	c7 44 24 08 e7 a8 04 	movl   $0x804a8e7,0x8(%esp)
 804a393:	08 
 804a394:	c7 44 24 04 4b 00 00 	movl   $0x4b,0x4(%esp)
 804a39b:	00 
 804a39c:	c7 04 24 71 ab 04 08 	movl   $0x804ab71,(%esp)
 804a3a3:	e8 48 ff ff ff       	call   804a2f0 <debug_panic>

0804a3a8 <exec>:
}

pid_t
exec (const char *file)
{
  return (pid_t) syscall1 (SYS_EXEC, file);
 804a3a8:	ff 74 24 04          	pushl  0x4(%esp)
 804a3ac:	6a 02                	push   $0x2
 804a3ae:	cd 30                	int    $0x30
 804a3b0:	83 c4 08             	add    $0x8,%esp
}
 804a3b3:	c3                   	ret    

0804a3b4 <wait>:

int
wait (pid_t pid)
{
  return syscall1 (SYS_WAIT, pid);
 804a3b4:	ff 74 24 04          	pushl  0x4(%esp)
 804a3b8:	6a 03                	push   $0x3
 804a3ba:	cd 30                	int    $0x30
 804a3bc:	83 c4 08             	add    $0x8,%esp
}
 804a3bf:	c3                   	ret    

0804a3c0 <create>:

bool
create (const char *file, unsigned initial_size)
{
  return syscall2 (SYS_CREATE, file, initial_size);
 804a3c0:	ff 74 24 08          	pushl  0x8(%esp)
 804a3c4:	ff 74 24 04          	pushl  0x4(%esp)
 804a3c8:	6a 04                	push   $0x4
 804a3ca:	cd 30                	int    $0x30
 804a3cc:	83 c4 0c             	add    $0xc,%esp
 804a3cf:	85 c0                	test   %eax,%eax
 804a3d1:	0f 95 c0             	setne  %al
}
 804a3d4:	c3                   	ret    

0804a3d5 <remove>:

bool
remove (const char *file)
{
  return syscall1 (SYS_REMOVE, file);
 804a3d5:	ff 74 24 04          	pushl  0x4(%esp)
 804a3d9:	6a 05                	push   $0x5
 804a3db:	cd 30                	int    $0x30
 804a3dd:	83 c4 08             	add    $0x8,%esp
 804a3e0:	85 c0                	test   %eax,%eax
 804a3e2:	0f 95 c0             	setne  %al
}
 804a3e5:	c3                   	ret    

0804a3e6 <open>:

int
open (const char *file)
{
  return syscall1 (SYS_OPEN, file);
 804a3e6:	ff 74 24 04          	pushl  0x4(%esp)
 804a3ea:	6a 06                	push   $0x6
 804a3ec:	cd 30                	int    $0x30
 804a3ee:	83 c4 08             	add    $0x8,%esp
}
 804a3f1:	c3                   	ret    

0804a3f2 <filesize>:

int
filesize (int fd) 
{
  return syscall1 (SYS_FILESIZE, fd);
 804a3f2:	ff 74 24 04          	pushl  0x4(%esp)
 804a3f6:	6a 07                	push   $0x7
 804a3f8:	cd 30                	int    $0x30
 804a3fa:	83 c4 08             	add    $0x8,%esp
}
 804a3fd:	c3                   	ret    

0804a3fe <read>:

int
read (int fd, void *buffer, unsigned size)
{
  return syscall3 (SYS_READ, fd, buffer, size);
 804a3fe:	ff 74 24 0c          	pushl  0xc(%esp)
 804a402:	ff 74 24 08          	pushl  0x8(%esp)
 804a406:	ff 74 24 04          	pushl  0x4(%esp)
 804a40a:	6a 08                	push   $0x8
 804a40c:	cd 30                	int    $0x30
 804a40e:	83 c4 10             	add    $0x10,%esp
}
 804a411:	c3                   	ret    

0804a412 <write>:

int
write (int fd, const void *buffer, unsigned size)
{
  return syscall3 (SYS_WRITE, fd, buffer, size);
 804a412:	ff 74 24 0c          	pushl  0xc(%esp)
 804a416:	ff 74 24 08          	pushl  0x8(%esp)
 804a41a:	ff 74 24 04          	pushl  0x4(%esp)
 804a41e:	6a 09                	push   $0x9
 804a420:	cd 30                	int    $0x30
 804a422:	83 c4 10             	add    $0x10,%esp
}
 804a425:	c3                   	ret    

0804a426 <seek>:

void
seek (int fd, unsigned position) 
{
  syscall2 (SYS_SEEK, fd, position);
 804a426:	ff 74 24 08          	pushl  0x8(%esp)
 804a42a:	ff 74 24 04          	pushl  0x4(%esp)
 804a42e:	6a 0a                	push   $0xa
 804a430:	cd 30                	int    $0x30
 804a432:	83 c4 0c             	add    $0xc,%esp
}
 804a435:	c3                   	ret    

0804a436 <tell>:

unsigned
tell (int fd) 
{
  return syscall1 (SYS_TELL, fd);
 804a436:	ff 74 24 04          	pushl  0x4(%esp)
 804a43a:	6a 0b                	push   $0xb
 804a43c:	cd 30                	int    $0x30
 804a43e:	83 c4 08             	add    $0x8,%esp
}
 804a441:	c3                   	ret    

0804a442 <close>:

void
close (int fd)
{
  syscall1 (SYS_CLOSE, fd);
 804a442:	ff 74 24 04          	pushl  0x4(%esp)
 804a446:	6a 0c                	push   $0xc
 804a448:	cd 30                	int    $0x30
 804a44a:	83 c4 08             	add    $0x8,%esp
}
 804a44d:	c3                   	ret    

0804a44e <mmap>:

mapid_t
mmap (int fd, void *addr)
{
  return syscall2 (SYS_MMAP, fd, addr);
 804a44e:	ff 74 24 08          	pushl  0x8(%esp)
 804a452:	ff 74 24 04          	pushl  0x4(%esp)
 804a456:	6a 0d                	push   $0xd
 804a458:	cd 30                	int    $0x30
 804a45a:	83 c4 0c             	add    $0xc,%esp
}
 804a45d:	c3                   	ret    

0804a45e <munmap>:

void
munmap (mapid_t mapid)
{
  syscall1 (SYS_MUNMAP, mapid);
 804a45e:	ff 74 24 04          	pushl  0x4(%esp)
 804a462:	6a 0e                	push   $0xe
 804a464:	cd 30                	int    $0x30
 804a466:	83 c4 08             	add    $0x8,%esp
}
 804a469:	c3                   	ret    

0804a46a <chdir>:

bool
chdir (const char *dir)
{
  return syscall1 (SYS_CHDIR, dir);
 804a46a:	ff 74 24 04          	pushl  0x4(%esp)
 804a46e:	6a 0f                	push   $0xf
 804a470:	cd 30                	int    $0x30
 804a472:	83 c4 08             	add    $0x8,%esp
 804a475:	85 c0                	test   %eax,%eax
 804a477:	0f 95 c0             	setne  %al
}
 804a47a:	c3                   	ret    

0804a47b <mkdir>:

bool
mkdir (const char *dir)
{
  return syscall1 (SYS_MKDIR, dir);
 804a47b:	ff 74 24 04          	pushl  0x4(%esp)
 804a47f:	6a 10                	push   $0x10
 804a481:	cd 30                	int    $0x30
 804a483:	83 c4 08             	add    $0x8,%esp
 804a486:	85 c0                	test   %eax,%eax
 804a488:	0f 95 c0             	setne  %al
}
 804a48b:	c3                   	ret    

0804a48c <readdir>:

bool
readdir (int fd, char name[READDIR_MAX_LEN + 1]) 
{
  return syscall2 (SYS_READDIR, fd, name);
 804a48c:	ff 74 24 08          	pushl  0x8(%esp)
 804a490:	ff 74 24 04          	pushl  0x4(%esp)
 804a494:	6a 11                	push   $0x11
 804a496:	cd 30                	int    $0x30
 804a498:	83 c4 0c             	add    $0xc,%esp
 804a49b:	85 c0                	test   %eax,%eax
 804a49d:	0f 95 c0             	setne  %al
}
 804a4a0:	c3                   	ret    

0804a4a1 <isdir>:

bool
isdir (int fd) 
{
  return syscall1 (SYS_ISDIR, fd);
 804a4a1:	ff 74 24 04          	pushl  0x4(%esp)
 804a4a5:	6a 12                	push   $0x12
 804a4a7:	cd 30                	int    $0x30
 804a4a9:	83 c4 08             	add    $0x8,%esp
 804a4ac:	85 c0                	test   %eax,%eax
 804a4ae:	0f 95 c0             	setne  %al
}
 804a4b1:	c3                   	ret    

0804a4b2 <inumber>:

int
inumber (int fd) 
{
  return syscall1 (SYS_INUMBER, fd);
 804a4b2:	ff 74 24 04          	pushl  0x4(%esp)
 804a4b6:	6a 13                	push   $0x13
 804a4b8:	cd 30                	int    $0x30
 804a4ba:	83 c4 08             	add    $0x8,%esp
}
 804a4bd:	c3                   	ret    
 804a4be:	90                   	nop
 804a4bf:	90                   	nop

0804a4c0 <flush>:
}

/* Flushes the buffer in AUX. */
static void
flush (struct vhprintf_aux *aux)
{
 804a4c0:	53                   	push   %ebx
 804a4c1:	83 ec 18             	sub    $0x18,%esp
 804a4c4:	89 c3                	mov    %eax,%ebx
  if (aux->p > aux->buf)
 804a4c6:	8b 40 40             	mov    0x40(%eax),%eax
 804a4c9:	39 d8                	cmp    %ebx,%eax
 804a4cb:	76 15                	jbe    804a4e2 <flush+0x22>
    write (aux->handle, aux->buf, aux->p - aux->buf);
 804a4cd:	29 d8                	sub    %ebx,%eax
 804a4cf:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a4d3:	89 5c 24 04          	mov    %ebx,0x4(%esp)
 804a4d7:	8b 43 48             	mov    0x48(%ebx),%eax
 804a4da:	89 04 24             	mov    %eax,(%esp)
 804a4dd:	e8 30 ff ff ff       	call   804a412 <write>
  aux->p = aux->buf;
 804a4e2:	89 5b 40             	mov    %ebx,0x40(%ebx)
}
 804a4e5:	83 c4 18             	add    $0x18,%esp
 804a4e8:	5b                   	pop    %ebx
 804a4e9:	c3                   	ret    

0804a4ea <add_char>:

/* Adds C to the buffer in AUX, flushing it if the buffer fills
   up. */
static void
add_char (char c, void *aux_) 
{
 804a4ea:	53                   	push   %ebx
 804a4eb:	83 ec 08             	sub    $0x8,%esp
 804a4ee:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  struct vhprintf_aux *aux = aux_;
  *aux->p++ = c;
 804a4f2:	8b 43 40             	mov    0x40(%ebx),%eax
 804a4f5:	8b 54 24 10          	mov    0x10(%esp),%edx
 804a4f9:	88 10                	mov    %dl,(%eax)
 804a4fb:	83 c0 01             	add    $0x1,%eax
 804a4fe:	89 43 40             	mov    %eax,0x40(%ebx)
  if (aux->p >= aux->buf + sizeof aux->buf)
 804a501:	8d 53 40             	lea    0x40(%ebx),%edx
 804a504:	39 d0                	cmp    %edx,%eax
 804a506:	72 07                	jb     804a50f <add_char+0x25>
    flush (aux);
 804a508:	89 d8                	mov    %ebx,%eax
 804a50a:	e8 b1 ff ff ff       	call   804a4c0 <flush>
  aux->char_cnt++;
 804a50f:	83 43 44 01          	addl   $0x1,0x44(%ebx)
}
 804a513:	83 c4 08             	add    $0x8,%esp
 804a516:	5b                   	pop    %ebx
 804a517:	c3                   	ret    

0804a518 <putchar>:
}

/* Writes C to the console. */
int
putchar (int c) 
{
 804a518:	53                   	push   %ebx
 804a519:	83 ec 28             	sub    $0x28,%esp
 804a51c:	8b 5c 24 30          	mov    0x30(%esp),%ebx
  char c2 = c;
 804a520:	88 5c 24 1f          	mov    %bl,0x1f(%esp)
  write (STDOUT_FILENO, &c2, 1);
 804a524:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 804a52b:	00 
 804a52c:	8d 44 24 1f          	lea    0x1f(%esp),%eax
 804a530:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a534:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a53b:	e8 d2 fe ff ff       	call   804a412 <write>
  return c;
}
 804a540:	89 d8                	mov    %ebx,%eax
 804a542:	83 c4 28             	add    $0x28,%esp
 804a545:	5b                   	pop    %ebx
 804a546:	c3                   	ret    

0804a547 <puts>:

/* Writes string S to the console, followed by a new-line
   character. */
int
puts (const char *s) 
{
 804a547:	57                   	push   %edi
 804a548:	83 ec 18             	sub    $0x18,%esp
 804a54b:	8b 54 24 20          	mov    0x20(%esp),%edx
  write (STDOUT_FILENO, s, strlen (s));
 804a54f:	89 d7                	mov    %edx,%edi
 804a551:	b8 00 00 00 00       	mov    $0x0,%eax
 804a556:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
 804a55b:	f2 ae                	repnz scas %es:(%edi),%al
 804a55d:	f7 d1                	not    %ecx
 804a55f:	83 e9 01             	sub    $0x1,%ecx
 804a562:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 804a566:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a56a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a571:	e8 9c fe ff ff       	call   804a412 <write>
  putchar ('\n');
 804a576:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
 804a57d:	e8 96 ff ff ff       	call   804a518 <putchar>

  return 0;
}
 804a582:	b8 00 00 00 00       	mov    $0x0,%eax
 804a587:	83 c4 18             	add    $0x18,%esp
 804a58a:	5f                   	pop    %edi
 804a58b:	c3                   	ret    

0804a58c <vhprintf>:
/* Formats the printf() format specification FORMAT with
   arguments given in ARGS and writes the output to the given
   HANDLE. */
int
vhprintf (int handle, const char *format, va_list args) 
{
 804a58c:	53                   	push   %ebx
 804a58d:	83 ec 68             	sub    $0x68,%esp
  struct vhprintf_aux aux;
  aux.p = aux.buf;
 804a590:	8d 5c 24 14          	lea    0x14(%esp),%ebx
 804a594:	89 5c 24 54          	mov    %ebx,0x54(%esp)
  aux.char_cnt = 0;
 804a598:	c7 44 24 58 00 00 00 	movl   $0x0,0x58(%esp)
 804a59f:	00 
  aux.handle = handle;
 804a5a0:	8b 44 24 70          	mov    0x70(%esp),%eax
 804a5a4:	89 44 24 5c          	mov    %eax,0x5c(%esp)
  __vprintf (format, args, add_char, &aux);
 804a5a8:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
 804a5ac:	c7 44 24 08 ea a4 04 	movl   $0x804a4ea,0x8(%esp)
 804a5b3:	08 
 804a5b4:	8b 44 24 78          	mov    0x78(%esp),%eax
 804a5b8:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a5bc:	8b 44 24 74          	mov    0x74(%esp),%eax
 804a5c0:	89 04 24             	mov    %eax,(%esp)
 804a5c3:	e8 1e e7 ff ff       	call   8048ce6 <__vprintf>
  flush (&aux);
 804a5c8:	89 d8                	mov    %ebx,%eax
 804a5ca:	e8 f1 fe ff ff       	call   804a4c0 <flush>
  return aux.char_cnt;
}
 804a5cf:	8b 44 24 58          	mov    0x58(%esp),%eax
 804a5d3:	83 c4 68             	add    $0x68,%esp
 804a5d6:	5b                   	pop    %ebx
 804a5d7:	c3                   	ret    

0804a5d8 <hprintf>:
}

/* Like printf(), but writes output to the given HANDLE. */
int
hprintf (int handle, const char *format, ...) 
{
 804a5d8:	83 ec 1c             	sub    $0x1c,%esp
  va_list args;
  int retval;

  va_start (args, format);
 804a5db:	8d 44 24 28          	lea    0x28(%esp),%eax
  retval = vhprintf (handle, format, args);
 804a5df:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a5e3:	8b 44 24 24          	mov    0x24(%esp),%eax
 804a5e7:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a5eb:	8b 44 24 20          	mov    0x20(%esp),%eax
 804a5ef:	89 04 24             	mov    %eax,(%esp)
 804a5f2:	e8 95 ff ff ff       	call   804a58c <vhprintf>
  va_end (args);

  return retval;
}
 804a5f7:	83 c4 1c             	add    $0x1c,%esp
 804a5fa:	c3                   	ret    

0804a5fb <vprintf>:

/* The standard vprintf() function,
   which is like printf() but uses a va_list. */
int
vprintf (const char *format, va_list args) 
{
 804a5fb:	83 ec 1c             	sub    $0x1c,%esp
  return vhprintf (STDOUT_FILENO, format, args);
 804a5fe:	8b 44 24 24          	mov    0x24(%esp),%eax
 804a602:	89 44 24 08          	mov    %eax,0x8(%esp)
 804a606:	8b 44 24 20          	mov    0x20(%esp),%eax
 804a60a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a60e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 804a615:	e8 72 ff ff ff       	call   804a58c <vhprintf>
}
 804a61a:	83 c4 1c             	add    $0x1c,%esp
 804a61d:	c3                   	ret    
 804a61e:	90                   	nop
 804a61f:	90                   	nop

0804a620 <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
 804a620:	55                   	push   %ebp
 804a621:	89 e5                	mov    %esp,%ebp
 804a623:	53                   	push   %ebx
 804a624:	83 ec 14             	sub    $0x14,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
 804a627:	8b 45 04             	mov    0x4(%ebp),%eax
 804a62a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a62e:	c7 04 24 8a ab 04 08 	movl   $0x804ab8a,(%esp)
 804a635:	e8 66 e6 ff ff       	call   8048ca0 <printf>
  for (frame = __builtin_frame_address (1);
 804a63a:	8b 5d 00             	mov    0x0(%ebp),%ebx
 804a63d:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
 804a643:	76 27                	jbe    804a66c <debug_backtrace+0x4c>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
 804a645:	83 3b 00             	cmpl   $0x0,(%ebx)
 804a648:	74 22                	je     804a66c <debug_backtrace+0x4c>
       frame = frame[0]) 
    printf (" %p", frame[1]);
 804a64a:	8b 43 04             	mov    0x4(%ebx),%eax
 804a64d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a651:	c7 04 24 95 ab 04 08 	movl   $0x804ab95,(%esp)
 804a658:	e8 43 e6 ff ff       	call   8048ca0 <printf>
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
 804a65d:	8b 1b                	mov    (%ebx),%ebx
{
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
 804a65f:	81 fb ff 0f 00 00    	cmp    $0xfff,%ebx
 804a665:	76 05                	jbe    804a66c <debug_backtrace+0x4c>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
 804a667:	83 3b 00             	cmpl   $0x0,(%ebx)
 804a66a:	75 de                	jne    804a64a <debug_backtrace+0x2a>
       frame = frame[0]) 
    printf (" %p", frame[1]);
  printf (".\n");
 804a66c:	c7 04 24 9b aa 04 08 	movl   $0x804aa9b,(%esp)
 804a673:	e8 cf fe ff ff       	call   804a547 <puts>

  if (!explained) 
 804a678:	80 3d 24 c3 04 08 00 	cmpb   $0x0,0x804c324
 804a67f:	75 13                	jne    804a694 <debug_backtrace+0x74>
    {
      explained = true;
 804a681:	c6 05 24 c3 04 08 01 	movb   $0x1,0x804c324
      printf ("The `backtrace' program can make call stacks useful.\n"
 804a688:	c7 04 24 34 ad 04 08 	movl   $0x804ad34,(%esp)
 804a68f:	e8 b3 fe ff ff       	call   804a547 <puts>
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
 804a694:	83 c4 14             	add    $0x14,%esp
 804a697:	5b                   	pop    %ebx
 804a698:	5d                   	pop    %ebp
 804a699:	c3                   	ret    
